
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://gentletomzerg.github.io/blog/2022/07/01/notes---xv6/">
      
      
      
        <link rel="next" href="../../../../2023/05/20/categorical-syllogisms/">
      
      
      <link rel="icon" href="../../../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.18">
    
    
      
        <title>Notes - Xv6 - GentleTomZerg Blog</title>
      
    
    
      <link rel="stylesheet" href="../../../../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=BioRhyme:300,300i,400,400i,700,700i%7CFira+Code:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"BioRhyme";--md-code-font:"Fira Code"}</style>
      
    
    
    <script>__md_scope=new URL("../../../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
   <link href="../../../../../assets/stylesheets/glightbox.min.css" rel="stylesheet"/><style>
    html.glightbox-open { overflow: initial; height: 100%; }
    .gslide-title { margin-top: 0px; user-select: text; }
    .gslide-desc { color: #666; user-select: text; }
    .gslide-image img { background: white; }
    .gscrollbar-fixer { padding-right: 15px; }
    .gdesc-inner { font-size: 0.75rem; }
    body[data-md-color-scheme="slate"] .gdesc-inner { background: var(--md-default-bg-color);}
    body[data-md-color-scheme="slate"] .gslide-title { color: var(--md-default-fg-color);}
    body[data-md-color-scheme="slate"] .gslide-desc { color: var(--md-default-fg-color);}</style> <script src="../../../../../assets/javascripts/glightbox.min.js"></script></head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="orange">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#chapter1-operating-systems-interfaces" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../../.." title="GentleTomZerg Blog" class="md-header__button md-logo" aria-label="GentleTomZerg Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            GentleTomZerg Blog
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Notes - Xv6
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="orange"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="orange" data-md-color-accent="grey"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../.." class="md-tabs__link">
          
  
  
  Home

        </a>
      </li>
    
  

      
        
  
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../../../../" class="md-tabs__link">
          
  
  
  Blog

        </a>
      </li>
    
  

      
        
  
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../../../../../art/" class="md-tabs__link">
          
  
  
  Art

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
                
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" hidden>
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../../.." title="GentleTomZerg Blog" class="md-nav__button md-logo" aria-label="GentleTomZerg Blog" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    GentleTomZerg Blog
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_1" >
        
          
          <label class="md-nav__link" for="__nav_1" id="__nav_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_1">
            <span class="md-nav__icon md-icon"></span>
            Home
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ðŸ‘‹ Hi! Iâ€™m Tom
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
      
        
        
      
      
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  
  <span class="md-ellipsis">
    Blog
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Blog
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      <a href="../../../../" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Blog
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Archive
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            Archive
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../archive/2025/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2025
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../archive/2024/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2024
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../archive/2023/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2023
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../archive/2022/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    2022
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Categories
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Categories
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../category/computer-science/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Computer Science
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../category/logic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Logic
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
    
  
  
    <li class="md-nav__item">
      <a href="../../../../category/software-engineering/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Software Engineering
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
      
      
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Art
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Art
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../art/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../../../art/collection1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Collection1
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
  <div class="md-content md-content--post" data-md-component="content">
    <div class="md-sidebar md-sidebar--post" data-md-component="sidebar" data-md-type="navigation">
      <div class="md-sidebar__scrollwrap">
        <div class="md-sidebar__inner md-post">
          <nav class="md-nav md-nav--primary">
            <div class="md-post__back">
              <div class="md-nav__title md-nav__container">
                <a href="../../../../" class="md-nav__link">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
                  <span class="md-ellipsis">
                    Back to index
                  </span>
                </a>
              </div>
            </div>
            
              <div class="md-post__authors md-typeset">
                
                  <div class="md-profile md-post__profile">
                    <span class="md-author md-author--long">
                      <img src="https://avatars.githubusercontent.com/u/51043088?s=400&u=e233a4511c1fc3a60a8afcc9b5a18839c3a1bb9e&v=4" alt="Tom">
                    </span>
                    <span class="md-profile__description">
                      <strong>
                        
                          Tom
                        
                      </strong>
                      <br>
                      Creator
                    </span>
                  </div>
                
              </div>
            
            <ul class="md-post__meta md-nav__list">
              <li class="md-nav__item md-nav__item--section">
                <div class="md-post__title">
                  <span class="md-ellipsis">
                    Metadata
                  </span>
                </div>
                <nav class="md-nav">
                  <ul class="md-nav__list">
                    <li class="md-nav__item">
                      <div class="md-nav__link">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 19H5V8h14m-3-7v2H8V1H6v2H5c-1.11 0-2 .89-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V5a2 2 0 0 0-2-2h-1V1m-1 11h-5v5h5z"/></svg>
                        <time datetime="2022-07-01 00:00:00+00:00" class="md-ellipsis">July 1, 2022</time>
                      </div>
                    </li>
                    
                    
                      <li class="md-nav__item">
                        <div class="md-nav__link">
                          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9 3v15h3V3zm3 2 4 13 3-1-4-13zM5 5v13h3V5zM3 19v2h18v-2z"/></svg>
                          <span class="md-ellipsis">
                            in
                            
                              <a href="../../../../category/computer-science/">Computer Science</a></span>
                        </div>
                      </li>
                    
                    
                      
                      <li class="md-nav__item">
                        <div class="md-nav__link">
                          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 20a8 8 0 0 0 8-8 8 8 0 0 0-8-8 8 8 0 0 0-8 8 8 8 0 0 0 8 8m0-18a10 10 0 0 1 10 10 10 10 0 0 1-10 10C6.47 22 2 17.5 2 12A10 10 0 0 1 12 2m.5 5v5.25l4.5 2.67-.75 1.23L11 13V7z"/></svg>
                          <span class="md-ellipsis">
                            
                              165 min read
                            
                          </span>
                        </div>
                      </li>
                    
                  </ul>
                </nav>
              </li>
            </ul>
            
          </nav>
          
            

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#chapter1-operating-systems-interfaces" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter1. Operating Systems Interfaces
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter1. Operating Systems Interfaces">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11-process-and-memory" class="md-nav__link">
    <span class="md-ellipsis">
      1.1 Process and Memory
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12-io-and-file-descriptors" class="md-nav__link">
    <span class="md-ellipsis">
      1.2 I/O and File descriptors
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#13-pipes" class="md-nav__link">
    <span class="md-ellipsis">
      1.3 Pipes(*)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#14-file-system" class="md-nav__link">
    <span class="md-ellipsis">
      1.4 File system
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter2-operating-system-organization" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter2. Operating system organization
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter2. Operating system organization">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#21-abstracting-physical-resources" class="md-nav__link">
    <span class="md-ellipsis">
      2.1 Abstracting physical resources
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#22-user-mode-supervisor-mode-and-system-calls" class="md-nav__link">
    <span class="md-ellipsis">
      2.2 User mode, supervisor mode, and system calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#23-kernel-organization" class="md-nav__link">
    <span class="md-ellipsis">
      2.3 Kernel organization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#25-process-overview" class="md-nav__link">
    <span class="md-ellipsis">
      2.5 Process overview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#26-code-starting-xv6-and-the-first-process" class="md-nav__link">
    <span class="md-ellipsis">
      2.6 Code: starting xv6 and the first process
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter3-page-tables" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter3. Page tables
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter3. Page tables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#31-paging-hardware" class="md-nav__link">
    <span class="md-ellipsis">
      3.1 Paging hardware
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#32-kernel-address-space" class="md-nav__link">
    <span class="md-ellipsis">
      3.2 Kernel address space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#33-code-creating-an-address-space" class="md-nav__link">
    <span class="md-ellipsis">
      3.3 Code: creating an address space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#34-physical-memory-allocation" class="md-nav__link">
    <span class="md-ellipsis">
      3.4 Physical memory allocation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#35-code-physical-memory-allocator" class="md-nav__link">
    <span class="md-ellipsis">
      3.5 Code: Physical memory allocator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#36-process-address-space" class="md-nav__link">
    <span class="md-ellipsis">
      3.6 Process address space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#37-code-sbrk" class="md-nav__link">
    <span class="md-ellipsis">
      3.7 Code: sbrk
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#38-code-exec" class="md-nav__link">
    <span class="md-ellipsis">
      3.8 Code: exec
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter4-traps-and-system-calls" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter4. Traps and system calls
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter4. Traps and system calls">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#trap" class="md-nav__link">
    <span class="md-ellipsis">
      Trap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#41-risc-v-trap-machinery" class="md-nav__link">
    <span class="md-ellipsis">
      4.1 RISC-V trap machinery
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#42-traps-from-user-space" class="md-nav__link">
    <span class="md-ellipsis">
      4.2 Traps from user space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#43-code-calling-system-calls" class="md-nav__link">
    <span class="md-ellipsis">
      4.3 Code: Calling system calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#44-code-system-call-arguments" class="md-nav__link">
    <span class="md-ellipsis">
      4.4 Code: System call arguments
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#45-traps-from-kernel-space" class="md-nav__link">
    <span class="md-ellipsis">
      4.5 Traps from kernel space
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#46-page-fault-exceptions" class="md-nav__link">
    <span class="md-ellipsis">
      4.6 Page-fault exceptions
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter5-interrupts-and-device-drivers" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter5. Interrupts and device drivers
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter5. Interrupts and device drivers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#51-code-console-input" class="md-nav__link">
    <span class="md-ellipsis">
      5.1 Code: Console input
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#52-code-console-output" class="md-nav__link">
    <span class="md-ellipsis">
      5.2 Code: Console output
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#53-concurrency-in-drivers" class="md-nav__link">
    <span class="md-ellipsis">
      5.3 Concurrency in drivers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#54-timer-interrupts" class="md-nav__link">
    <span class="md-ellipsis">
      5.4 Timer interrupts
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#55-real-world" class="md-nav__link">
    <span class="md-ellipsis">
      5.5 Real world
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter6-locking" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter6. Locking
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter6. Locking">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#61-race-conditions" class="md-nav__link">
    <span class="md-ellipsis">
      6.1 Race conditions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#62-code-locks" class="md-nav__link">
    <span class="md-ellipsis">
      6.2 Code: Locks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#63-code-using-locks" class="md-nav__link">
    <span class="md-ellipsis">
      6.3 Code: Using locks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#64-deadlock-and-lock-ordering" class="md-nav__link">
    <span class="md-ellipsis">
      6.4 Deadlock and lock ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#65-locks-and-interrupt-handlers" class="md-nav__link">
    <span class="md-ellipsis">
      6.5 Locks and interrupt handlers
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#66-instruction-and-memory-ordering" class="md-nav__link">
    <span class="md-ellipsis">
      6.6 Instruction and memory ordering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#67-sleep-locks" class="md-nav__link">
    <span class="md-ellipsis">
      6.7 Sleep locks
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-7-scheduling" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter 7 Scheduling
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 7 Scheduling">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#71-multiplexing" class="md-nav__link">
    <span class="md-ellipsis">
      7.1 Multiplexing
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#72-code-context-switching" class="md-nav__link">
    <span class="md-ellipsis">
      7.2 Code: Context switching
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#73-code-scheduling" class="md-nav__link">
    <span class="md-ellipsis">
      7.3 Code: Scheduling
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#74-code-mycpu-and-myproc" class="md-nav__link">
    <span class="md-ellipsis">
      7.4 Code: mycpu and myproc
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#75-sleep-and-wakeup" class="md-nav__link">
    <span class="md-ellipsis">
      7.5 Sleep and wakeup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#76-code-sleep-and-wakeup" class="md-nav__link">
    <span class="md-ellipsis">
      7.6 Code: Sleep and wakeup
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#77-code-pipes" class="md-nav__link">
    <span class="md-ellipsis">
      7.7 Code: Pipes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#78-code-wait-exit-and-kill" class="md-nav__link">
    <span class="md-ellipsis">
      7.8 Code: Wait, exit, and kill
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#79-real-world" class="md-nav__link">
    <span class="md-ellipsis">
      7.9 Real world
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#chapter-8-file-system" class="md-nav__link">
    <span class="md-ellipsis">
      Chapter 8 File system
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Chapter 8 File system">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#81-overview" class="md-nav__link">
    <span class="md-ellipsis">
      8.1 Overview
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#82-buffer-cache-layer" class="md-nav__link">
    <span class="md-ellipsis">
      8.2 Buffer cache layer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#83-code-buffer-cache" class="md-nav__link">
    <span class="md-ellipsis">
      8.3 Code: Buffer cache
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#87-code-block-allocator" class="md-nav__link">
    <span class="md-ellipsis">
      8.7 Code: Block allocator
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#88-inode-layer" class="md-nav__link">
    <span class="md-ellipsis">
      8.8 Inode layer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#89-code-inodes" class="md-nav__link">
    <span class="md-ellipsis">
      8.9 Code: Inodes
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#810-code-inode-content" class="md-nav__link">
    <span class="md-ellipsis">
      8.10 Code: Inode content
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#811-code-directory-layer" class="md-nav__link">
    <span class="md-ellipsis">
      8.11 Code: directory layer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#812-code-path-names" class="md-nav__link">
    <span class="md-ellipsis">
      8.12 Code: Path names
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#813-file-descriptor-layer" class="md-nav__link">
    <span class="md-ellipsis">
      8.13 File descriptor layer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#814-code-system-calls" class="md-nav__link">
    <span class="md-ellipsis">
      8.14 Code: System calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#84-logging-layer" class="md-nav__link">
    <span class="md-ellipsis">
      8.4 Logging layer
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#85-log-design" class="md-nav__link">
    <span class="md-ellipsis">
      8.5 Log design
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#86-code-logging" class="md-nav__link">
    <span class="md-ellipsis">
      8.6 Code: logging
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#journaling-the-linux-ext2fs-filesystem" class="md-nav__link">
    <span class="md-ellipsis">
      Journaling the Linux ext2fs Filesystem
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#labs" class="md-nav__link">
    <span class="md-ellipsis">
      Labs
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Labs">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gdb" class="md-nav__link">
    <span class="md-ellipsis">
      GDB
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-xv6-and-unix-utilities" class="md-nav__link">
    <span class="md-ellipsis">
      Lab: Xv6 and Unix utilities
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-system-calls" class="md-nav__link">
    <span class="md-ellipsis">
      Lab: system calls
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-page-table" class="md-nav__link">
    <span class="md-ellipsis">
      Lab: Page Table
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lab3-page-tables" class="md-nav__link">
    <span class="md-ellipsis">
      Lab3 : Page Tables
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lab3 : Page Tables">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lab-31-print-a-page-table" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 3.1 Print a page table
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-32-a-kernel-page-table-per-process" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 3.2 A kernel page table per process
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lab4-traps" class="md-nav__link">
    <span class="md-ellipsis">
      Lab4: Traps
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lab4: Traps">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lab-32-alarm" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 3.2 Alarm
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#lab5-lazy-allocation" class="md-nav__link">
    <span class="md-ellipsis">
      Lab5 Lazy Allocation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lab5 Lazy Allocation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lab-51-eliminate-allocation-from-sbrk" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 5.1 Eliminate allocation from sbrk()
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-52-lazy-allocation" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 5.2 Lazy Allocation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lab-53-lazytests-and-usertests" class="md-nav__link">
    <span class="md-ellipsis">
      Lab 5.3 Lazytests and Usertests
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
          
        </div>
      </div>
    </div>
    <article class="md-content__inner md-typeset">
      
        
  


  <nav class="md-tags" >
    
      
      
      
        <span class="md-tag">operating system</span>
      
    
  </nav>



  <h1>Notes - Xv6</h1>

<div><h2 id="chapter1-operating-systems-interfaces">Chapter1. Operating Systems Interfaces<a class="headerlink" href="#chapter1-operating-systems-interfaces" title="Permanent link">Â¶</a></h2>
<p>When a <strong>process</strong> needs to invoke a <strong>kernel service</strong>, it invokes a <strong>system call</strong>, one of the calls in the operating systemâ€™s interface. The system call enters the kernel; the kernel performs the service and returns. Thus a process alternates between executing in user space and kernel space.</p>
<p>The <strong>kernel</strong> uses the <strong>hardware protection</strong> mechanisms provided by a CPU to ensure that <strong>each process executing in user space can access only its own memory</strong>. The kernel executes with the hardware privileges required to implement these protections; user programs execute without those privileges.</p>
<p>When a user program invokes a system call, the hardware raises the privilege level and starts executing a pre-arranged function in the kernel.</p>
<!-- more -->

<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220307213809995.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220307213809995" src="../../../../assets/Operating%20Systems.assets/image-20220307213809995.png"></a></p>
<h3 id="11-process-and-memory">1.1 Process and Memory<a class="headerlink" href="#11-process-and-memory" title="Permanent link">Â¶</a></h3>
<h4 id="xv6-system-calls-table">Xv6 System Calls Table<a class="headerlink" href="#xv6-system-calls-table" title="Permanent link">Â¶</a></h4>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220307214019798.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220307214019798" src="../../../../assets/Operating%20Systems.assets/image-20220307214019798.png"></a></p>
<h4 id="system-call-example-fork">System Call Example : fork()<a class="headerlink" href="#system-call-example-fork" title="Permanent link">Â¶</a></h4>
<p><code>fork</code> <strong>creates a new process</strong>, called the child process, with <strong>exactly the same memory contents as the calling process</strong>, called the parent process. Fork <strong>returns in both the parent and the child</strong>.</p>
<p>In the <code>parent</code>, fork <strong>returns the childâ€™s PID</strong>;</p>
<p>in the <code>child</code>, fork <strong>returns zero</strong>.</p>
<p><code>exit</code> system call causes the calling process to <strong>stop executing</strong> and to <strong>release resources such as memory and open files</strong>. Exit takes an integer status argument, conventionally <strong>0 to indicate success and 1 to indicate failure</strong>.</p>
<p><code>wait</code> system call <strong>returns the PID of an exited (or killed) child of the current process</strong> and copies the exit status of the child to the address <code>(int *)0</code> passed to wait;</p>
<p>if none of the callerâ€™s children has exited, wait waits for one to do so.</p>
<p>If the caller has no children, wait immediately returns -1.</p>
<p>If the parent doesnâ€™t care about the exit status of a child, it can pass a 0 address to wait.</p>
<div class="highlight"><pre><span></span><code><span class="cp">##include &lt;stdio.h&gt;</span>
<span class="cp">##include &lt;stdlib.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"parent: child=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span>
<span class="w">        </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wait</span><span class="p">((</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"child %d is done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"child: exiting</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"fork error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//Output:</span>
<span class="c1">//parent: child=4821</span>
<span class="c1">//child: exiting</span>
<span class="c1">//child 4821 is done</span>
</code></pre></div>
<h4 id="system-call-example-shell">System Call Example: shell<a class="headerlink" href="#system-call-example-shell" title="Permanent link">Â¶</a></h4>
<p>When <code>exec</code> succeeds, it <strong>does not return to the calling program</strong>; instead, the instructions loaded from the file <strong>start executing at the entry point declared in the ELF header</strong>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Read and run input commands.</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">getcmd</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'c'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'d'</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">' '</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// Chdir must be called by the parent, not the child.</span>
<span class="w">      </span><span class="n">buf</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">  </span><span class="c1">// chop \n</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">chdir</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"cannot cd %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="c1">//shellåˆ›å»ºå­è¿›ç¨‹åŽ»runcmdï¼Œshellï¼ˆçˆ¶è¿›ç¨‹ï¼‰è¿›å…¥ç­‰å¾…çŠ¶æ€</span>
<span class="w">    </span><span class="c1">//shellç»™runcmdè®©å‡ºCPU</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">fork1</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">runcmd</span><span class="p">(</span><span class="n">parsecmd</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
<span class="w">    </span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">fork1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>

<span class="w">  </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"fork"</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="how-does-system-calls-shown-above-allocate-memory">How does system calls shown above allocate memory<a class="headerlink" href="#how-does-system-calls-shown-above-allocate-memory" title="Permanent link">Â¶</a></h4>
<p>Xv6 allocates most user-space memory implicitly: <strong>fork</strong> allocates the memory required <strong>for the childâ€™s copy of the parentâ€™s memory</strong>, and <strong>exec</strong> allocates enough memory to <strong>hold the executable file</strong>. A process that needs more memory at run-time (perhaps for malloc) can call <strong><code>sbrk(n)</code></strong> to grow its data memory by n bytes; <strong><code>sbrk</code></strong> returns the location of the new memory.</p>
<h3 id="12-io-and-file-descriptors">1.2 I/O and File descriptors<a class="headerlink" href="#12-io-and-file-descriptors" title="Permanent link">Â¶</a></h3>
<p>A <strong><code>file descriptor</code></strong> is a small integer representing <strong>a kernel-managed object</strong> that a process may read from or write to.</p>
<p>A process may obtain a file descriptor by opening a file, directory, or device, or by creating a pipe, or by duplicating an existing descriptor. For simplicity weâ€™ll often refer to the object a file descriptor refers to as a â€œfileâ€; the <strong>file descriptor interface abstracts away the differences between files, pipes, and devices, making them all look like streams of bytes</strong>.</p>
<p>Internally, the <strong>xv6 kernel uses the file descriptor as an index into a <code>per-process table</code></strong>, so that <strong>every process has a private space of file descriptors starting at zero</strong>. By convention, a process</p>
<p>reads from file descriptor <strong>0 (standard input)</strong>,</p>
<p>writes output to file descriptor <strong>1 (standard output)</strong>,</p>
<p>writes error messages to file descriptor <strong>2 (standard error)</strong>.</p>
<h4 id="read-write-close">read(), write(), close()<a class="headerlink" href="#read-write-close" title="Permanent link">Â¶</a></h4>
<p><strong><code>Each file descriptor that refers to a file has an offset associated with it</code></strong></p>
<p>call <strong><code>read(fd, buf, n)</code></strong> reads at most n bytes from the file descriptor <code>fd</code>, copies them into <code>buf</code>, and returns the number of bytes read.</p>
<p>call <strong><code>write(fd, buf, n)</code></strong> writes n bytes from <code>buf</code> to the file descriptor <code>fd</code> and returns the number of bytes written.</p>
<p>The <strong><code>close</code></strong> system call releases a file descriptor, making it free for reuse by a future open, pipe, or dup system call (see below). <strong>A newly allocated file descriptor is always the <u>lowest numbered unused descriptor</u> of the current process</strong>.</p>
<h4 id="cat-source-code"><code>cat</code> source code<a class="headerlink" href="#cat-source-code" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="cp">##include "kernel/types.h"</span>
<span class="cp">##include "kernel/stat.h"</span>
<span class="cp">##include "user/user.h"</span>

<span class="kt">char</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

<span class="kt">void</span>
<span class="nf">cat</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="k">while</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">)))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"cat: write error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"cat: read error</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="c1">//æœªç»™å‡ºæ–‡ä»¶åï¼Œè¾“å…¥æµé»˜è®¤ä¸º0ï¼ˆæ ‡å‡†è¾“å…¥æµï¼‰</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">){</span>
<span class="w">    </span><span class="n">cat</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="c1">//æœ‰æ–‡ä»¶åï¼Œç”¨openæ‰“å¼€ï¼ŒèŽ·å¾—kernelç»™è¯¥æ–‡ä»¶åˆ†é…çš„å…·æœ‰æœ€å°å€¼çš„fd</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">argc</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"cat: cannot open %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">cat</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">    </span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="io-redirection">I/O Redirection<a class="headerlink" href="#io-redirection" title="Permanent link">Â¶</a></h4>
<p><code>Fork</code> copies the parentâ€™s <strong>file descriptor table</strong> along with its memory, so that the <strong>child starts with exactly the same open files as the parent</strong>.</p>
<p>system call <code>exec</code> replaces the calling processâ€™s memory but <strong>preserves its file table</strong></p>
<p><code>shell$ cat &lt; input.txt</code>: å°†file descriptor 0 é‡å®šå‘åˆ°äº†<code>input.txt</code>ï¼Œä»Žè€Œ<code>cat</code>æŽ¥æ”¶åˆ°çš„è¾“å…¥ä¸å†ä»Žé”®ç›˜æ¥ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"cat"</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="c1">//shellè¿›ç¨‹waitï¼Œå­è¿›ç¨‹æ‰§è¡Œcat</span>
<span class="c1">//å­è¿›ç¨‹ release 0ï¼ˆstandard inputï¼‰</span>
<span class="c1">//ä»Žè€Œinput.txtä¸€å®šèƒ½æ‹¿åˆ°0ä½œä¸ºfd</span>
<span class="c1">//å­è¿›ç¨‹catçš„è¾“å…¥æµå°±ä»Žé”®ç›˜å˜ä¸ºäº†input.txt</span>
<span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">open</span><span class="p">(</span><span class="s">"input.txt"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span>
<span class="n">exec</span><span class="p">(</span><span class="s">"cat"</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The <strong>parent processâ€™s file descriptors are not changed by this sequence</strong>, since it modifies only the childâ€™s descriptors.</p>
<p>è¿™æ ·åšï¼Œshellçš„file descriptor(æŒ‡å‘æ˜¾å­˜)ä¾ç„¶è¢«shellè¿›ç¨‹ä¿å­˜ç€ï¼Œä½†æ˜¯catè¿›ç¨‹çš„file descriptorå·²ç»è¢«æ”¹å˜äº†ï¼ˆæŒ‡å‘æ–‡ä»¶ï¼‰ã€‚ä½†**ä¸¤ä¸ªè¿›ç¨‹å¹¶æ²¡æœ‰å—åˆ°è¯¥å€¼æ”¹å˜çš„å½±å“ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆforkå’Œexecuteè¦åˆ†å¼€å†™çš„åŽŸå› **ã€‚</p>
<p>Now it should be clear why it is helpful that fork and exec are separate calls: between the two, the <strong>shell has a chance to redirect the childâ€™s I/O <u>without disturbing the I/O setup of the main shell</u></strong>.</p>
<h4 id="shared-file-offset">Shared file offset(?)<a class="headerlink" href="#shared-file-offset" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code>My Question
fileçš„offsetè¢«å…±äº«çš„è¯ï¼Œå¦‚æžœçˆ¶è¿›ç¨‹fpæŒ‡å‘æ˜¾å­˜ï¼Œå­è¿›ç¨‹fpæŒ‡å‘äº†ä¸€ä¸ªæ–‡ä»¶ï¼Œå­è¿›ç¨‹æ”¹å˜äº†åç§»é‡ï¼Œå½“è½¬åˆ°çˆ¶è¿›ç¨‹çš„æ—¶å€™ï¼Œçˆ¶è¿›ç¨‹ä¼šç©ºå‡ºä¸€å®šé‡çš„offsetç»§ç»­è¾“å‡ºå˜›ï¼Ÿéœ€è¦çŸ¥é“file descriptors tableç©¶ç«Ÿæ˜¯å’‹å›žäº‹ã€‚
</code></pre></div>
<p>Although fork copies the file descriptor table, <strong>each underlying file offset is shared between parent and child</strong>. <strong>Two file descriptors share an offset</strong> if they were derived from the same original file descriptor by a sequence of <strong>fork and dup calls</strong>.</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"hello "</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">"world</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//Output</span>
<span class="c1">//Hello World</span>
</code></pre></div>
<h3 id="13-pipes">1.3 Pipes(*)<a class="headerlink" href="#13-pipes" title="Permanent link">Â¶</a></h3>
<h4 id="definition">Definition<a class="headerlink" href="#definition" title="Permanent link">Â¶</a></h4>
<p>A pipe is a small kernel buffer <strong>exposed to processes</strong> as <strong>a pair of file descriptors</strong>, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. <strong>Pipes provide a way for processes to communicate</strong>.</p>
<h4 id="example">Example<a class="headerlink" href="#example" title="Permanent link">Â¶</a></h4>
<p>pipe()å‡½æ•°ç”±å†…æ ¸æä¾›ã€‚</p>
<p>The following example code runs the program <code>wc</code> with <code>standard input</code> connected to the read end of a pipe.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">"wc"</span><span class="p">;</span>
<span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">pipe</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="c1">//åˆ›å»ºä¸€ä¸ªpipeï¼Œç”¨pæ¥è®°å½•readå’Œwriteç«¯å£</span>
<span class="k">if</span><span class="p">(</span><span class="n">fork</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">dup</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span><span class="c1">//standard inputçŽ°åœ¨å’Œp[0]ï¼ˆreadç«¯å£è¿žæŽ¥ï¼‰</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="n">exec</span><span class="p">(</span><span class="s">"/bin/wc"</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">write</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="s">"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>
<p>ä¸‹å›¾å’Œä¸Šè¿°ä¸¾ä¾‹æ— å…³ã€‚</p>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/20161223173958916.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/20161223173958916.png" alt="img"></a></p>
<h3 id="14-file-system">1.4 File system<a class="headerlink" href="#14-file-system" title="Permanent link">Â¶</a></h3>
<h4 id="chdir"><code>chdir()</code><a class="headerlink" href="#chdir" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">//The first fragment changes the processâ€™s current directory to /a/b;</span>
<span class="n">chdir</span><span class="p">(</span><span class="s">"/a"</span><span class="p">);</span>
<span class="n">chdir</span><span class="p">(</span><span class="s">"b"</span><span class="p">);</span>
<span class="n">open</span><span class="p">(</span><span class="s">"c"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span>
<span class="c1">//the second neither refers to nor changes the processâ€™s current directory.</span>
<span class="n">open</span><span class="p">(</span><span class="s">"/a/b/c"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">);</span>
</code></pre></div>
<h4 id="mknod"><code>mknod</code><a class="headerlink" href="#mknod" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">mkdir</span><span class="p">(</span><span class="s">"/dir"</span><span class="p">);</span>
<span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s">"/dir/file"</span><span class="p">,</span><span class="w"> </span><span class="n">O_CREATE</span><span class="o">|</span><span class="n">O_WRONLY</span><span class="p">);</span>
<span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>

<span class="n">mknod</span><span class="p">(</span><span class="s">"/console"</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p><code>Mknod</code> creates a special file that refers to a device. Associated with a device file are the major and minor device numbers (the two arguments to <code>mknod</code>), which uniquely identify a kernel device. When a process later opens a device file, t**he kernel diverts read and write system calls to the kernel device implementation** instead of passing them to the file system</p>
<h2 id="chapter2-operating-system-organization">Chapter2. Operating system organization<a class="headerlink" href="#chapter2-operating-system-organization" title="Permanent link">Â¶</a></h2>
<p>An operating system must fulfill three requirements: <strong>multiplexing</strong>, <strong>isolation</strong>, and <strong>interaction</strong></p>
<ul>
<li>
<p>For example, even if there are more processes than there are hardware CPUs, the operating system must ensure that a**ll of the processes get a chance to execute**.</p>
</li>
<li>
<p>The operating system must also arrange for isolation between the processes. That is, if one process has a bug and malfunctions, <strong>it shouldnâ€™t affect processes that donâ€™t depend on the buggy process</strong>.</p>
</li>
<li>
<p>Complete isolation, however, is too strong, since <strong>it should be possible for processes to intentionally interact</strong>;</p>
</li>
</ul>
<h3 id="21-abstracting-physical-resources">2.1 Abstracting physical resources<a class="headerlink" href="#21-abstracting-physical-resources" title="Permanent link">Â¶</a></h3>
<p><strong>Itâ€™s more typical for applications to not trust each other</strong>, <strong>and to have bugs</strong>, so one often wants stronger isolation than a cooperative scheme provides. <strong>To achieve strong isolation itâ€™s helpful to forbid applications from directly accessing sensitive hardware resources, and instead to abstract the resources into services</strong>.</p>
<p>For example, Unix applications interact with storage only through the file systemâ€™s open, read, write, and close system calls, instead of reading and writing the disk directly.</p>
<h3 id="22-user-mode-supervisor-mode-and-system-calls">2.2 User mode, supervisor mode, and system calls<a class="headerlink" href="#22-user-mode-supervisor-mode-and-system-calls" title="Permanent link">Â¶</a></h3>
<p>To achieve strong <strong>isolation</strong>, the operating system must arrange that applications <strong>cannot modify (or even read) the operating systemâ€™s data structures and instructions</strong> and that <strong>applications cannot access other processesâ€™ memory</strong>.</p>
<p><strong>CPUs provide hardware support for strong isolation</strong>. For example, RISC-V has <strong>three modes</strong> in which the CPU can execute instructions: <strong>machine mode</strong>, <strong>supervisor mode</strong>, and <strong>user mode</strong>.</p>
<ul>
<li>a CPU starts in <strong>machine mode</strong>. Machine mode is mostly intended for configuring a computer. Xv6 executes a few lines in machine mode and then changes to supervisor mode.</li>
<li>In <strong>supervisor mode</strong> the CPU is allowed to execute <strong>privileged instructions</strong>: for example, enabling and disabling interrupts, reading and writing the register that holds the address of a page table.</li>
<li>An application can execute only <strong>user-mode</strong> instructions (e.g., adding numbers, etc.) and is said to be <strong>running in user space</strong>, while the software in supervisor mode can also execute <strong>privileged instruction**s and is said to be **running in kernel space</strong>. The <strong>software running in kernel space (or in supervisor mode) is called the <code>kernel</code></strong>.</li>
</ul>
<p><strong>CPUs provide a special instruction</strong> that switches the CPU from user mode to supervisor mode and enters the kernel at <strong>an entry point</strong> <strong>specified by the kernel</strong>. (RISC-V provides the <strong><code>ecall</code></strong> instruction for this purpose.)</p>
<p>Once the CPU has switched to supervisor mode, the <strong>kernel can then validate the arguments of the system call</strong>, <u>decide whether the application is allowed to perform the requested operation, and then deny it or execute it</u>. It is important that the <strong>kernel control the entry point for transitions to supervisor mode</strong>; if the application could decide the kernel entry point, a malicious application could, for example, enter the kernel at a point where the validation of arguments is skipped.</p>
<h3 id="23-kernel-organization">2.3 Kernel organization<a class="headerlink" href="#23-kernel-organization" title="Permanent link">Â¶</a></h3>
<p><strong><code>monolithic kernel</code></strong>. the <strong>entire operating system resides in the kernel</strong>, so that the implementations of all system calls run in supervisor mode.</p>
<ol>
<li>
<p>This organization is convenient because</p>
</li>
<li>
<p>the OS designer doesnâ€™t have to decide which part of the operating system doesnâ€™t need full hardware privilege.</p>
</li>
<li>
<p>Furthermore, it is <strong>easier for different parts of the operating system to cooperate</strong>. For example, an operating system might have a buffer cache that can be shared both by the file system and the virtual memory system.</p>
</li>
<li>
<p>A downside of the monolithic organization is that</p>
</li>
<li>
<p>the interfaces between different parts of the operating system are often complex, and therefore <strong>it is easy for an operating system developer to make a mistake</strong>.</p>
</li>
<li>In a monolithic kernel, a mistake is fatal, because an error in supervisor mode will often cause the kernel to fail. <strong>If the kernel fails,the computer stops working, and thus all applications fail too. The computer must reboot to start again</strong>.</li>
</ol>
<p><strong><code>microkernel</code></strong>. To reduce the risk of mistakes in the kernel, OS designers can <strong>minimize the amount of operating system code that runs in supervisor mode, and execute the bulk of the operating system in user mode</strong>.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220311165258588.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220311165258588" src="../../../../assets/Operating%20Systems.assets/image-20220311165258588.png"></a></p>
<h3 id="25-process-overview">2.5 Process overview<a class="headerlink" href="#25-process-overview" title="Permanent link">Â¶</a></h3>
<p><strong>The unit of isolation in xv6 (as in other Unix operating systems) is a process</strong>.</p>
<ul>
<li>The process abstraction prevents one process from wrecking or spying on another processâ€™s memory, CPU, file descriptors, etc.</li>
<li>It also prevents a process from wrecking the kernel itself, so that a process canâ€™t subvert the kernelâ€™s isolation mechanisms.</li>
</ul>
<p>The <strong>mechanisms used by the kernel to implement processes</strong> include the <strong>user/supervisor mode flag</strong>, <strong>address spaces</strong>, and <strong>time-slicing of threads</strong>. To help enforce isolation, the process abstraction provides the illusion to a program that it has its own private machine. A process provides a program with what appears to be a private memory system, or address space, which other processes cannot read or write. A process also provides the program with what appears to be its own CPU to execute the programâ€™s instructions.</p>
<h4 id="page-tables-brief-introduction">Page Tables Brief Introduction<a class="headerlink" href="#page-tables-brief-introduction" title="Permanent link">Â¶</a></h4>
<p>Xv6 uses <strong>page tables</strong> (which are implemented by hardware) to <strong>give each process its own address space</strong>. The <u>RISC-V page table translates (or â€œmapsâ€) a virtual address (the address that an RISC-V instruction manipulates) to a physical address (an address that the CPU chip sends to main memory).</u></p>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/image-20220311170706075.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/image-20220311170706075.png" alt="image-20220311170706075" style="zoom: 67%;"></a></p>
<p>an <strong>address space</strong> includes the processâ€™s user memory <strong>starting at virtual address zero</strong>. Instructions come first, followed by global variables, then the stack, and finally a â€œheapâ€ area (for malloc) that the process can expand as needed.</p>
<p>There are a number of factors that limit the maximum size of a processâ€™s address space: pointers on the RISC-V are 64 bits wide; <strong>the hardware only uses the low 39 bits when looking up virtual addresses in page tables; and xv6 only uses 38 of those 39 bits.</strong> Thus, the maximum address is <code>2^38 âˆ’ 1 = 0x3fffffffff</code>, which is MAXVA.</p>
<p>At the top of the address space xv6 reserves a page for a <strong>trampoline</strong> and a page mapping the processâ€™s <strong>trapframe</strong> to switch to the kernel, as we will explain in Chapter 4.</p>
<h4 id="thread-brief-introduction">Thread Brief Introduction<a class="headerlink" href="#thread-brief-introduction" title="Permanent link">Â¶</a></h4>
<p><strong>Each process has a thread of execution (or thread for short) that executes the processâ€™s instructions</strong>. A thread can be suspended and later resumed. <strong>To switch transparently between processes, the kernel suspends the currently running thread and resumes another processâ€™s thread</strong>. Much of <strong>the state of a thread (local variables, function call return addresses) is stored on the threadâ€™s stacks.</strong></p>
<p><strong>Each process has two stacks</strong>: a <strong>user stack</strong> and a <strong>kernel stack</strong> (p-&gt;kstack).</p>
<ul>
<li>When the process is executing user instructions, only its user stack is in use, and its kernel stack is empty.</li>
<li>When the process enters the kernel (for a system call or interrupt), the kernel code executes on the processâ€™s kernel stack;</li>
<li>A processâ€™s thread alternates between actively using its user stack and its kernel stack.</li>
</ul>
<h4 id="system-call-start-and-end">System Call Start and End<a class="headerlink" href="#system-call-start-and-end" title="Permanent link">Â¶</a></h4>
<p>A process can make a system call by executing the RISC-V <strong><code>ecall</code></strong> instruction.</p>
<p>This instruction</p>
<ul>
<li>
<p><strong>raises the hardware privilege level</strong> and</p>
</li>
<li>
<p>changes the program counter to a <strong>kernel-defined entry point</strong>.</p>
</li>
</ul>
<p><strong>The code at the entry point switches to a kernel stack</strong> and <strong>executes the kernel instructions</strong> that implement the system call.</p>
<p>When the system call completes, the kernel switches back to the user stack and returns to user space by calling the <strong><code>sret</code></strong> instruction,</p>
<ul>
<li>which <strong>lowers the hardware privilege level</strong> and resumes executing user instructions just after the system call instruction.</li>
<li><strong>A processâ€™s thread can â€œblockâ€ in the kernel to wait for I/O</strong>, and resume where it left off when the I/O has finished.</li>
</ul>
<h3 id="26-code-starting-xv6-and-the-first-process">2.6 Code: starting xv6 and the first process<a class="headerlink" href="#26-code-starting-xv6-and-the-first-process" title="Permanent link">Â¶</a></h3>
<h4 id="machine-mode">Machine Mode<a class="headerlink" href="#machine-mode" title="Permanent link">Â¶</a></h4>
<p>The loader loads the xv6 kernel into memory at physical address 0x80000000. The reason it places the kernel at 0x80000000 rather than 0x0 is because the address range 0x0:0x80000000 contains I/O devices.</p>
<p><code>entry.S</code></p>
<p>The instructions at _entry set up a stack so that xv6 can run C code. <strong>Xv6 declares space for an initial stack, stack0, in the file <code>start.c</code> (<code>kernel/start.c:11</code>). The code at _entry loads the stack pointer register sp with the address stack0+4096</strong>, the top of the stack, because the stack on RISC-V grows down. Now that the kernel has a stack, _entry calls into C code at start (kernel/start.c:21).</p>
<div class="highlight"><pre><span></span><code>## qemu -kernel loads the kernel at 0x80000000
        # and causes each CPU to jump there.
        # kernel.ld causes the following code to
        # be placed at 0x80000000.
.section .text
_entry:
    # set up a stack for C.
        # stack0 is declared in start.c,
        # with a 4096-byte stack per CPU.
        # sp = stack0 + (hartid * 4096)
        la sp, stack0
        li a0, 1024*4
        csrr a1, mhartid
        addi a1, a1, 1
        mul a0, a0, a1
        add sp, sp, a0
    # jump to start() in start.c
        call start
spin:
        j spin
</code></pre></div>
<p><code>start.c</code></p>
<p>The function start performs some configuration that is only allowed in machine mode, and then switches to supervisor mode.</p>
<p><strong>To enter supervisor mode, RISC-V provides the instruction <code>mret</code>.</strong> This instruction is most often used to return from a previous call from supervisor mode to machine mode.</p>
<p>start isnâ€™t returning from such a call, and instead sets things up as if there had been one(<code>mret</code>æœ¬è´¨ä¸Šæ˜¯ä»Žsupervisor modeè·³è½¬å›žmachine modeï¼Œä¸ºäº†èƒ½å¤Ÿè®©<code>mret</code>æŒ‡ä»¤ä½¿æˆ‘ä»¬è·³è½¬åˆ°supervisor modeï¼Œéœ€è¦åšå¦‚ä¸‹äº‹æƒ…):</p>
<p>it <strong>sets the previous privilege mode to supervisor</strong> in the register <code>mstatus</code>, it <strong>sets the return address to main</strong> by writing mainâ€™s address into the register <code>mepc</code>, <strong>disables virtual address translation</strong> in supervisor mode by writing 0 into the page-table register <code>satp</code>, and <strong>delegates all interrupts and exceptions to supervisor mode</strong>. Before jumping into supervisor mode, start performs one more task: <strong>it programs the clock chip to generate timer interrupts</strong>. With this housekeeping out of the way, start â€œreturnsâ€ to supervisor mode by calling <code>mret</code>. This causes the program counter to change to main (kernel/main.c:11).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// entry.S needs one stack per CPU.</span>
<span class="n">__attribute__</span><span class="w"> </span><span class="p">((</span><span class="n">aligned</span><span class="w"> </span><span class="p">(</span><span class="mi">16</span><span class="p">)))</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="n">stack0</span><span class="p">[</span><span class="mi">4096</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">NCPU</span><span class="p">];</span>

<span class="c1">// scratch area for timer interrupt, one per CPU.</span>
<span class="n">uint64</span><span class="w"> </span><span class="n">mscratch0</span><span class="p">[</span><span class="n">NCPU</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">32</span><span class="p">];</span>

<span class="c1">// assembly code in kernelvec.S for machine-mode timer interrupt.</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">timervec</span><span class="p">();</span>

<span class="c1">// entry.S jumps here in machine mode on stack0.</span>
<span class="kt">void</span>
<span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// set M Previous Privilege mode to Supervisor, for mret.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_mstatus</span><span class="p">();</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">MSTATUS_MPP_MASK</span><span class="p">;</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">MSTATUS_MPP_S</span><span class="p">;</span>
<span class="w">  </span><span class="n">w_mstatus</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// set M Exception Program Counter to main, for mret.</span>
<span class="w">  </span><span class="c1">// requires gcc -mcmodel=medany</span>
<span class="w">  </span><span class="n">w_mepc</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">main</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// disable paging for now.</span>
<span class="w">  </span><span class="n">w_satp</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// delegate all interrupts and exceptions to supervisor mode.</span>
<span class="w">  </span><span class="n">w_medeleg</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
<span class="w">  </span><span class="n">w_mideleg</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">);</span>
<span class="w">  </span><span class="n">w_sie</span><span class="p">(</span><span class="n">r_sie</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_SEIE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_STIE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">SIE_SSIE</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// ask for clock interrupts.</span>
<span class="w">  </span><span class="n">timerinit</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// keep each CPU's hartid in its tp register, for cpuid().</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_mhartid</span><span class="p">();</span>
<span class="w">  </span><span class="n">w_tp</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// switch to supervisor mode and jump to main().</span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mret"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="supervisor-mode">Supervisor Mode<a class="headerlink" href="#supervisor-mode" title="Permanent link">Â¶</a></h4>
<p><code>main.c</code></p>
<p><code>main</code> (kernel/main.c:11) initializes several devices and subsystems, <strong>it creates the first process by calling <code>userinit</code></strong> (kernel/proc.c:212).</p>
<p>The first process executes a small program written in RISC-V assembly, <strong><code>initcode.S</code></strong> (user/initcode.S:1), which <strong>re-enters the kernel by invoking the exec system call</strong>(ç³»ç»Ÿå¼€å¯åŽçš„ç¬¬ä¸€æ¬¡system call).</p>
<div class="highlight"><pre><span></span><code>## Initial process that execs /init.
## This code runs in user space.

##include "syscall.h"

## exec(init, argv)
.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec
        ecall

## for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit

## char init[] = "/init\0";
init:
  .string "/init\0"

## char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
</code></pre></div>
<p><code>initcode.S</code>æœ¬è´¨ä¸Šå°±æ˜¯<code>exec(init, argv)</code>, å› ä¸ºæ­¤æ—¶æ²¡æœ‰æ–‡ä»¶ç³»ç»Ÿï¼Œæ‰€ä»¥åªèƒ½ç”¨è¿™ç§æ–¹å¼è¿è¡Œ<code>user/init.c</code>.</p>
<h4 id="user-mode">User Mode<a class="headerlink" href="#user-mode" title="Permanent link">Â¶</a></h4>
<p><code>Init</code>(user/init.c:15) creates a new console device file if needed and then <strong>opens it as file descriptors 0, 1, and 2</strong>. Then it <strong>starts a shell</strong> on the console. The system is up.</p>
<h2 id="chapter3-page-tables">Chapter3. Page tables<a class="headerlink" href="#chapter3-page-tables" title="Permanent link">Â¶</a></h2>
<p><strong>Page tables</strong> are the mechanism through which the operating system <strong>provides each process</strong> with its <strong>own private address space and memory</strong>.</p>
<p>Page tables determine <strong>what memory addresses mean</strong>, and <strong>what parts of physical memory can be accessed.</strong></p>
<p>They allow xv6 to <strong><u>isolate</u> different processâ€™s address spaces and to <u>multiplex</u> them onto a single physical memory</strong>.</p>
<p>Page tables also provide a level of indirection that allows xv6 to perform a few tricks:</p>
<ul>
<li>mapping the same memory (a trampoline page) in several address spaces,</li>
<li>guarding kernel and user stacks with an unmapped page.</li>
</ul>
<h3 id="31-paging-hardware">3.1 Paging hardware<a class="headerlink" href="#31-paging-hardware" title="Permanent link">Â¶</a></h3>
<h4 id="terminology">Terminology<a class="headerlink" href="#terminology" title="Permanent link">Â¶</a></h4>
<ul>
<li><strong>PTE</strong>: page table entry</li>
<li><strong>PPN</strong>: physical page number</li>
</ul>
<p><strong>As a reminder, RISC-V instructions <u>(both user and kernel)</u> manipulate <u>virtual addresses</u>.</strong></p>
<h4 id="logical-page-table">Logical Page Table<a class="headerlink" href="#logical-page-table" title="Permanent link">Â¶</a></h4>
<p>The RISC-V <strong>page table hardware</strong> connects these two kinds of addresses, by mapping each virtual address to a physical address.</p>
<p>xv6 runs on Sv39 RISC-V, which means that <strong>only the bottom 39 bits of a 64-bit virtual address are used</strong>; the top 25 bits are not used.</p>
<p>In this Sv39 configuration, a RISC-V page table is logically an array of <code>2^27</code> (134,217,728) page table entries (PTEs). <strong>Each PTE contains a 44-bit physical page number (PPN) and some flags</strong>.</p>
<p><strong>The paging hardware translates a virtual address by using the top 27 bits of the 39 bits to index into the page table to find a PTE, and making a 56-bit physical address whose top 44 bits come from the PPN in the PTE and whose bottom 12 bits are copied from the original virtual address.</strong></p>
<p><strong>A Page</strong>: A page table gives the operating system control over virtual-to-physical address translations at the <strong>granularity of aligned chunks of 4096 (<code>2^12</code>) bytes</strong>. æ“ä½œç³»ç»Ÿå¯æŽ§çš„æ˜¯è™šæ‹Ÿåœ°å€é‡Œçš„12ä½çš„offsetã€‚</p>
<p>In Sv39 RISC-V, the top 25 bits of a virtual address are not used for translation; in the future, RISC-V may use those bits to define more levels of translation. <strong>The physical address also has room for growth: there is room in the PTE format for the physical page number to grow by another 10 bits</strong>.ï¼ˆ64 - 44 - 10 = 10ï¼‰</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220319004042706.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220319004042706" src="../../../../assets/Operating%20Systems.assets/image-20220319004042706.png"></a></p>
<p>å¦‚æžœæ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±çš„page tableï¼Œé‚£ä¹ˆæ¯ä¸ªpage tableè¡¨ä¼šæœ‰å¤šå¤§å‘¢ï¼Ÿ</p>
<p>è¿™ä¸ªpage tableæœ€å¤šä¼šæœ‰2^27ä¸ªæ¡ç›®ï¼ˆè™šæ‹Ÿå†…å­˜åœ°å€ä¸­çš„indexé•¿åº¦ä¸º27ï¼‰ã€‚<strong>å¦‚æžœæ¯ä¸ªè¿›ç¨‹éƒ½ä½¿ç”¨è¿™ä¹ˆå¤§çš„page tableï¼Œè¿›ç¨‹éœ€è¦ä¸ºpage tableæ¶ˆè€—å¤§é‡çš„å†…å­˜ï¼Œå¹¶ä¸”å¾ˆå¿«ç‰©ç†å†…å­˜å°±ä¼šè€—å°½ã€‚</strong></p>
<h4 id="actual-translation">Actual Translation<a class="headerlink" href="#actual-translation" title="Permanent link">Â¶</a></h4>
<p>The actual translation happens in <strong>three steps</strong>.</p>
<p><strong>A page table is stored in physical memory as a three-level tree</strong>.</p>
<p><strong>The root of the tree is a 4096-byte(516 * 64bit=4096B) page-table page that contains 512 PTEs</strong>, which contain the physical addresses for page-table pages in the next level of the tree. Each of those pages contains 512 PTEs for the final level in the tree. The paging hardware uses the top 9 bits of the 27 bits to select a PTE in the root page-table page, the middle 9 bits to select a PTE in a page-table page in the next level of the tree, and the bottom 9 bits to select the final PTE.</p>
<p>This three-level structure allows a page table to <strong>omit entire page table pages in the common case in which large ranges of virtual addresses have no mappings.</strong></p>
<p>To tell the hardware to use a page table, t**he kernel must write the physical address of the root page-table page into the <code>satp</code> register**. <strong>Each CPU has its own <code>satp</code></strong>. A CPU will translate all addresses generated by subsequent instructions using the page table pointed to by its own <code>satp</code>. Each CPU has its own <code>satp</code> so that different CPUs can run different processes, each with a private address space described by its own page table.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220319155658381.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220319155658381" src="../../../../assets/Operating%20Systems.assets/image-20220319155658381.png"></a></p>
<p>è¿™ç§æ–¹å¼çš„ä¸»è¦ä¼˜ç‚¹æ˜¯ï¼Œ<strong>å¦‚æžœåœ°å€ç©ºé—´ä¸­å¤§éƒ¨åˆ†åœ°å€éƒ½æ²¡æœ‰ä½¿ç”¨ï¼Œä½ ä¸å¿…ä¸ºæ¯ä¸€ä¸ªindexå‡†å¤‡ä¸€ä¸ªæ¡ç›®</strong>ã€‚</p>
<p><strong>åœ¨å‰ä¸€ä¸ªæ–¹æ¡ˆä¸­ï¼Œè™½ç„¶æˆ‘ä»¬åªä½¿ç”¨äº†ä¸€ä¸ªpageï¼Œè¿˜æ˜¯éœ€è¦<code>2^27</code>ä¸ªPTEã€‚è¿™ä¸ªæ–¹æ¡ˆä¸­ï¼Œæˆ‘ä»¬åªéœ€è¦<code>3 * 512</code>ä¸ªPTEã€‚æ‰€éœ€çš„ç©ºé—´å¤§å¤§å‡å°‘äº†ã€‚è¿™æ˜¯å®žé™…ä¸Šç¡¬ä»¶é‡‡ç”¨è¿™ç§å±‚æ¬¡åŒ–çš„3çº§page directoryç»“æž„çš„ä¸»è¦åŽŸå› ã€‚</strong></p>
<h4 id="ppnflags">PPN+Flags<a class="headerlink" href="#ppnflags" title="Permanent link">Â¶</a></h4>
<p>Each PTE contains <strong>flag bits that tell the paging hardware how the associated virtual address is allowed to be used</strong>.</p>
<ul>
<li>
<p><strong>PTE_V</strong> indicates <u>whether the PTE is present</u>: if it is not set, a reference to the page causes an exception.</p>
</li>
<li>
<p><strong>PTE_R</strong> controls whether instructions are allowed to <u>read</u> to the page.</p>
</li>
<li>
<p><strong>PTE_W</strong> controls whether instructions are allowed to <u>write</u> to the page.</p>
</li>
<li>
<p><strong>PTE_X</strong> controls whether the CPU may interpret the content of the page as instructions and <u>execute</u> them.</p>
</li>
<li>
<p><strong>PTE_U</strong> controls <u>whether instructions in user mode are allowed to access the page</u>; if PTE_U is not set, the PTE can be used only in supervisor mode.</p>
</li>
</ul>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220319161110245.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220319161110245" src="../../../../assets/Operating%20Systems.assets/image-20220319161110245.png"></a></p>
<h3 id="32-kernel-address-space">3.2 Kernel address space<a class="headerlink" href="#32-kernel-address-space" title="Permanent link">Â¶</a></h3>
<p><strong>Xv6 maintains one page table per process, describing each processâ€™s user address space, plus a single page table that describes the kernelâ€™s address space</strong>.</p>
<p>The kernel configures the layout of its address space to give itself access to physical memory and various hardware resources at predictable virtual addresses.</p>
<p>QEMU simulates a computer that includes <strong>RAM (physical memory) starting at physical address 0x80000000 and continuing through at least 0x86400000</strong>, which xv6 calls PHYSTOP. The QEMU simulation also includes I/O devices such as a disk interface.</p>
<p>QEMU exposes the <strong>device interfaces to software as memory-mapped control registers that sit below 0x80000000</strong> in the physical address space. <strong>The kernel can interact with the devices by reading/writing these special physical addresses</strong>; such reads and writes communicate with the device hardware rather than with RAM.</p>
<p>The kernel gets at RAM and memory-mapped device registers using <strong>â€œdirect mapping;â€</strong> that is, mapping the resources at virtual addresses that are equal to the physical address.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220319161821600.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220319161821600" src="../../../../assets/Operating%20Systems.assets/image-20220319161821600.png"></a></p>
<h4 id="kernel-virtual-addresses-that-arent-direct-mapped">kernel virtual addresses that arenâ€™t direct-mapped<a class="headerlink" href="#kernel-virtual-addresses-that-arent-direct-mapped" title="Permanent link">Â¶</a></h4>
<p>There are a couple of <strong>kernel virtual addresses that arenâ€™t direct-mapped</strong>:</p>
<ul>
<li>
<p><strong>The trampoline page</strong>. It is mapped at the top of the virtual address space; user page tables have this same mapping. we see here an interesting use case of page tables; <strong>a physical page (holding the trampoline code) is mapped twice in the virtual address space of the kernel</strong>: <strong>once at top of the virtual address space and once with a direct mapping</strong>.</p>
</li>
<li>
<p><strong>The kernel stack pages</strong>. <strong>Each process has its own kernel stack</strong>, which is mapped high so that <strong>below it xv6 can leave an <u>unmapped guard page</u></strong>.</p>
</li>
</ul>
<p><strong>The guard pageâ€™s PTE is invalid (PTE_V is not set), so that if the kernel overflows a kernel stack, it will likely cause an exception and the kernel will panic</strong>.</p>
<h3 id="33-code-creating-an-address-space">3.3 Code: creating an address space<a class="headerlink" href="#33-code-creating-an-address-space" title="Permanent link">Â¶</a></h3>
<h4 id="what-is-in-kernelvmc">What is in <code>kernel/vm.c</code><a class="headerlink" href="#what-is-in-kernelvmc" title="Permanent link">Â¶</a></h4>
<ul>
<li>The <strong>central data structure</strong> is <code>pagetable_t</code>, which is really <u>a <strong>pointer to</strong> a RISC-V <strong>root page-table page</strong></u>;</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="o">*</span><span class="n">pagetable_t</span><span class="p">;</span><span class="w"> </span><span class="c1">// 512 PTEs</span>
</code></pre></div>
<p>a <code>pagetable_t</code> may be <strong>either the kernel page table, or one of the per-process page tables</strong>.</p>
<ul>
<li>
<p>The <strong>central functions</strong> areï¼š</p>
</li>
<li>
<p><strong><code>walk</code></strong>, which finds the PTE for a virtual address.</p>
</li>
<li><strong><code>mappages</code></strong>, which installs PTEs for new mappings.</li>
<li>Functions starting with <strong><code>kvm</code></strong> manipulate the kernel page table;</li>
<li>functions starting with <code>uvm</code> manipulate a user page table;</li>
<li>other functions are used for both.</li>
<li><strong><code>copyout</code></strong> and <strong><code>copyin</code></strong> copy <strong>data to and from user virtual addresses provided as system call arguments</strong>; they are in <code>vm.c</code> because <strong>they need to explicitly translate those addresses in order to find the corresponding physical memory</strong>. (å†…æ ¸æ€å’Œç”¨æˆ·æ€æ•°æ®äº¤äº’çš„åŽŸç†)</li>
</ul>
<h4 id="kernel-page-table-initialization">Kernel Page Table Initialization<a class="headerlink" href="#kernel-page-table-initialization" title="Permanent link">Â¶</a></h4>
<ul>
<li>
<p>Early in the boot sequence, <code>main</code> calls <code>kvminit</code> (kernel/vm.c:22) to <strong>create the kernelâ€™s page table</strong>. This call occurs <strong>before xv6 has enabled paging</strong> on the RISC-V, <strong>so addresses refer directly to physical memory</strong>.</p>
</li>
<li>
<p><code>Kvminit</code> first allocates a page of physical memory to hold the root page-table page.</p>
</li>
<li>
<p>Then it calls <code>kvmmap</code> to install the translations that the kernel needs. The translations include the kernelâ€™s instructions and data, physical memory up to PHYSTOP, and memory ranges which are actually devices.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/*</span>
<span class="cm"> * create a direct-map page table for the kernel.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">kvminit</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">kernel_pagetable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pagetable_t</span><span class="p">)</span><span class="w"> </span><span class="n">kalloc</span><span class="p">();</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">kernel_pagetable</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// uart registers</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">UART0</span><span class="p">,</span><span class="w"> </span><span class="n">UART0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// virtio mmio disk interface</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">VIRTIO0</span><span class="p">,</span><span class="w"> </span><span class="n">VIRTIO0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// CLINT</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">CLINT</span><span class="p">,</span><span class="w"> </span><span class="n">CLINT</span><span class="p">,</span><span class="w"> </span><span class="mh">0x10000</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// PLIC</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">PLIC</span><span class="p">,</span><span class="w"> </span><span class="n">PLIC</span><span class="p">,</span><span class="w"> </span><span class="mh">0x400000</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// map kernel text executable and read-only.</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">KERNBASE</span><span class="p">,</span><span class="w"> </span><span class="n">KERNBASE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="o">-</span><span class="n">KERNBASE</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_X</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// map kernel data and the physical RAM we'll make use of.</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span><span class="w"> </span><span class="n">PHYSTOP</span><span class="o">-</span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">etext</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// map the trampoline for trap entry/exit to</span>
<span class="w">  </span><span class="c1">// the highest virtual address in the kernel.</span>
<span class="w">  </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">TRAMPOLINE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">trampoline</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_X</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><code>kvmmap</code> (kernel/vm.c:118) calls <code>mappages</code> (kernel/vm.c:149), which <strong>installs mappings into a page table for a range of virtual addresses to a corresponding range of physical addresses</strong>.</p>
</li>
<li>
<p>It does this separately for each virtual address in the range, at page intervals.</p>
<p>For each virtual address to be mapped, <strong><code>mappages</code> calls <code>walk</code> to find the address of the PTE for that address. It then initializes the PTE to hold the relevant physical page number, the desired permissions</strong> (PTE_W, PTE_X, and/or PTE_R), and PTE_V to mark the PTE as valid (kernel/vm.c:161).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// add a mapping to the kernel page table.</span>
<span class="c1">// only used when booting.</span>
<span class="c1">// does not flush TLB or enable paging.</span>
<span class="kt">void</span>
<span class="nf">kvmmap</span><span class="p">(</span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">kernel_pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">perm</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"kvmmap"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Create PTEs for virtual addresses starting at va that refer to</span>
<span class="c1">// physical addresses starting at pa. va and size might not</span>
<span class="c1">// be page-aligned. Returns 0 on success, -1 if walk() couldn't</span>
<span class="c1">// allocate a needed page-table page.</span>
<span class="kt">int</span>
<span class="nf">mappages</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">last</span><span class="p">;</span>
<span class="w">  </span><span class="n">pte_t</span><span class="w"> </span><span class="o">*</span><span class="n">pte</span><span class="p">;</span>

<span class="w">  </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="w">  </span><span class="n">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(;;){</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"remap"</span><span class="p">);</span>
<span class="w">    </span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PA2PTE</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">perm</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">last</span><span class="p">)</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">pa</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><code>walk</code> (kernel/vm.c:72) <strong>mimics the RISC-V paging hardware</strong> as it looks up the PTE for a virtual address (see Figure 3.2). <code>walk</code> descends the 3-level page table 9 bits at the time.</p>
</li>
<li>
<p>It uses each levelâ€™s 9 bits of virtual address to find the PTE of either the next-level page table or the final page(kernel/vm.c:78). If the PTE isnâ€™t valid, then the required page hasnâ€™t yet been allocated;</p>
</li>
<li>if the <code>alloc</code> argument is set, <code>walk</code> allocates a new page-table page and puts its physical address in the PTE.</li>
<li>It returns the address of the PTE in the lowest layer in the tree (kernel/vm.c:88).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// Return the address of the PTE in page table pagetable</span>
<span class="c1">// that corresponds to virtual address va.  If alloc!=0,</span>
<span class="c1">// create any required page-table pages.</span>
<span class="c1">//</span>
<span class="c1">// The risc-v Sv39 scheme has three levels of page-table</span>
<span class="c1">// pages. A page-table page contains 512 64-bit PTEs.</span>
<span class="c1">// A 64-bit virtual address is split into five fields:</span>
<span class="c1">//   39..63 -- must be zero.</span>
<span class="c1">//   30..38 -- 9 bits of level-2 index.</span>
<span class="c1">//   21..29 -- 9 bits of level-1 index.</span>
<span class="c1">//   12..20 -- 9 bits of level-0 index.</span>
<span class="c1">//    0..11 -- 12 bits of byte offset within the page.</span>
<span class="n">pte_t</span><span class="w"> </span><span class="o">*</span>
<span class="nf">walk</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">va</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">MAXVA</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"walk"</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">level</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pte_t</span><span class="w"> </span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">)];</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">pagetable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pagetable_t</span><span class="p">)</span><span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alloc</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">pagetable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">pde_t</span><span class="o">*</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>
<span class="w">      </span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PA2PTE</span><span class="p">(</span><span class="n">pagetable</span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pagetable</span><span class="p">[</span><span class="n">PX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">va</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div>
<p>The above code depends on physical memory being direct-mapped into the kernel virtual address space. For example, as walk descends levels of the page table, it pulls the (physical) address of the next-level-down page table from a PTE (kernel/vm.c:80), and then uses that address as a virtual address to fetch the PTE at the next level down (kernel/vm.c:78).</p>
<h4 id="user-page-table-initialization">User Page Table Initialization<a class="headerlink" href="#user-page-table-initialization" title="Permanent link">Â¶</a></h4>
<ul>
<li>main calls <code>kvminithart</code> (kernel/vm.c:53) to install the kernel page table. <strong>It writes the physical address of the root page-table page into the register <code>satp</code>.</strong> After this the CPU will translate addresses using the kernel page table. Since the kernel uses an identity mapping, the now virtual address of the next instruction will map to the right physical memory address.</li>
</ul>
<p>Each RISC-V <strong>CPU caches page table entries</strong> in a <strong>Translation Look-aside Buffer (TLB)</strong>, and <strong>when xv6 changes a page table, it must tell the CPU to invalidate corresponding cached TLB entries</strong>. If it didnâ€™t, then at some point later the TLB might use an old cached mapping, pointing to a physical page that in the meantime has been allocated to another process, and as a result, a process might be able to scribble(ä¹±æ¶‚) on some other processâ€™s memory. The <strong>RISC-V has an instruction <code>sfence.vma</code> that flushes the current CPUâ€™s TLB</strong>. xv6 executes <code>sfence.vma</code> in <code>kvminithart</code> after reloading the <code>satp</code> register, and in the trampoline code that switches to a user page table before returning to user space.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Switch h/w page table register to the kernel's page table,</span>
<span class="c1">// and enable paging.</span>
<span class="kt">void</span>
<span class="nf">kvminithart</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">w_satp</span><span class="p">(</span><span class="n">MAKE_SATP</span><span class="p">(</span><span class="n">kernel_pagetable</span><span class="p">));</span>
<span class="w">  </span><span class="n">sfence_vma</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li><code>procinit</code> (kernel/proc.c:26), which is called from main, <strong>allocates a kernel stack for each process</strong>. It maps each stack at the virtual address generated by KSTACK, which leaves room for the invalid stack-guard pages. <code>kvmmap</code> adds the mapping PTEs to the kernel page table, and the call to <code>kvminithart</code> reloads the kernel page table into <code>satp</code> so that the hardware knows about the new PTEs.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// initialize the proc table at boot time.</span>
<span class="kt">void</span>
<span class="nf">procinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pid_lock</span><span class="p">,</span><span class="w"> </span><span class="s">"nextpid"</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"proc"</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// Allocate a page for the process's kernel stack.</span>
<span class="w">      </span><span class="c1">// Map it high in memory, followed by an invalid</span>
<span class="w">      </span><span class="c1">// guard page.</span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">pa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kalloc</span><span class="p">();</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">pa</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">"kalloc"</span><span class="p">);</span>
<span class="w">      </span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">KSTACK</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">proc</span><span class="p">));</span>
<span class="w">      </span><span class="n">kvmmap</span><span class="p">(</span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_R</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">PTE_W</span><span class="p">);</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">kvminithart</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="34-physical-memory-allocation">3.4 Physical memory allocation<a class="headerlink" href="#34-physical-memory-allocation" title="Permanent link">Â¶</a></h3>
<p>The kernel must allocate and free physical memory at run-time for page tables, user memory, kernel stacks, and pipe buffers. xv6 uses the physical memory between the end of the kernel and PHYSTOP for run-time allocation. It allocates and frees whole 4096-byte pages at a time. It keeps track of which pages are free by threading a linked list through the pages themselves. <strong>Allocation consists of removing a page from the linked list; freeing consists of adding the freed page to the list.</strong></p>
<h3 id="35-code-physical-memory-allocator">3.5 Code: Physical memory allocator<a class="headerlink" href="#35-code-physical-memory-allocator" title="Permanent link">Â¶</a></h3>
<ul>
<li>
<p>The allocator resides in <code>kalloc.c</code> (kernel/kalloc.c:1).</p>
</li>
<li>
<p>The <strong>allocatorâ€™s data structure is a free list of physical memory pages that are available for allocation</strong>. Each free pageâ€™s list element is a struct run (kernel/kalloc.c:17).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">run</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">run</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
</li>
<li>
<p><strong>Where does the allocator get the memory to hold that data structure?</strong> <strong>It store each free pageâ€™s run structure in the free page itself, since thereâ€™s nothing else stored there.</strong></p>
</li>
<li>
<p>The function main calls <code>kinit</code> to initialize the allocator (kernel/kalloc.c:27). <strong>kinit initializes the free list to hold every page between the end of the kernel and <code>PHYSTOP</code></strong>. xv6 ought to determine how much physical memory is available by parsing configuration information provided by the hardware. Instead xv6 assumes that the machine has 128 megabytes of RAM.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">kinit</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"kmem"</span><span class="p">);</span>
<span class="w">  </span><span class="n">freerange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">PHYSTOP</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>kinit calls <code>freerange</code> to add memory to the free list via per-page calls to <code>kfree</code>. <strong>A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096)</strong>, so <code>freerange</code> uses <code>PGROUNDUP</code> to ensure that it frees only aligned physical addresses.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">freerange</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa_start</span><span class="p">,</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa_end</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PGROUNDUP</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa_start</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PGSIZE</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa_end</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">)</span>
<span class="w">    </span><span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>The function <code>kfree</code> (kernel/kalloc.c:47) <strong>begins by setting every byte in the memory being freed to the value 1</strong>. This will cause code that uses memory after freeing it (uses â€œdangling referencesâ€) to read garbage instead of the old valid contents; hopefully that will cause such code to break faster. <strong>Then <code>kfree</code> prepends the page to the free list:</strong> it casts pa to a pointer to struct run, records the old start of the free list in r-&gt;next, and sets the free list equal to r. <code>kalloc</code> removes and returns the first element in the free list.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Free the page of physical memory pointed at by v,</span>
<span class="c1">// which normally should have been returned by a</span>
<span class="c1">// call to kalloc().  (The exception is when</span>
<span class="c1">// initializing the allocator; see kinit above.)</span>
<span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">pa</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">run</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(((</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">pa</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">PHYSTOP</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"kfree"</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Fill with junk to catch dangling refs.</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>

<span class="w">  </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">run</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
<span class="w">  </span><span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
</ul>
<h3 id="36-process-address-space">3.6 Process address space<a class="headerlink" href="#36-process-address-space" title="Permanent link">Â¶</a></h3>
<p><strong>Each process has a separate page table</strong>, and <strong>when xv6 switches between processes, it also changes page tables</strong>. As Figure 2.3 shows, a processâ€™s user memory starts at virtual address zero and can grow up to MAXVA (kernel/riscv.h:348), allowing a process to address in principle 256 Gigabytes of memory (<code>#define MAXVA (1L &lt;&lt; (9 + 9 + 9 + 12 - 1))</code>).</p>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/image-20220311170706075.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/image-20220311170706075.png" alt="image-20220311170706075" style="zoom: 67%;"></a></p>
<h4 id="how-does-a-process-obtain-memory">How Does a Process Obtain Memory<a class="headerlink" href="#how-does-a-process-obtain-memory" title="Permanent link">Â¶</a></h4>
<p>When a process asks xv6 for more user memory,</p>
<ol>
<li>xv6 first uses <code>kalloc</code> to <strong>allocate physical pages</strong>.</li>
<li>It then <strong>adds PTEs to the processâ€™s page table that point to the new physical pages</strong>. Xv6 sets the PTE_W, PTE_X, PTE_R, PTE_U, and PTE_V flags in these PTEs. Most processes do not use the entire user address space; xv6 leaves PTE_V clear in unused PTEs.</li>
</ol>
<h4 id="use-of-page-tables">Use of Page Tables<a class="headerlink" href="#use-of-page-tables" title="Permanent link">Â¶</a></h4>
<p>We see here a few nice examples of use of page tables.</p>
<ol>
<li>First, different processesâ€™ page tables translate user addresses to different pages of physical memory, so that <strong>each process has private user memory</strong>.</li>
<li>Second, each process sees its memory as having contiguous virtual addresses starting at zero, while <strong>the processâ€™s physical memory can be non-contiguous</strong>.</li>
<li>Third, the kernel maps a page with trampoline code at the top of the user address space, thus <strong>a single page of physical memory shows up in all address spaces</strong>.</li>
</ol>
<h4 id="layout-of-the-user-memory-of-an-executing-process">Layout of the User Memory of an Executing Process<a class="headerlink" href="#layout-of-the-user-memory-of-an-executing-process" title="Permanent link">Â¶</a></h4>
<p>Figure 3.4 shows the layout of the user memory of an executing process in xv6 in more detail. <strong>The stack is a single page</strong>, and is shown with the initial contents as created by exec. Strings containing the command-line arguments, as well as an array of pointers to them, are at the very top of the stack. Just under that are values that allow a program to start at main as if the function <code>main(argc, argv)</code> had just been called.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220322233318284.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220322233318284" src="../../../../assets/Operating%20Systems.assets/image-20220322233318284.png"></a></p>
<p>To detect <strong>a user stack overflowing the allocated stack memory</strong>, <strong>xv6 places an invalid guard page right below the stack</strong>. If the user stack overflows and the process tries to use an address below the stack, the hardware will generate a page-fault exception because the mapping is not valid. A real-world operating system might instead automatically allocate more memory for the user stack when it overflows.</p>
<h3 id="37-code-sbrk">3.7 Code: <code>sbrk</code><a class="headerlink" href="#37-code-sbrk" title="Permanent link">Â¶</a></h3>
<p><code>Sbrk</code> <strong>is the system call for a process to shrink or grow its memory</strong>. <code>sbrk()</code> change the location of the <strong>program break</strong>, which defines the end of the process's data segment (i.e., the program break is the first location after the end of the uninitialized data segment).</p>
<p>The system call is implemented by the function <code>growproc</code> (kernel/proc.c:239). <code>growproc</code> calls <code>uvmalloc</code> or <code>uvmdealloc</code>, depending on whether n is positive or negative.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Grow or shrink user memory by n bytes.</span>
<span class="c1">// Return 0 on success, -1 on failure.</span>
<span class="kt">int</span>
<span class="nf">growproc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uvmalloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uvmdealloc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="p">,</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">sz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>uvmalloc</code> (kernel/vm.c:229) allocates physical memory with <code>kalloc</code>, and adds PTEs to the user page table with <code>mappages</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate PTEs and physical memory to grow process from oldsz to</span>
<span class="c1">// newsz, which need not be page aligned.  Returns new size or 0 on error.</span>
<span class="n">uint64</span>
<span class="nf">uvmalloc</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">oldsz</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">newsz</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">mem</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">newsz</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">oldsz</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">oldsz</span><span class="p">;</span>

<span class="w">  </span><span class="n">oldsz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">oldsz</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oldsz</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">newsz</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">){</span>
<span class="w">    </span><span class="n">mem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kalloc</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">mem</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">uvmdealloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">oldsz</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">mem</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">kfree</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>
<span class="w">      </span><span class="n">uvmdealloc</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">oldsz</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">newsz</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>uvmdealloc</code> calls <code>uvmunmap</code> (kernel/vm.c:174), which uses <code>walk</code> to find PTEs and <code>kfree</code> to free the physical memory they refer to.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Deallocate user pages to bring the process size from oldsz to</span>
<span class="c1">// newsz.  oldsz and newsz need not be page-aligned, nor does newsz</span>
<span class="c1">// need to be less than oldsz.  oldsz can be larger than the actual</span>
<span class="c1">// process size.  Returns the new process size.</span>
<span class="n">uint64</span>
<span class="nf">uvmdealloc</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">oldsz</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">newsz</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">newsz</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">oldsz</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">oldsz</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">newsz</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">oldsz</span><span class="p">)){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">npages</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">oldsz</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">newsz</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span>
<span class="w">    </span><span class="n">uvmunmap</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">newsz</span><span class="p">),</span><span class="w"> </span><span class="n">npages</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">newsz</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Remove npages of mappings starting from va. va must be</span>
<span class="c1">// page-aligned. The mappings must exist.</span>
<span class="c1">// Optionally free the physical memory.</span>
<span class="kt">void</span>
<span class="nf">uvmunmap</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">npages</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">do_free</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="n">pte_t</span><span class="w"> </span><span class="o">*</span><span class="n">pte</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">va</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not aligned"</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">npages</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">walk</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: walk"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not mapped"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">PTE_FLAGS</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"uvmunmap: not a leaf"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">do_free</span><span class="p">){</span>
<span class="w">      </span><span class="n">uint64</span><span class="w"> </span><span class="n">pa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTE2PA</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span><span class="p">);</span>
<span class="w">      </span><span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="o">*</span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="why-use-page-table">Why use page table<a class="headerlink" href="#why-use-page-table" title="Permanent link">Â¶</a></h4>
<p>xv6 uses a processâ€™s page table</p>
<ol>
<li>tell the hardware how to map user virtual addresses,</li>
<li>the only record of which physical memory pages are allocated to that process. That is the reason why freeing user memory (in <code>uvmunmap</code>) requires examination of the user page table.</li>
</ol>
<h3 id="38-code-exec">3.8 Code: <code>exec</code><a class="headerlink" href="#38-code-exec" title="Permanent link">Â¶</a></h3>
<p><code>Exec</code> is the system call that <strong>creates the user part of an address space</strong>.</p>
<ol>
<li>It initializes the user part of an address space from a file stored in the file system.</li>
<li><code>Exec</code> (kernel/exec.c:13) opens the named binary path using <code>namei</code> (kernel/exec.c:26), which is explained in Chapter 8. Then, it reads the ELF header.</li>
</ol>
<h4 id="elf-format">ELF format<a class="headerlink" href="#elf-format" title="Permanent link">Â¶</a></h4>
<p>Xv6 applications are described in the widely-used ELF format, defined in (<code>kernel/elf.h</code>).</p>
<p><strong>An ELF binary consists of <u>an ELF header, struct <code>elfhdr</code></u> **(kernel/elf.h:6), **<u>followed by a sequence of program section headers</u></strong>, struct <code>proghdr</code> (kernel/elf.h:25).</p>
<p>Each <code>proghdr</code> <strong>describes a section of the application that must be loaded into memory</strong>;</p>
<p>xv6 programs have only one program section header, but other systems might have separate sections for instructions and data.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// File header</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">elfhdr</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">magic</span><span class="p">;</span><span class="w">  </span><span class="c1">// must equal ELF_MAGIC</span>
<span class="w">  </span><span class="n">uchar</span><span class="w"> </span><span class="n">elf</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">machine</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">version</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">entry</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">phoff</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">shoff</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">ehsize</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">phentsize</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">phnum</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">shentsize</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">shnum</span><span class="p">;</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">shstrndx</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Program section header</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">proghdr</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint32</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint32</span><span class="w"> </span><span class="n">flags</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">vaddr</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">paddr</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">filesz</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">memsz</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">align</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<h4 id="how-to-check-the-file-probably-contains-an-elf-binary">How to check the file probably contains an ELF binary<a class="headerlink" href="#how-to-check-the-file-probably-contains-an-elf-binary" title="Permanent link">Â¶</a></h4>
<p>An ELF binary starts with the four-byte â€œ<strong>magic numberâ€</strong> 0x7F, â€˜Eâ€™, â€˜Lâ€™, â€˜Fâ€™, or ELF_MAGIC (kernel/elf.h:3). If the ELF header has the right magic number, exec assumes that the binary is well-formed.</p>
<div class="highlight"><pre><span></span><code><span class="cp">##define ELF_MAGIC 0x464C457FU  </span><span class="c1">// "\x7FELF" in little endian</span>
</code></pre></div>
<h4 id="execc"><code>exec.c</code><a class="headerlink" href="#execc" title="Permanent link">Â¶</a></h4>
<p><code>exec(char *path, char **argv)</code></p>
<ul>
<li>
<p><strong>allocates a new page table with no user mappings</strong> with <code>proc_pagetable</code> (kernel/exec.c:38),</p>
</li>
<li>
<p><strong>allocates memory for each ELF segment</strong> with <code>uvmalloc</code> (kernel/exec.c:52), and</p>
</li>
<li>
<p><strong>loads each segment into memory</strong> with <code>loadseg</code> (kernel/exec.c:10). <code>loadseg</code> uses <code>walkaddr</code> to find the physical address of the allocated memory at which to write each page of the ELF segment, and <code>readi</code> to read from the file.</p>
</li>
</ul>
<h4 id="example-of-execinit-argv">Example of <code>exec("/init", argv)</code><a class="headerlink" href="#example-of-execinit-argv" title="Permanent link">Â¶</a></h4>
<p>The program section header for <code>/init</code>, the first user program created with exec, looks like this:</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220326210922620.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220326210922620" src="../../../../assets/Operating%20Systems.assets/image-20220326210922620.png"></a></p>
<ul>
<li>
<p>The program section headerâ€™s <code>filesz</code> may be less than the <code>memsz</code>, indicating that the gap between them should be filled with zeroes (for C global variables) rather than read from the file. For <code>/init</code>, <code>filesz</code> is 2112 bytes and <code>memsz</code> is 2136 bytes, and thus <strong><code>uvmalloc</code> allocates enough physical memory to hold 2136 bytes, but reads only 2112 bytes from the file<code>/init</code>.</strong></p>
</li>
<li>
<p>Now <code>exec</code> <strong>allocates and initializes the user stack</strong>. It allocates just one stack page. <code>Exec</code> copies the argument strings to the top of the stack one at a time, recording the pointers to them in <code>ustack</code>. It places a null pointer at the end of what will be the <code>argv</code> list passed to main. The first three entries in <code>ustack</code> are the fake return program counter, <code>argc</code>, and <code>argv</code> pointer.</p>
</li>
<li>
<p><code>Exec</code> <strong>places an inaccessible page just below the stack page</strong>, so that programs that try to use more than one page will fault. This inaccessible page also allows exec to deal with arguments that are too large; in that situation, the <code>copyout</code> (kernel/vm.c:355) function that exec uses to copy arguments to the stack will notice that the destination page is not accessible, and will return -1.</p>
</li>
</ul>
<h4 id="error-handling">Error handling<a class="headerlink" href="#error-handling" title="Permanent link">Â¶</a></h4>
<p>During the preparation of the new memory image,</p>
<p>if exec detects an error like an invalid program segment, it jumps to the label bad, frees the new image, and returns -1.</p>
<p>Exec must wait to free the old image until it is sure that the system call will succeed: if the old image is gone, the system call cannot return -1 to it.</p>
<p>The only error cases in exec happen during the creation of the image. Once the image is complete, exec can commit to the new page table (kernel/exec.c:113) and free the old one (kernel/exec.c:117).</p>
<h4 id="risk-of-exec">Risk of <code>exec()</code><a class="headerlink" href="#risk-of-exec" title="Permanent link">Â¶</a></h4>
<p><strong>Exec loads bytes from the ELF file into memory at addresses specified by the ELF file</strong>. Users or processes <strong>can place whatever addresses they want into an ELF file</strong>. Thus exec is risky, because the addresses in the ELF file may refer to the kernel, accidentally or on purpose. The consequences for an unwary kernel could range from a crash to a malicious subversion of the kernelâ€™s isolation mechanisms (i.e., a security exploit). xv6 performs a number of checks to avoid these risks. For example <code>if (ph.vaddr + ph.memsz &lt; ph.vaddr)</code> checks for whether the sum overflows a 64-bit integer. The danger is that a user could construct an ELF binary with a <code>ph.vaddr</code> that points to a user-chosen address, and <code>ph.memsz</code> large enough that the sum overflows to 0x1000, which will look like a valid value. In an older version of xv6 in which the user address space also contained the kernel (but not readable/writable in user mode), the user could choose an address that corresponded to kernel memory and would thus copy data from the ELF binary into the kernel. In the RISC-V version of xv6 this cannot happen, because the kernel has its own separate page table; <code>loadseg</code> loads into the processâ€™s page table, not in the kernelâ€™s page table.</p>
<h2 id="chapter4-traps-and-system-calls">Chapter4. Traps and system calls<a class="headerlink" href="#chapter4-traps-and-system-calls" title="Permanent link">Â¶</a></h2>
<h3 id="trap">Trap<a class="headerlink" href="#trap" title="Permanent link">Â¶</a></h3>
<p>There are <strong>three</strong> kinds of event which cause the CPU to set aside ordinary execution of instructions and force a transfer of control to special code that handles the event.</p>
<ul>
<li>One situation is a <strong>system call</strong>, when a user program executes the <code>ecall</code> instruction to ask the kernel to do something for it.</li>
<li>Another situation is an <strong>exception</strong>: an instruction (user or kernel) does something illegal, such as divide by zero or use an invalid virtual address.</li>
<li>The third situation is a <strong>device interrupt</strong>, when a device signals that it needs attention, for example when the disk hardware finishes a read or write request.</li>
</ul>
<p>This book uses <strong><code>trap</code></strong> as a generic term for these situations.</p>
<p>Typically whatever code was executing at the time of the trap will later need to resume, and shouldnâ€™t need to be aware that anything special happened. That is, we often want traps to be transparent; this is particularly important for interrupts, which the interrupted code typically doesnâ€™t expect.</p>
<p>The usual sequence is that</p>
<ul>
<li>a trap <strong>forces a transfer of control into the kernel</strong>;</li>
<li>the kernel <strong>saves registers and other state</strong> so that execution can be resumed;</li>
<li>the kernel <strong>executes appropriate handler code</strong> (e.g., a system call implementation or device driver);</li>
<li>the kernel <strong>restores the saved state and returns from the trap</strong>; and the original code resumes where it left off.</li>
</ul>
<h3 id="41-risc-v-trap-machinery">4.1 RISC-V trap machinery<a class="headerlink" href="#41-risc-v-trap-machinery" title="Permanent link">Â¶</a></h3>
<h4 id="registers-for-trap">Registers for Trap<a class="headerlink" href="#registers-for-trap" title="Permanent link">Â¶</a></h4>
<p>Each <strong>RISC-V CPU has a set of control registers that the kernel writes to tell the CPU how to handle traps</strong>, <strong>and that the kernel can read to find out about a trap that has occurred</strong>. The RISC-V documents contain the full story. <code>riscv.h</code> (kernel/riscv.h:1) contains definitions that xv6 uses. Hereâ€™s an outline of the most important registers:</p>
<ul>
<li>
<p><code>stvec</code>: The kernel writes the address of its trap handler here; the RISC-V jumps here to handle a trap.</p>
</li>
<li>
<p><code>sepc</code>: When a trap occurs, RISC-V saves the program counter here (since the pc is then overwritten with <code>stvec</code>). The <code>sret</code> (return from trap) instruction copies <code>sepc</code> to the pc. The kernel can write to <code>sepc</code> to control where <code>sret</code> goes.</p>
</li>
<li>
<p><code>scause</code>: The RISC-V puts a number here that describes the reason for the trap.</p>
</li>
<li>
<p><code>sscratch</code>: The kernel places a value here that comes in handy at the very start of a trap handler.</p>
</li>
<li>
<p><code>sstatus</code>: The SIE bit in <code>sstatus</code> controls whether device interrupts are enabled. If the kernel clears SIE, the RISC-V will defer device interrupts until the kernel sets SIE. The SPP bit indicates whether a trap came from user mode or supervisor mode, and controls to what mode <code>sret</code> returns.</p>
</li>
</ul>
<p>The above registers relate to traps handled in supervisor mode, and <strong>they cannot be read or written in user mode</strong>. There is an equivalent set of control registers for traps handled in machine mode; xv6 uses them only for the special case of timer interrupts. Each CPU on a multi-core chip has its own set of these registers, and more than one CPU may be handling a trap at any given time.</p>
<h4 id="cpu-hardwares-trap-handling-sequence">CPU hardwareâ€™s trap handling sequence<a class="headerlink" href="#cpu-hardwares-trap-handling-sequence" title="Permanent link">Â¶</a></h4>
<p>When it needs to force a trap, the RISC-V hardware does the following for all trap types (other than timer interrupts):</p>
<ol>
<li>If the trap is a device interrupt, and the sstatus SIE bit is clear, donâ€™t do any of the following.</li>
<li>Disable interrupts by clearing SIE.</li>
<li><strong>Copy the pc to <code>sepc</code>.</strong></li>
<li>Save the current mode (user or supervisor) in the SPP bit in sstatus.</li>
<li><strong>Set <code>scause</code> to reflect the trapâ€™s cause.</strong></li>
<li>Set the mode to supervisor.</li>
<li><strong>Copy <code>stvec</code> to the pc.</strong></li>
<li>Start executing at the new pc.</li>
</ol>
<hr>
<p>Note that the <strong>CPU doesnâ€™t switch to the kernel page table, doesnâ€™t switch to a stack in the kernel, and doesnâ€™t save any registers other than the pc</strong>.</p>
<p><strong>Kernel software must perform these tasks</strong>.</p>
<p>One reason that the CPU does minimal work during a trap is to provide flexibility to software; for example, some operating systems donâ€™t require a page table switch in some situations, which can increase performance.</p>
<p>You might wonder whether the CPU hardwareâ€™s trap handling sequence could be further simplified. For example, suppose that the CPU didnâ€™t switch program counters. Then a trap could switch to supervisor mode while still running user instructions. Those user instructions could break the user/kernel isolation, for example by modifying the <code>satp</code> register to point to a page table that allowed accessing all of physical memory. It is thus important that the CPU switch to a kernel specified instruction address, namely <code>stvec</code>.</p>
<h3 id="42-traps-from-user-space">4.2 Traps from user space<a class="headerlink" href="#42-traps-from-user-space" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>CPUå¯¹äºŽtrapæ‰€åšçš„äº‹å…¶å®žå¾ˆå°‘ï¼Œä»–åªè®¾ç½®äº†ä¸€äº›flagå¹¶ä¿å­˜äº†pcå€¼ï¼Œç„¶åŽè®©pcæŒ‡å‘äº†æœ¬ç« å†…å®¹çš„å¼€ç«¯<code>uservec</code>ã€‚<code>uservec</code>å°±è¦æƒ³åŠžæ³•åˆ‡æ¢é¡µè¡¨å¹¶ä¿å­˜ç”¨æˆ·æ€å æœ‰çš„å¯„å­˜å™¨ã€‚ä»Žè€Œä¸ºæ‰§è¡Œtrapçš„handlerä»£ç æä¾›è¿è¡ŒçŽ¯å¢ƒã€‚</p>
</blockquote>
<p>A trap may occur while executing in user space if the user program makes a system call (<code>ecall</code> instruction), or does something illegal, or if a device interrupts. The high-level path of a trap from user space is <code>uservec</code> (kernel/trampoline.S:16), then <code>usertrap</code> (kernel/trap.c:37); and when returning, <code>usertrapret</code> (kernel/trap.c:90) and then <code>userret</code> (kernel/trampoline.S:16).</p>
<hr>
<p>Traps from user code are more challenging than from the kernel, since <code>satp</code> points to a user page table that doesnâ€™t map the kernel, and the stack pointer may contain an invalid or even malicious value.</p>
<p>Because the <strong>RISC-V hardware doesnâ€™t switch page tables during a trap</strong>, <strong>the user page table must include a mapping for <code>uservec</code>, the trap vector instructions that <code>stvec</code> points to.</strong> <code>uservec</code> must switch <code>satp</code> to point to the kernel page table;</p>
<p><strong>in order to continue executing instructions after the switch</strong>, <strong><code>uservec</code> must be mapped at the same address in the kernel page table as in the user page table.</strong></p>
<blockquote>
<p>å› ä¸º<code>uservec</code>ä½¿å‘½æ˜¯è¦åšCPUæ²¡æœ‰åšçš„äº‹ï¼Œæœ€é‡è¦çš„å°±æ˜¯é¡µè¡¨çš„åˆ‡æ¢ã€‚é‚£ä¹ˆå†åˆ‡æ¢äº†é¡µè¡¨ä¹‹åŽï¼Œä¸ºäº†è®©ç”¨æˆ·é¡µè¡¨é‡Œçš„ä»£ç åœ¨åˆ‡æ¢åˆ°å†…æ ¸é¡µè¡¨åŽä¹Ÿèƒ½è¿è¡Œï¼Œæˆ‘ä»¬åœ¨ä¸¤è€…ç›¸åŒçš„è™šæ‹Ÿåœ°å€å¤„é¢„å…ˆæ”¾å…¥äº†ä¸€æ ·çš„ä»£ç ã€‚è¿™ä¸ªç›¸åŒçš„åœ°å€åŒºåŸŸå¦‚ä¸‹æ‰€è¿°ã€‚</p>
</blockquote>
<hr>
<p>Xv6 satisfies these constraints with a trampoline page that contains <code>uservec</code>. <strong>Xv6 maps the trampoline page at the same virtual address in the kernel page table and in every user page table</strong>. This virtual address is <code>TRAMPOLINE</code> (as we saw in Figure 2.3 and in Figure 3.3). The trampoline contents are set in <code>trampoline.S</code>, and (when executing user code) <code>stvec</code> is set to <code>uservec</code> (kernel/trampoline.S:16).</p>
<div class="highlight"><pre><span></span><code>uservec:
    #
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.
        #
        # sscratch points to where the process's p-&gt;trapframe is
        # mapped into user space, at TRAPFRAME.
        #

    # swap a0 and sscratch
        # so that a0 is TRAPFRAME
        csrrw a0, sscratch, a0

        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        .
        .
        .
</code></pre></div>
<p>When <code>uservec</code> starts, all 32 registers contain values owned by the interrupted code. But <code>uservec</code> needs to be able to modify some registers in order to set <code>satp</code> and generate addresses at which to save the registers. RISC-V provides a helping hand in the form of the <code>sscratch</code> register. The <code>csrrw</code> instruction at the start of <code>uservec</code> swaps the contents of a0 and <code>sscratch</code>. Now the user codeâ€™s a0 is saved; <code>uservec</code> has one register (a0) to play with; and a0 contains the value the kernel previously placed in <code>sscratch</code>.</p>
<blockquote>
<p>ä¸Šé¢è®²çš„æ˜¯å½“ç”¨æˆ·æ€ç¨‹åºè§¦å‘ä¸­æ–­æ—¶ï¼Œå½“å‰çš„32ä¸ªå¯„å­˜å™¨éƒ½è¢«ç”¨æˆ·å æœ‰ï¼Œæ‰€ä»¥ä¸€å¼€å§‹ç”¨äº†<code>sscratch</code>å¯„å­˜å™¨å…ˆå°†<code>a0</code>ä¿å­˜ä¸‹æ¥ï¼Œè®©<code>a0</code>æŒ‡å‘<code>trapframe</code>ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå½“å‰ç”¨æˆ·æ€æ‰€å æœ‰çš„æ‰€æœ‰å¯„å­˜å™¨ä¾æ¬¡ä¿å­˜ä¸‹æ¥ã€‚</p>
</blockquote>
<p><code>uservec</code>â€™s next task is to save the user registers. <strong>Before entering user space, the kernel previously set</strong> <code>sscratch</code> <strong>to point to a per-process</strong> <code>trapframe</code> <strong>that (among other things) has space to save all the user registers</strong> (kernel/proc.h:44). Because <code>satp</code> still refers to the user page table, <code>uservec</code> needs the <code>trapframe</code> to be mapped in the user address space. When creating each process, xv6 allocates a page for the processâ€™s <code>trapframe</code>, and arranges for <strong>it always to be mapped at user virtual address TRAPFRAME</strong>, which is just below TRAMPOLINE. The processâ€™s <code>p-&gt;trapframe</code> also points to the <code>trapframe</code>, though at its physical address so the kernel can use it through the kernel page table.</p>
<blockquote>
<p><code>sscratch</code>åœ¨å†…æ ¸æ€ä¸­é¢„å…ˆè¢«è®¾ç½®çš„åº”è¯¥æ˜¯ç”¨æˆ·æ€ä¸‹<code>trapframe</code>çš„ç»Ÿä¸€è™šæ‹Ÿåœ°å€ï¼Œæ¯ä¸ªprocesså†…éƒ¨å­˜å‚¨äº†ä¸€ä¸ªä»–æ‰€æ‹¥æœ‰çš„<code>trapframe</code>çš„ç‰©ç†åœ°å€ã€‚å½“ç„¶ï¼Œè¿™ä¸ªç‰©ç†åœ°å€å’Œç»Ÿä¸€è™šæ‹Ÿåœ°å€çš„æ˜ å°„è¢«è®°å½•åœ¨processçš„ç”¨æˆ·é¡µè¡¨ä¹‹ä¸­ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code>static struct proc*
allocproc(void)
{
  struct proc *p;

 ................................

found:
  p-&gt;pid = allocpid();

  // Allocate a trapframe page.
  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0){
    release(&amp;p-&gt;lock);
    return 0;
  }
</code></pre></div>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220525234504924.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220525234504924" src="../../../../assets/Operating%20Systems.assets/image-20220525234504924.png"></a></p>
<p>Thus after swapping a0 and <code>sscratch</code>, a0 holds a pointer to the current processâ€™s <code>trapframe</code>. <code>uservec</code> now saves all user registers there, including the userâ€™s a0, read from <code>sscratch</code>. The <code>trapframe</code> contains pointers to the current processâ€™s kernel stack, the current CPUâ€™s <code>hartid</code>, the address of <code>usertrap</code>, and the address of the kernel page table. <code>uservec</code> retrieves these values, switches <code>satp</code> to the kernel page table, and calls <code>usertrap</code>ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">trapframe</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="cm">/*   0 */</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">kernel_satp</span><span class="p">;</span><span class="w">   </span><span class="c1">// kernel page table</span>
<span class="w">  </span><span class="cm">/*   8 */</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">kernel_sp</span><span class="p">;</span><span class="w">     </span><span class="c1">// top of process's kernel stack</span>
<span class="w">  </span><span class="cm">/*  16 */</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">kernel_trap</span><span class="p">;</span><span class="w">   </span><span class="c1">// usertrap()</span>
<span class="w">  </span><span class="cm">/*  24 */</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">epc</span><span class="p">;</span><span class="w">           </span><span class="c1">// saved user program counter</span>
<span class="w">  </span><span class="cm">/*  32 */</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">kernel_hartid</span><span class="p">;</span><span class="w"> </span><span class="c1">// saved kernel tp</span>
<span class="w">    </span><span class="p">...............</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>uservec:
    #
        # trap.c sets stvec to point here, so
        # traps from user space start here,
        # in supervisor mode, but with a
        # user page table.
        #
        # sscratch points to where the process's p-&gt;trapframe is
        # mapped into user space, at TRAPFRAME.
        #

    # swap a0 and sscratch
        # so that a0 is TRAPFRAME
        csrrw a0, sscratch, a0

        # save the user registers in TRAPFRAME
        sd ra, 40(a0)
        sd sp, 48(a0)
        sd gp, 56(a0)
        sd tp, 64(a0)
        sd t0, 72(a0)
        sd t1, 80(a0)
        .
        .
        .
        # save the user a0 in p-&gt;trapframe-&gt;a0
        csrr t0, sscratch
        sd t0, 112(a0)

        # restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp
        ld sp, 8(a0)

        # make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid
        ld tp, 32(a0)

        # load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap
        ld t0, 16(a0)

        # restore kernel page table from p-&gt;trapframe-&gt;kernel_satp
        ld t1, 0(a0)
        csrw satp, t1
        sfence.vma zero, zero

        # a0 is no longer valid, since the kernel page
        # table does not specially map p-&gt;tf.

        # jump to usertrap(), which does not return
        jr t0
</code></pre></div>
<blockquote>
<p>ä¿å­˜å®Œäº†ç”¨æˆ·æ€å æœ‰çš„æ‰€æœ‰å¯„å­˜å™¨ï¼Œ<code>uservec</code>æœ€åŽé€šè¿‡<code>a0</code>ï¼ˆæ­¤æ—¶æŒ‡å‘çš„æ˜¯<code>trapframe</code>ï¼‰,å°†å…¶ä¸­çš„é‡è¦æ•°æ®ä¾æ¬¡å–å‡ºå¹¶è¦†ç›–ç›¸åº”çš„å¯„å­˜å™¨ï¼Œåˆ‡æ¢åˆ°å†…æ ¸é¡µè¡¨ï¼Œæ­¤æ—¶ï¼Œtrap handlerä»£ç çš„è¿è¡ŒçŽ¯å¢ƒå°±å·²ç»å‡†å¤‡å¥½äº†ã€‚æŽ¥ä¸‹æ¥ï¼ŒpcæŒ‡å‘<code>usertrap()</code>.</p>
</blockquote>
<hr>
<p><strong>The job of <code>usertrap</code> is to determine the cause of the trap, process it, and return</strong> (kernel/- trap.c:37).</p>
<p>As mentioned above, it first changes <code>stvec</code> so that a trap while in the kernel will be handled by <code>kernelvec</code>. <strong>It saves the <code>sepc</code> (the saved user program counter), again because there might be a process switch in <code>usertrap</code> that could cause <code>sepc</code> to be overwritten.</strong></p>
<p>If the trap is a system call, <code>syscall</code> handles it;</p>
<p>if a device interrupt, <code>devintr</code>;</p>
<p>otherwise itâ€™s an exception, and the kernel kills the faulting process.</p>
<p><strong>The system call path adds four to the saved user pc because RISC-V, in the case of a system call, leaves the program pointer pointing to the <code>ecall</code> instruction</strong>. On the way out, <code>usertrap</code> checks if the process has been killed or should yield the CPU (if this trap is a timer interrupt).</p>
<div class="highlight"><pre><span></span><code><span class="c1">//</span>
<span class="c1">// handle an interrupt, exception, or system call from user space.</span>
<span class="c1">// called from trampoline.S</span>
<span class="c1">//</span>
<span class="kt">void</span>
<span class="nf">usertrap</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">which_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">r_sstatus</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SSTATUS_SPP</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"usertrap: not from user mode"</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// send interrupts and exceptions to kerneltrap(),</span>
<span class="w">  </span><span class="c1">// since we're now in the kernel.</span>
<span class="w">  </span><span class="n">w_stvec</span><span class="p">((</span><span class="n">uint64</span><span class="p">)</span><span class="n">kernelvec</span><span class="p">);</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// save user program counter.</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_sepc</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">r_scause</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">8</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// system call</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
<span class="w">      </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// sepc points to the ecall instruction,</span>
<span class="w">    </span><span class="c1">// but we want to return to the next instruction.</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// an interrupt will change sstatus &amp;c registers,</span>
<span class="w">    </span><span class="c1">// so don't enable until done with those registers.</span>
<span class="w">    </span><span class="n">intr_on</span><span class="p">();</span>

<span class="w">    </span><span class="n">syscall</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">((</span><span class="n">which_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devintr</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// ok</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r_scause</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r_sepc</span><span class="p">(),</span><span class="w"> </span><span class="n">r_stval</span><span class="p">());</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">)</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// give up the CPU if this is a timer interrupt.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">which_dev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="n">yield</span><span class="p">();</span>

<span class="w">  </span><span class="n">usertrapret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>è¿™ä¸€éƒ¨åˆ†å°±æ˜¯å†…æ ¸æ€å¦‚ä½•å¤„ç†trapçš„ä»£ç äº†ï¼Œè¿™é‡Œå­˜æœ‰ä¸€ä¸ªæ²¡æœ‰ç†è§£çš„åœ°æ–¹ï¼šä¸ºä»€ä¹ˆpcè¦åŠ 4ï¼Ÿ(å› ä¸º<code>ecall</code>çš„æœºå™¨æŒ‡ä»¤æ˜¯4å­—èŠ‚ï¼ŒåŠ 4å°±ä¼šè·³åˆ°<code>ecall</code>çš„ä¸‹ä¸€ä¸ªæŒ‡ä»¤åŽ»)</p>
<p>æŽ¥ä¸‹æ¥å½“trapå¤„ç†å®Œæ¯•ï¼Œå°±è¦ç€æ‰‹å›žåˆ°ç”¨æˆ·æ€äº†ã€‚</p>
</blockquote>
<hr>
<p>The first step in returning to user space is the call to <code>usertrapret</code> (kernel/trap.c:90). This function sets up the RISC-V control registers to prepare for a future trap from user space.</p>
<p>This involves changing <code>stvec</code> to refer to <code>uservec</code>,</p>
<p>preparing the <code>trapframe</code> fields that <code>uservec</code> relies on, and</p>
<p>setting <code>sepc</code> to the previously saved user program counter. At the end,</p>
<p><code>usertrapret</code> calls <code>userret</code> on the trampoline page that is mapped in both user and kernel page tables; the reason is that assembly code in <code>userret</code> will switch page tables.</p>
<blockquote>
<p><code>stvec</code>ä¿å­˜ç€è§£å†³trapçš„ä»£ç ä½ç½®ï¼Œæ­¤æ—¶å°†ä»–æ¢å¤åˆ°<code>uservec</code>, ä¸ºä¸‹ä¸€æ¬¡ç”¨æˆ·æ€ä¸­æ–­åšå¥½å‡†å¤‡</p>
<p>æ¢å¤<code>trapframe</code>ä¿å­˜çš„ä¸Žkernelç›¸å…³çš„ç‰¹æ®Šæ•°æ®ï¼Œè¿™äº›æ•°æ®åœ¨å¤„ç†ä¸­æ–­çš„è¿‡ç¨‹ä¸­(åˆ‡æ¢å†…æ ¸é¡µè¡¨ï¼Œå†…æ ¸æ ˆç­‰)éƒ½è¢«<code>trampoline.S</code>ç”¨åˆ°ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">//</span>
<span class="c1">// return to user space</span>
<span class="c1">//</span>
<span class="kt">void</span>
<span class="nf">usertrapret</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// we're about to switch the destination of traps from</span>
<span class="w">  </span><span class="c1">// kerneltrap() to usertrap(), so turn off interrupts until</span>
<span class="w">  </span><span class="c1">// we're back in user space, where usertrap() is correct.</span>
<span class="w">  </span><span class="n">intr_off</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// send syscalls, interrupts, and exceptions to trampoline.S</span>
<span class="w">  </span><span class="n">w_stvec</span><span class="p">(</span><span class="n">TRAMPOLINE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">uservec</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">trampoline</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// set up trapframe values that uservec will need when</span>
<span class="w">  </span><span class="c1">// the process next re-enters the kernel.</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">kernel_satp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_satp</span><span class="p">();</span><span class="w">         </span><span class="c1">// kernel page table</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">kernel_sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span><span class="w"> </span><span class="c1">// process's kernel stack</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">kernel_trap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">usertrap</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">kernel_hartid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_tp</span><span class="p">();</span><span class="w">         </span><span class="c1">// hartid for cpuid()</span>

<span class="w">  </span><span class="c1">// set up the registers that trampoline.S's sret will use</span>
<span class="w">  </span><span class="c1">// to get to user space.</span>

<span class="w">  </span><span class="c1">// set S Previous Privilege mode to User.</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_sstatus</span><span class="p">();</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">SSTATUS_SPP</span><span class="p">;</span><span class="w"> </span><span class="c1">// clear SPP to 0 for user mode</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">SSTATUS_SPIE</span><span class="p">;</span><span class="w"> </span><span class="c1">// enable interrupts in user mode</span>
<span class="w">  </span><span class="n">w_sstatus</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// set S Exception Program Counter to the saved user pc.</span>
<span class="w">  </span><span class="n">w_sepc</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// tell trampoline.S the user page table to switch to.</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">satp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAKE_SATP</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// jump to trampoline.S at the top of memory, which</span>
<span class="w">  </span><span class="c1">// switches to the user page table, restores user registers,</span>
<span class="w">  </span><span class="c1">// and switches to user mode with sret.</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">fn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">TRAMPOLINE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">userret</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">trampoline</span><span class="p">);</span>
<span class="w">  </span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">uint64</span><span class="p">,</span><span class="n">uint64</span><span class="p">))</span><span class="n">fn</span><span class="p">)(</span><span class="n">TRAPFRAME</span><span class="p">,</span><span class="w"> </span><span class="n">satp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>usertrapret</code>â€™s call to <code>userret</code> passes a pointer to the processâ€™s user page table in <code>a0</code> and TRAPFRAME in <code>a1</code> (kernel/trampoline.S:88).</p>
<p><code>userret</code> switches <code>satp</code> to the processâ€™s user page table. Recall that the user page table maps both the trampoline page and TRAPFRAME, but nothing else from the kernel. Again, the fact that the trampoline page is mapped at the same virtual address in user and kernel page tables is what allows <code>uservec</code> to keep executing after changing <code>satp</code>.</p>
<p><code>userret</code> copies the <code>trapframe</code>â€™s saved user a0 to <code>sscratch</code> in preparation for a later swap with TRAPFRAME. From this point on, the only data <code>userret</code> can use is the register contents and the content of the <code>trapframe</code>. Next <code>userret</code> restores saved user registers from the <code>trapframe</code>, does a final swap of a0 and <code>sscratch</code> to restore the user a0 and save TRAPFRAME for the next trap, and uses <code>sret</code> to return to user space.</p>
<blockquote>
<p>è¿™é‡Œæˆ‘ä»¬å°±åˆå›žåˆ°äº†TRAMPOLINE.Sæ±‡ç¼–ä»£ç éƒ¨åˆ†äº†ï¼Œè¿™é‡Œæ€»ç»“ä¸€ä¸‹4.2èŠ‚çš„æ•´ä¸ªè°ƒç”¨è¿‡ç¨‹</p>
<p>å½“trapå‘ç”ŸåŽï¼ŒCPUä¼šå°†pcæŒ‡å‘<code>trampoline.S</code>çš„<code>uservec</code>éƒ¨åˆ†, æŽ¥ç€</p>
<p><code>uservec</code> -&gt; <code>usertrap</code> -&gt; <code>usertrapret</code> -&gt; <code>userret</code></p>
<p><code>userret</code>ä¸»è¦åšçš„äº‹å°±æ˜¯å°†é¡µè¡¨åˆ‡æ¢ä¸ºç”¨æˆ·é¡µè¡¨ï¼Œæ¢å¤ä¹‹å‰ä¿å­˜çš„ç”¨æˆ·æ€å¯„å­˜å™¨çš„å€¼ï¼Œæ¢å¤ç”¨æˆ·æ€çš„è¿è¡ŒçŽ¯å¢ƒã€‚è¿™é‡Œè¾¹éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œæ­¤æ—¶<code>p-&gt;trapframe-&gt;a0</code>å­˜å‚¨ç€trap handlerè¿è¡ŒåŽçš„è¿”å›žå€¼ï¼Œæ‰€ä»¥å…ˆç”¨<code>sscrach</code>å°†å…¶ä¿å­˜ï¼Œç„¶åŽ<code>a0</code>ç»§ç»­å……å½“TRAPFRAMEæ¥é€ä¸€æ¢å¤ç”¨æˆ·æ€trapå‰çš„å¯„å­˜å™¨å€¼ã€‚æœ€åŽå†å°†trapåŽçš„è¿”å›žå€¼ç»™<code>a0</code>ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code>.globl userret
userret:
        # userret(TRAPFRAME, pagetable)
        # switch from kernel to user.
        # usertrapret() calls here.
        # a0: TRAPFRAME, in user page table.
        # a1: user page table, for satp.

        # switch to the user page table.
        csrw satp, a1
        sfence.vma zero, zero

        # put the saved user a0 in sscratch, so we
        # can swap it with our a0 (TRAPFRAME) in the last step.
        ld t0, 112(a0)
        csrw sscratch, t0

        # restore all but a0 from TRAPFRAME
        ld ra, 40(a0)
        ld sp, 48(a0)
        ld gp, 56(a0)
        ld tp, 64(a0)
        ld t0, 72(a0)
    ...................................

    # restore user a0, and save TRAPFRAME in sscratch
        csrrw a0, sscratch, a0

        # return to user mode and user pc.
        # usertrapret() set up sstatus and sepc.
        sret
</code></pre></div>
<h3 id="43-code-calling-system-calls">4.3 Code: Calling system calls<a class="headerlink" href="#43-code-calling-system-calls" title="Permanent link">Â¶</a></h3>
<p>Chapter 2 ended with <code>initcode.S</code> invoking the exec system call (user/initcode.S:11).</p>
<div class="highlight"><pre><span></span><code>##include "syscall.h"

## exec(init, argv)
.globl start
start:
        la a0, init
        la a1, argv
        li a7, SYS_exec
        ecall

## for(;;) exit();
exit:
        li a7, SYS_exit
        ecall
        jal exit

## char init[] = "/init\0";
init:
  .string "/init\0"

## char *argv[] = { init, 0 };
.p2align 2
argv:
  .long init
  .long 0
</code></pre></div>
<p>Letâ€™s look at how the user call makes its way to the exec system callâ€™s implementation in the kernel. The user code places the arguments for exec in registers <code>a0</code> and <code>a1</code>, and puts the system call number in <code>a7</code>.</p>
<p>System call numbers match the entries in the <code>syscalls</code> array, a table of function pointers (kernel/syscall.c:108).</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">syscalls</span><span class="p">[])(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="p">[</span><span class="n">SYS_fork</span><span class="p">]</span><span class="w">    </span><span class="n">sys_fork</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exit</span><span class="p">]</span><span class="w">    </span><span class="n">sys_exit</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_wait</span><span class="p">]</span><span class="w">    </span><span class="n">sys_wait</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_pipe</span><span class="p">]</span><span class="w">    </span><span class="n">sys_pipe</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_read</span><span class="p">]</span><span class="w">    </span><span class="n">sys_read</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_kill</span><span class="p">]</span><span class="w">    </span><span class="n">sys_kill</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exec</span><span class="p">]</span><span class="w">    </span><span class="n">sys_exec</span><span class="p">,</span>
<span class="p">..........................</span>
<span class="p">};</span>
</code></pre></div>
<p>The <code>ecall</code> instruction traps into the kernel and executes <code>uservec</code>, <code>usertrap</code>, and then <code>syscall</code>, as we saw above. <code>syscall</code>(kernel/syscall.c:133) retrieves the system call number from the saved a7 in the <code>trapframe</code> and uses it to index into <code>syscalls</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NELEM</span><span class="p">(</span><span class="n">syscalls</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">]();</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %s: unknown sys call %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">            </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>For the first system call, a7 contains SYS_exec (kernel/syscall.h:8), resulting in a call to the system call implementation function sys_exec. When the system call implementation function returns, <code>syscall</code> records its return value in <code>p-&gt;trapframe-&gt;a0</code>. This will cause the original user-space call to exec() to return that value, since the C calling convention on RISC-V places return values in a0. System calls conventionally return negative numbers to indicate errors, and zero or positive numbers for success. If the system call number is invalid, <code>syscall</code> prints an error and returns âˆ’1.</p>
<h3 id="44-code-system-call-arguments">4.4 Code: System call arguments<a class="headerlink" href="#44-code-system-call-arguments" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°åœ¨å“ªé‡Œå‘¢ï¼Ÿå½“ç„¶æ˜¯å­˜åœ¨å¯„å­˜å™¨é‡Œï¼Œç„¶è€Œï¼Œåœ¨æˆ‘ä»¬è¿›å…¥trap handlerä¹‹å‰ï¼Œæˆ‘ä»¬ç”¨<code>trapframe</code>ä¿å­˜äº†æ‰€æœ‰çš„ç”¨æˆ·æ€çš„å¯„å­˜å™¨ï¼Œä»Žè€Œï¼Œç³»ç»Ÿè°ƒç”¨å‡½æ•°éœ€è¦åœ¨<code>p-&gt;trapframe</code>ä¸­èŽ·å–è‡ªå·±éœ€è¦çš„å‚æ•°ã€‚</p>
</blockquote>
<p>System call implementations in the kernel need to find the arguments passed by user code. <strong>Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers.</strong> The kernel trap code saves user registers to the current processâ€™s trap frame, where kernel code can find them. The functions <code>argint</code>, <code>argaddr</code>, and <code>argfd</code> retrieve the <code>nâ€™th</code> system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call <code>argraw</code> to retrieve the appropriate saved user register (kernel/syscall.c:35)</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">uint64</span>
<span class="nf">argraw</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a1</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a2</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a3</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a4</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="mi">5</span><span class="p">:</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a5</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"argraw"</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Fetch the nth 32-bit system call argument.</span>
<span class="kt">int</span>
<span class="nf">argint</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argraw</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Retrieve an argument as a pointer.</span>
<span class="c1">// Doesn't check for legality, since</span>
<span class="c1">// copyin/copyout will do that.</span>
<span class="kt">int</span>
<span class="nf">argaddr</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="o">*</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argraw</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<blockquote>
<p>æˆ‘ä»¬åœ¨ä½¿ç”¨å‘½ä»¤è¡Œæ—¶ï¼Œå‘<code>exec()</code>ç³»ç»Ÿè°ƒç”¨è¾“å…¥çš„æ˜¯ä¸€ç»„æŒ‡å‘å­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚è¿™é‡Œæœ€æ ¸å¿ƒçš„éš¾ç‚¹å°±æ˜¯ç”¨æˆ·æ€çš„æŒ‡é’ˆåœ°å€åªèƒ½è¢«ç”¨æˆ·é¡µè¡¨è§£æžï¼Œå¦‚ä½•è®©å†…æ ¸é¡µè¡¨çŸ¥é“è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å“ªä¸€å—ç‰©ç†å†…å­˜å‘¢ï¼Ÿ</p>
<p>é¡µè¡¨ç« èŠ‚çš„å®žéªŒåšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œæ¯ä¸ªè¿›ç¨‹éƒ½æ‹¥æœ‰ä¸€å¼ å†…æ ¸é¡µè¡¨å’Œä¸€å¼ ç”¨æˆ·é¡µè¡¨ï¼Œç”¨æˆ·é¡µè¡¨çš„æ˜ å°„ä¼šåŒæ—¶å­˜å‚¨åœ¨å†…æ ¸é¡µè¡¨ä¸Šï¼Œä»Žè€Œç”¨æˆ·ä¼ æ¥çš„æŒ‡é’ˆå¯ä»¥ç›´æŽ¥è¢«å†…æ ¸æ€ä½¿ç”¨ã€‚</p>
</blockquote>
<p>Some system calls pass pointers as arguments, and the kernel must use those pointers to read or write user memory. The <code>exec</code>system call, for example, passes the kernel an array of pointers referring to string arguments in user space. <strong>These pointers pose two challenges</strong>.</p>
<p><strong>First,</strong> the user program may be buggy or malicious, and may pass the kernel an invalid pointer or a pointer intended to trick the kernel into accessing kernel memory instead of user memory. <strong>Second,</strong> the xv6 <u>kernel page table mappings are not the same as the user page table mappings</u>, so the kernel <strong>cannot use ordinary instructions to load or store from user-supplied addresses</strong>.</p>
<p>The kernel implements functions that safely transfer data to and from user-supplied addresses. <code>fetchstr</code> is an example (kernel/syscall.c:25). File system calls such as exec use <code>fetchstr</code> to retrieve string file-name arguments from user space. <code>fetchstr</code> calls <code>copyinstr</code> to do the hard work.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Fetch the nul-terminated string at addr from the current process.</span>
<span class="c1">// Returns length of string, not including nul, or -1 for error.</span>
<span class="kt">int</span>
<span class="nf">fetchstr</span><span class="p">(</span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">copyinstr</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">buf</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">max</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<blockquote>
<p>è¿™é‡Œæˆ‘ä»¬é¢å¯¹çš„æ˜¯ä¸€ä¸ªæ¯ä¸ªè¿›ç¨‹å…±äº«å†…æ ¸é¡µè¡¨çš„æ“ä½œç³»ç»Ÿï¼Œè¿™é‡Œè§£å†³ä¸Šè¿°é—®é¢˜çš„æ–¹æ³•å°±æ˜¯ä¾é ä»£ç è€Œä¸æ˜¯CPUçš„ç‰©ç†æœºåˆ¶åŽ»æ‰¾åˆ°ç”¨æˆ·åœ°å€æ‰€å¯¹åº”çš„ç‰©ç†åœ°å€ã€‚</p>
</blockquote>
<p><code>copyinstr</code> (kernel/vm.c:406) copies up to max bytes to <code>dst</code> from virtual address <code>srcva</code> in the user page table <code>pagetable</code>. It uses <code>walkaddr</code> (which calls walk) to walk the page table in software to determine the physical address pa0 for <code>srcva</code>. Since the kernel maps all physical RAM addresses to the same kernel virtual address, <code>copyinstr</code> can directly copy string bytes from <code>pa0</code> to <code>dst</code>. <strong><code>walkaddr</code> (kernel/vm.c:95) checks that the user-supplied virtual address is part of the processâ€™s user address space, so programs cannot trick the kernel into reading other memory.</strong> A similar function, <code>copyout</code>, copies data from the kernel to a user-supplied address.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Copy a null-terminated string from user to kernel.</span>
<span class="c1">// Copy bytes to dst from virtual address srcva in a given page table,</span>
<span class="c1">// until a '\0', or max.</span>
<span class="c1">// Return 0 on success, -1 on error.</span>
<span class="kt">int</span>
<span class="nf">copyinstr</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">srcva</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">va0</span><span class="p">,</span><span class="w"> </span><span class="n">pa0</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">got_null</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">got_null</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">va0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">srcva</span><span class="p">);</span>
<span class="w">    </span><span class="n">pa0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">walkaddr</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">va0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pa0</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">srcva</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>
<span class="w">      </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pa0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">srcva</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">va0</span><span class="p">));</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\0'</span><span class="p">){</span>
<span class="w">        </span><span class="o">*</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sc">'\0'</span><span class="p">;</span>
<span class="w">        </span><span class="n">got_null</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="o">*</span><span class="n">dst</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="o">--</span><span class="n">n</span><span class="p">;</span>
<span class="w">      </span><span class="o">--</span><span class="n">max</span><span class="p">;</span>
<span class="w">      </span><span class="n">p</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">dst</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">srcva</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">va0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">got_null</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="45-traps-from-kernel-space">4.5 Traps from kernel space<a class="headerlink" href="#45-traps-from-kernel-space" title="Permanent link">Â¶</a></h3>
<p>Xv6 configures the CPU trap registers somewhat differently depending on whether user or kernel code is executing. When the kernel is executing on a CPU, the kernel points <code>stvec</code> to the assembly code at <code>kernelvec</code> (kernel/kernelvec.S:10). Since xv6 is already in the kernel, <code>kernelvec</code> can rely on <code>satp</code> being set to the kernel page table, and on the stack pointer referring to a valid kernel stack. <code>kernelvec</code> saves all registers so that the interrupted code can eventually resume without disturbance.</p>
<p><code>kernelvec</code> <strong>saves the registers on the stack of the interrupted kernel thread</strong>, which makes sense because the register values belong to that thread. <u>This is particularly important if the trap causes a switch to a different thread â€“ in that case the trap will actually return on the stack of the new thread, leaving the interrupted threadâ€™s saved registers safely on its stack.</u></p>
<div class="highlight"><pre><span></span><code>    #
        # interrupts and exceptions while in supervisor
        # mode come here.
        #
        # push all registers, call kerneltrap(), restore, return.
        #
.globl kerneltrap
.globl kernelvec
.align 4
kernelvec:
        // make room to save registers.
        addi sp, sp, -256

        // save the registers.
        sd ra, 0(sp)
        sd sp, 8(sp)
        sd gp, 16(sp)
        sd tp, 24(sp)
        sd t0, 32(sp)
        sd t1, 40(sp)
      ....................................

    // call the C trap handler in trap.c
        call kerneltrap
</code></pre></div>
<p><code>kernelvec</code> jumps to <code>kerneltrap</code> (kernel/trap.c:134) after saving registers. <code>kerneltrap</code> is prepared for two types of traps: <code>device interrupts</code> and <code>exceptions</code>. It calls <code>devintr</code> (kernel/- trap.c:177) to check for and handle the former. If the trap isnâ€™t a device interrupt, it must be an exception, and that is always a fatal error if it occurs in the xv6 kernel; the kernel calls panic and stops executing.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// interrupts and exceptions from kernel code go here via kernelvec,</span>
<span class="c1">// on whatever the current kernel stack is.</span>
<span class="kt">void</span>
<span class="nf">kerneltrap</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">which_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">sepc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_sepc</span><span class="p">();</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">sstatus</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_sstatus</span><span class="p">();</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">scause</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_scause</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">sstatus</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">SSTATUS_SPP</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"kerneltrap: not from supervisor mode"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">intr_get</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"kerneltrap: interrupts enabled"</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">which_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devintr</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"scause %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">scause</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r_sepc</span><span class="p">(),</span><span class="w"> </span><span class="n">r_stval</span><span class="p">());</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"kerneltrap"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// give up the CPU if this is a timer interrupt.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">which_dev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">)</span>
<span class="w">    </span><span class="n">yield</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// the yield() may have caused some traps to occur,</span>
<span class="w">  </span><span class="c1">// so restore trap registers for use by kernelvec.S's sepc instruction.</span>
<span class="w">  </span><span class="n">w_sepc</span><span class="p">(</span><span class="n">sepc</span><span class="p">);</span>
<span class="w">  </span><span class="n">w_sstatus</span><span class="p">(</span><span class="n">sstatus</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>è¿™é‡Œè®¨è®ºäº†çº¿ç¨‹å’Œtrapä¹‹é—´çš„å…³ç³»ï¼Œéœ€è¦åœ¨å­¦å®Œç¬¬ä¸ƒç« åŽæ¥è¿™é‡Œè¡¥å……</p>
</blockquote>
<p>If <code>kerneltrap</code> was called due to a timer interrupt, and a processâ€™s kernel thread is running (rather than a scheduler thread), <code>kerneltrap</code> calls yield to give other threads a chance to run. At some point one of those threads will yield, and let our thread and its <code>kerneltrap</code> resume again. Chapter 7 explains what happens in yield.</p>
<p>When <code>kerneltrap</code>â€™s work is done, it needs to return to whatever code was interrupted by the trap. Because a yield may have disturbed the saved <code>sepc</code> and the saved previous mode in <code>sstatus</code>, <code>kerneltrap</code> saves them when it starts. It now restores those control registers and returns to <code>kernelvec</code> (kernel/kernelvec.S:48). <code>kernelvec</code> pops the saved registers from the stack and executes <code>sret</code>, which copies <code>sepc</code> to pc and resumes the interrupted kernel code.</p>
<p>Itâ€™s worth thinking through how the trap return happens if <code>kerneltrap</code> called yield due to a timer interrupt.</p>
<div class="highlight"><pre><span></span><code>// call the C trap handler in trap.c
        call kerneltrap

        // restore registers.
        ld ra, 0(sp)
        ld sp, 8(sp)
        ld gp, 16(sp)
        // not this, in case we moved CPUs: ld tp, 24(sp)
        ld t0, 32(sp)
        ld t1, 40(sp)
        ld t2, 48(sp)
        ld s0, 56(sp)
        ld s1, 64(sp)
       ..........................................

        addi sp, sp, 256

        // return to whatever we were doing in the kernel.
        sret
</code></pre></div>
<p>Xv6 sets a CPUâ€™s <code>stvec</code> to <code>kernelvec</code> when that CPU enters the kernel from user space; you can see this in <code>usertrap</code> (kernel/trap.c:29). <strong>Thereâ€™s a window of time when the kernel is executing but <code>stvec</code> is set to <code>uservec</code>, and itâ€™s crucial that device interrupts be disabled during that window</strong>. Luckily the RISC-V always disables interrupts when it starts to take a trap, and xv6 doesnâ€™t enable them again until after it sets <code>stvec</code>.</p>
<h3 id="46-page-fault-exceptions">4.6 Page-fault exceptions<a class="headerlink" href="#46-page-fault-exceptions" title="Permanent link">Â¶</a></h3>
<p>Xv6â€™s response to exceptions is quite boring: if an exception happens in user space, the kernel kills the faulting process. If an exception happens in the kernel, the kernel panics. Real operating systems often respond in much more interesting ways.</p>
<p>As an example, many kernels use page faults to implement <strong><code>copy-on-write (COW) fork</code></strong>. To explain copy-on-write fork, consider xv6â€™s fork, described in Chapter 3. fork causes the child to have the same memory content as the parent, by calling <code>uvmcopy</code> (kernel/vm.c:309) to allocate physical memory for the child and copy the parentâ€™s memory into it. It would be more efficient if the child and parent could share the parentâ€™s physical memory. A straightforward implementation of this would not work, however, since it would cause the parent and child to disrupt each otherâ€™s execution with their writes to the shared stack and heap.</p>
<p>Parent and child can safely share <code>phyical</code> memory using copy-on-write fork, driven by page faults. When a CPU cannot translate a virtual address to a physical address, the CPU generates a page-fault exception. RISC-V has <strong>three different kinds of page fault:</strong> <code>load page faults</code> (when a load instruction cannot translate its virtual address), <code>store page faults</code> (when a store instruction cannot translate its virtual address), and <code>instruction page faults</code> (when the address for an instruction doesnâ€™t translate). The value in the <code>scause</code> register indicates the type of the page fault and the <code>stval</code> register contains the address that couldnâ€™t be translated.</p>
<p>The basic plan in COW fork is for the parent and child to <strong>initially share all physical pages</strong>, but to map them <strong>read-only</strong>. Thus, when the child or parent executes a store instruction, the RISC-V <strong>CPU raises a page-fault exception</strong>. In response to this exception, the <strong>kernel makes a copy of the page that contains the faulted address</strong>. It maps one copy read/write in the childâ€™s address space and the other copy read/write in the parentâ€™s address space. After updating the page tables, <strong>the kernel resumes the faulting process at the instruction that caused the fault</strong>. Because the kernel has updated the relevant PTE to allow writes, the faulting instruction will now execute without a fault.</p>
<p>This COW plan works well for fork, because often the child calls <code>exec</code> immediately after the fork, replacing its address space with a new address space. In that common case, the child will experience only a few page faults, and the kernel can avoid making a complete copy. Furthermore, COW fork is transparent: no modifications to applications are necessary for them to benefit.</p>
<p>The combination of page tables and page faults opens up a wide-range of interesting possibilities other than COW fork. Another widely-used feature is called <strong><code>lazy allocation</code></strong>, which has two parts. First, when an application calls <code>sbrk</code>, the <strong>kernel grows the address space, but marks the new addresses as not valid in the page table.</strong> Second, <strong>on a page fault on one of those new addresses, the kernel allocates physical memory and maps it into the page table</strong>. Since applications often ask for more memory than they need, lazy allocation is a win: the kernel allocates memory only when the application actually uses it. Like COW fork, the kernel can implement this feature transparently to applications.</p>
<p>Yet another widely-used feature that exploits page faults is <strong><code>paging from disk</code></strong>. <u>If applications need more memory than the available physical RAM, the kernel can evict some pages: write them to a storage device such as a disk and mark their PTEs as not valid</u>. If an application reads or writes an evicted page, the CPU will experience a page fault. The kernel can then inspect the faulting address. If the address belongs to a page that is on disk, the kernel allocates a page of physical memory, reads the page from disk to that memory, updates the PTE to be valid and refer to that memory, and resumes the application. To make room for the page, the kernel may have to evict another page. This feature requires no changes to applications, and works well if applications have locality of reference (i.e., they use only a subset of their memory at any given time).</p>
<p>Other features that combine paging and page-fault exceptions include automatically extending stacks and memory-mapped files.</p>
<h2 id="chapter5-interrupts-and-device-drivers">Chapter5. Interrupts and device drivers<a class="headerlink" href="#chapter5-interrupts-and-device-drivers" title="Permanent link">Â¶</a></h2>
<p>A driver is the code in an operating system that manages a particular device: it configures the device hardware, tells the device to perform operations, handles the resulting interrupts, and interacts with processes that may be waiting for I/O from the device. Driver code can be tricky because a driver executes concurrently with the device that it manages. In addition, the driver must understand the deviceâ€™s hardware interface, which can be complex and poorly documented. Devices that need attention from the operating system can usually be configured to generate interrupts, which are one type of trap. The kernel trap handling code recognizes when a device has raised an interrupt and calls the driverâ€™s interrupt handler; in xv6, this dispatch happens in <code>devintr</code> (kernel/trap.c:177).</p>
<p>Many <strong>device drivers</strong> execute code in two contexts: <strong>a top half that runs in a processâ€™s kernel thread, and a bottom half that executes at interrupt time.</strong></p>
<ul>
<li>
<p><strong>The top half</strong> is called via system calls such as read and write that want the device to perform I/O. This code may ask the hardware to start an operation (e.g., ask the disk to read a block); then the code waits for the operation to complete. Eventually the device completes the operation and raises an interrupt.</p>
</li>
<li>
<p>The driverâ€™s interrupt handler, acting as <strong>the bottom half</strong>, figures out what operation has completed, wakes up a waiting process if appropriate, and tells the hardware to start work on any waiting next operation.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// check if it's an external interrupt or software interrupt,</span>
<span class="c1">// and handle it.</span>
<span class="c1">// returns 2 if timer interrupt,</span>
<span class="c1">// 1 if other device,</span>
<span class="c1">// 0 if not recognized.</span>
<span class="kt">int</span>
<span class="nf">devintr</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">scause</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_scause</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">scause</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x8000000000000000L</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">     </span><span class="p">(</span><span class="n">scause</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0xff</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">9</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// this is a supervisor external interrupt, via PLIC.</span>

<span class="w">    </span><span class="c1">// irq indicates which device interrupted.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plic_claim</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UART0_IRQ</span><span class="p">){</span>
<span class="w">      </span><span class="n">uartintr</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VIRTIO0_IRQ</span><span class="p">){</span>
<span class="w">      </span><span class="n">virtio_disk_intr</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="p">){</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"unexpected interrupt irq=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">irq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// the PLIC allows each device to raise at most one</span>
<span class="w">    </span><span class="c1">// interrupt at a time; tell the PLIC the device is</span>
<span class="w">    </span><span class="c1">// now allowed to interrupt again.</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="p">)</span>
<span class="w">      </span><span class="n">plic_complete</span><span class="p">(</span><span class="n">irq</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">scause</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mh">0x8000000000000001L</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// software interrupt from a machine-mode timer interrupt,</span>
<span class="w">    </span><span class="c1">// forwarded by timervec in kernelvec.S.</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">cpuid</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">clockintr</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// acknowledge the software interrupt by clearing</span>
<span class="w">    </span><span class="c1">// the SSIP bit in sip.</span>
<span class="w">    </span><span class="n">w_sip</span><span class="p">(</span><span class="n">r_sip</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="o">~</span><span class="mi">2</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="51-code-console-input">5.1 Code: Console input<a class="headerlink" href="#51-code-console-input" title="Permanent link">Â¶</a></h3>
<p>The console driver (<code>console.c</code>) is a simple illustration of driver structure.</p>
<p>The <strong>console driver accepts characters typed by a human, via the UART</strong> serial-port hardware attached to the RISC-V. The console driver accumulates a line of input at a time, processing special input characters such as backspace and control-u.</p>
<p>User processes, such as the <strong>shell, use the read system call to fetch lines of input from the console</strong>. When you type input to xv6 in QEMU, your keystrokes are delivered to xv6 by way of QEMUâ€™s simulated UART hardware. The UART hardware that the driver talks to is a 16550 chip [11] emulated by QEMU. On a real computer, a 16550 would manage an RS232 serial link connecting to a terminal or other computer. When running QEMU, itâ€™s connected to your keyboard and display.</p>
<p><strong>The UART hardware appears to software as a set of memory-mapped control registers.</strong> That is, there are some physical addresses that RISC-V hardware connects to the UART device, so that loads and stores interact with the device hardware rather than RAM. The memory-mapped addresses for the UART start at 0x10000000, or UART0 (kernel/memlayout.h:21). There are a handful of UART control registers, each the width of a byte. Their offsets from UART0 are defined in (kernel/uart.c:22). For example, the LSR register contain bits that indicate whether input characters are waiting to be read by the software. These characters (if any) are available for reading from the RHR register. Each time one is read, the UART hardware deletes it from an internal FIFO of waiting characters, and clears the â€œreadyâ€ bit in LSR when the FIFO is empty. The UART transmit hardware is largely independent of the receive hardware; if software writes a byte to the THR, the UART transmit that byte.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// the UART control registers.</span>
<span class="c1">// some have different meanings for</span>
<span class="c1">// read vs write.</span>
<span class="c1">// see http://byterunner.com/16550.html</span>
<span class="cp">##define RHR 0                 </span><span class="c1">// receive holding register (for input bytes)</span>
<span class="cp">##define THR 0                 </span><span class="c1">// transmit holding register (for output bytes)</span>
<span class="cp">##define IER 1                 </span><span class="c1">// interrupt enable register</span>
<span class="cp">##define IER_RX_ENABLE (1&lt;&lt;0)</span>
<span class="cp">##define IER_TX_ENABLE (1&lt;&lt;1)</span>
<span class="cp">##define FCR 2                 </span><span class="c1">// FIFO control register</span>
<span class="cp">##define FCR_FIFO_ENABLE (1&lt;&lt;0)</span>
<span class="cp">##define FCR_FIFO_CLEAR (3&lt;&lt;1) </span><span class="c1">// clear the content of the two FIFOs</span>
<span class="cp">##define ISR 2                 </span><span class="c1">// interrupt status register</span>
<span class="cp">##define LCR 3                 </span><span class="c1">// line control register</span>
<span class="cp">##define LCR_EIGHT_BITS (3&lt;&lt;0)</span>
<span class="cp">##define LCR_BAUD_LATCH (1&lt;&lt;7) </span><span class="c1">// special mode to set baud rate</span>
<span class="cp">##define LSR 5                 </span><span class="c1">// line status register</span>
<span class="cp">##define LSR_RX_READY (1&lt;&lt;0)   </span><span class="c1">// input is waiting to be read from RHR</span>
<span class="cp">##define LSR_TX_IDLE (1&lt;&lt;5)    </span><span class="c1">// THR can accept another character to send</span>
</code></pre></div>
<p>Xv6â€™s main calls <code>consoleinit</code> (kernel/console.c:184) to initialize the UART hardware. This code configures the UART to</p>
<ul>
<li><strong>generate a receive interrupt when the UART receives each byte of input,</strong> and</li>
<li><strong>a transmit complete interrupt each time the UART finishes sending a byte of output</strong> (kernel/uart.c:53).</li>
</ul>
<blockquote>
<p>UARTæ˜¯deviceå’Œconsoleä¹‹é—´äº¤äº’çš„æ¡¥æ¢ï¼Œè¿™é‡Œä¸»è¦è¯´æ˜Žäº†UARTå’Œdeviceä¹‹é—´çš„å…³ç³»ï¼Œæ¯å½“æˆ‘ä»¬ä½¿ç”¨keyboardæŒ‰ä¸‹ä¸€ä¸ªæŒ‰é”®æ—¶ï¼ŒUARTå°±ä¼šè§¦å‘ä¸€ä¸ªæŽ¥æ”¶ä¸­æ–­ï¼›æ¯å½“UARTè¿›è¡Œäº†ä¸€æ¬¡ä¼ è¾“æ—¶ï¼Œå°±ä¼šè§¦å‘ä¸€æ¬¡ä¼ è¾“å®Œæˆçš„ä¸­æ–­ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">consoleinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"cons"</span><span class="p">);</span>

<span class="w">  </span><span class="n">uartinit</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// connect read and write system calls</span>
<span class="w">  </span><span class="c1">// to consoleread and consolewrite.</span>
<span class="w">  </span><span class="n">devsw</span><span class="p">[</span><span class="n">CONSOLE</span><span class="p">].</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">consoleread</span><span class="p">;</span>
<span class="w">  </span><span class="n">devsw</span><span class="p">[</span><span class="n">CONSOLE</span><span class="p">].</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">consolewrite</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">uartinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// disable interrupts.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="n">IER</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// special mode to set baud rate.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="n">LCR</span><span class="p">,</span><span class="w"> </span><span class="n">LCR_BAUD_LATCH</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// LSB for baud rate of 38.4K.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x03</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// MSB for baud rate of 38.4K.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mh">0x00</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// leave set-baud mode,</span>
<span class="w">  </span><span class="c1">// and set word length to 8 bits, no parity.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="n">LCR</span><span class="p">,</span><span class="w"> </span><span class="n">LCR_EIGHT_BITS</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// reset and enable FIFOs.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="n">FCR</span><span class="p">,</span><span class="w"> </span><span class="n">FCR_FIFO_ENABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">FCR_FIFO_CLEAR</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// enable transmit and receive interrupts.</span>
<span class="w">  </span><span class="n">WriteReg</span><span class="p">(</span><span class="n">IER</span><span class="p">,</span><span class="w"> </span><span class="n">IER_TX_ENABLE</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">IER_RX_ENABLE</span><span class="p">);</span>

<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">,</span><span class="w"> </span><span class="s">"uart"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The xv6 <strong>shell reads from the console by way of a file descriptor opened by <code>init.c</code></strong> (user/init.c:19). Calls to the read system call make their way through the kernel to <code>consoleread</code> (kernel/console.c:82). <code>consoleread</code> waits for input to arrive (via interrupts) and be buffered in <code>cons.buf</code>, copies the input to user space, and (after a whole line has arrived) returns to the user process. <strong>If the user hasnâ€™t typed a full line yet, any reading processes will wait in the sleep call (kernel/console.c:98)</strong> (Chapter 7 explains the details of sleep).</p>
<blockquote>
<p>ç³»ç»Ÿè°ƒç”¨<code>read()</code>æœ€åŽçš„çœŸæ­£å®žçŽ°æ˜¯<code>consoleread()</code>. consoleæ˜¯è¿žæŽ¥ç”¨æˆ·å’ŒUARTçš„æ¡¥æ¢ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// user/init.c:19</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">wpid</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">open</span><span class="p">(</span><span class="s">"console"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">mknod</span><span class="p">(</span><span class="s">"console"</span><span class="p">,</span><span class="w"> </span><span class="n">CONSOLE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">open</span><span class="p">(</span><span class="s">"console"</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="p">...........</span>
<span class="p">}</span>

<span class="c1">// kernel/console.c:82</span>
<span class="c1">// user read()s from the console go here.</span>
<span class="c1">// copy (up to) a whole input line to dst.</span>
<span class="c1">// user_dist indicates whether dst is a user</span>
<span class="c1">// or kernel address.</span>
<span class="c1">//</span>
<span class="kt">int</span>
<span class="nf">consoleread</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">user_dst</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">target</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">cbuf</span><span class="p">;</span>

<span class="w">  </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// wait until interrupt handler has put some</span>
<span class="w">    </span><span class="c1">// input into cons.buffer.</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">w</span><span class="p">){</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
<span class="w">        </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="o">++</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">INPUT_BUF</span><span class="p">];</span>
<span class="w">      </span><span class="p">.......</span>

<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>When the user types a character, the UART hardware asks the RISC-V to raise an interrupt, which activates xv6â€™s trap handler. The trap handler calls <code>devintr</code> (kernel/trap.c:177), which looks at the RISC-V <code>scause</code> register to discover that the interrupt is from an external device. Then it asks a hardware unit called the PLIC [1] to tell it which device interrupted (kernel/trap.c:186). If it was the UART, <code>devintr</code> calls <code>uartintr</code>.</p>
<blockquote>
<p>è¿™é‡Œå¯¹device â†’ UARTä¹‹é—´çš„å…³ç³»ä½œäº†è¯´æ˜Žã€‚ç”¨æˆ·é”®å…¥ä¸€ä¸ªå­—ç¬¦ï¼ŒUARTè§¦å‘æŽ¥æ”¶ä¸­æ–­ä»Žè€Œè§¦å‘trap handlerã€‚è¿™ç±»å¤–éƒ¨deviceä¸­æ–­éƒ½ä¼šè¢«äº¤ç»™<code>devintr()</code>å¤„ç†ï¼Œå®ƒä¼šè¯¢é—®PLICæ˜¯å“ªä¸€ä¸ªå¤–éƒ¨deviceåšå‡ºäº†è¿™ä¸ªä¸­æ–­ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// irq indicates which device interrupted.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">irq</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plic_claim</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UART0_IRQ</span><span class="p">){</span>
<span class="w">      </span><span class="n">uartintr</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">VIRTIO0_IRQ</span><span class="p">){</span>
<span class="w">      </span><span class="n">virtio_disk_intr</span><span class="p">();</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">irq</span><span class="p">){</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"unexpected interrupt irq=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">irq</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div>
<p><code>uartintr</code> (kernel/uart.c:180) reads any waiting input characters from the UART hardware and hands them to <code>consoleintr</code> (kernel/console.c:138); it doesnâ€™t wait for characters, since future input will raise a new interrupt. <strong>The job of <code>consoleintr</code> is to accumulate input characters in <code>cons.buf</code> until a whole line arrives.</strong> <code>consoleintr</code> treats backspace and a few other characters specially. When a newline arrives, <code>consoleintr</code> wakes up a waiting <code>consoleread</code> (if there is one).</p>
<p>Once woken, <code>consoleread</code> will observe a full line in <code>cons.buf</code>, copy it to user space, and return (via the system call machinery) to user space.</p>
<blockquote>
<p>è¿™é‡Œå¯¹UARTâ†’consoleä¹‹é—´çš„å…³ç³»ä½œäº†è¯´æ˜Žã€‚åœ¨ä¸Šä¸€æ­¥UARTè§¦å‘äº†æŽ¥æ”¶ä¸­æ–­åŽï¼Œ<code>trap.c</code>ä¸­çš„ä»£ç å°†ä»–å¼•å…¥åˆ°ç›¸åº”çš„handlerå‡½æ•°ä¸­ã€‚<code>uartintr()</code>ä¸ºUARTå‘èµ·çš„å¤–éƒ¨ä¸­æ–­çš„å¤„ç†å‡½æ•°, ä»–çš„ä¸»è¦å·¥ä½œå°±æ˜¯é€šè¿‡<code>uartgetc()</code>ä»Žç›¸åº”çš„å¤–éƒ¨è®¾å¤‡ä¸­çš„å¯„å­˜å™¨ä¸­è¯»å–è¾“å…¥çš„å­—ç¬¦ï¼Œè¯»åˆ°åŽç«‹åˆ»ä¼ å…¥<code>consoleintr(c)</code>. <code>consoleintr()</code>ä¸­çš„ä»£ç ä¼šå…ˆå¤„ç†ä¸€äº›ç‰¹æ®Šå­—ç¬¦æŒ‡ä»¤ï¼Œä½†å…¶æ ¸å¿ƒåŠŸèƒ½å°±æ˜¯ç»´æŠ¤<code>cons.buf</code>, è¿™ä¸ªç¼“å†²åŒºå°±æ˜¯ä¸€ä¸ªç§¯ç´¯å­—ç¬¦çš„åœ°æ–¹ï¼Œå½“å®ƒç§¯ç´¯äº†ä¸€è¡Œæ—¶ï¼Œå®ƒå°±éœ€è¦å”¤é†’<code>consoleread</code>æ¥æ¶ˆè´¹ä»–åœ¨bufferä¸­å·²ç»å­˜å…¥çš„å†…å®¹ã€‚</p>
<p><strong>è¿™é‡Œç”¨bufferä½“çŽ°äº†ä¸€ç§ç”Ÿäº§è€…-æ¶ˆè´¹è€…çš„æ¨¡å¼</strong></p>
<hr>
<p>ä¸¾ä¸ªä¾‹å­ï¼š</p>
<p>è¿™é‡Œå¯ä»¥æƒ³æƒ³<code>ls</code>æŒ‡ä»¤ï¼Œæˆ‘ä»¬åˆ†åˆ«è¾“å…¥äº†<code>l,s</code>ä¸¤ä¸ªå­—ç¬¦ï¼Œä»–ä»¬è§¦å‘äº†ä¸¤æ¬¡ä¸­æ–­ï¼Œæ¯æ¬¡ä¸­æ–­åˆ†åˆ«å°†<code>l</code>,<code>s</code>åŠ å…¥åˆ°consoleçš„bufferä¹‹ä¸­ï¼Œç„¶åŽæˆ‘ä»¬æ•²å‡»å›žè½¦ï¼Œåˆå¼•å‘äº†ä¸­æ–­ï¼Œè¿™æ—¶consoleå‘çŽ°å®ƒèŽ·å¾—äº†ä¸€ä¸ªå®Œæ•´çš„å¥å­ï¼Œä»–å°±ä¼šå”¤é†’<code>consoleread()</code>æŠŠbufferä¸­çš„<code>ls</code>æŒ‡ä»¤å‘ç»™ä»–ï¼Œè¿›è€Œç³»ç»Ÿè°ƒç”¨readä¹Ÿå°±å¾—åˆ°äº†<code>ls</code>ï¼ŒæŽ¥ç€shellå°±å¯ä»¥å¼€å¯lsè¿›ç¨‹äº†ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// handle a uart interrupt, raised because input has</span>
<span class="c1">// arrived, or the uart is ready for more output, or</span>
<span class="c1">// both. called from trap.c.</span>
<span class="kt">void</span>
<span class="nf">uartintr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// read and process incoming characters.</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uartgetc</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">consoleintr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// send buffered characters.</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">uartstart</span><span class="p">();</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//</span>
<span class="c1">// the console input interrupt handler.</span>
<span class="c1">// uartintr() calls this for input character.</span>
<span class="c1">// do erase/kill processing, append to cons.buf,</span>
<span class="c1">// wake up consoleread() if a whole line has arrived.</span>
<span class="c1">//</span>
<span class="kt">void</span>
<span class="nf">consoleintr</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">switch</span><span class="p">(</span><span class="n">c</span><span class="p">){</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">C</span><span class="p">(</span><span class="sc">'P'</span><span class="p">):</span><span class="w">  </span><span class="c1">// Print process list.</span>
<span class="w">    </span><span class="n">procdump</span><span class="p">();</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">C</span><span class="p">(</span><span class="sc">'U'</span><span class="p">):</span><span class="w">  </span><span class="c1">// Kill line.</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">&amp;&amp;</span>
<span class="w">          </span><span class="n">cons</span><span class="p">.</span><span class="n">buf</span><span class="p">[(</span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">INPUT_BUF</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="sc">'\n'</span><span class="p">){</span>
<span class="w">      </span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="o">--</span><span class="p">;</span>
<span class="w">      </span><span class="n">consputc</span><span class="p">(</span><span class="n">BACKSPACE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">C</span><span class="p">(</span><span class="sc">'H'</span><span class="p">):</span><span class="w"> </span><span class="c1">// Backspace</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="sc">'\x7f'</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">w</span><span class="p">){</span>
<span class="w">      </span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="o">--</span><span class="p">;</span>
<span class="w">      </span><span class="n">consputc</span><span class="p">(</span><span class="n">BACKSPACE</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="k">default</span><span class="o">:</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="o">-</span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">INPUT_BUF</span><span class="p">){</span>
<span class="w">      </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\r'</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="sc">'\n'</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>

<span class="w">      </span><span class="c1">// echo back to the user.</span>
<span class="w">      </span><span class="n">consputc</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

<span class="w">      </span><span class="c1">// store for consumption by consoleread().</span>
<span class="w">      </span><span class="n">cons</span><span class="p">.</span><span class="n">buf</span><span class="p">[</span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="o">++</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">INPUT_BUF</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\n'</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="sc">'D'</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="o">+</span><span class="n">INPUT_BUF</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// wake up consoleread() if a whole line (or end-of-file)</span>
<span class="w">        </span><span class="c1">// has arrived.</span>
<span class="w">        </span><span class="n">cons</span><span class="p">.</span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cons</span><span class="p">.</span><span class="n">e</span><span class="p">;</span>
<span class="w">        </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">r</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cons</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="52-code-console-output">5.2 Code: Console output<a class="headerlink" href="#52-code-console-output" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>ä¸Šä¸€èŠ‚è¯´çš„æ˜¯ç³»ç»Ÿè°ƒç”¨<code>read()</code>æ˜¯æ€Žä¹ˆè¯»åˆ°ç”¨æˆ·è¾“å…¥çš„<code>ls</code>å¹¶è¿”å›žç»™å†…æ ¸çš„ï¼Œè¿™ä¸€èŠ‚è¯´çš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨shellå‘½ä»¤è¡Œè¾“å…¥<code>l,s</code>æ—¶ï¼Œä»–æ˜¯å¦‚ä½•è¢«ä¸€ä¸ªä¸€ä¸ªçš„æ‰“å°åœ¨å‘½ä»¤è¡Œä¸­çš„ã€‚è¿™é‡Œå’Œ<code>console.c</code>æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œè¿™é‡Œæ—¶UARTä¼šå°†bufferä¸­çš„å­—ç¬¦å‘é€ç»™å…¶ä»–çš„deviceï¼Œä¾‹å¦‚æ˜¾å­˜ã€‚</p>
</blockquote>
<p>A <strong>write system call</strong> on a file descriptor connected to the console eventually arrives at <strong><code>uartputc</code> (kernel/uart.c:87).</strong> The device driver maintains an output buffer (<code>uart_tx_buf</code>) so that writing processes do not have to wait for the UART to finish sending; instead, <code>uartputc</code> appends each character to the buffer, calls <code>uartstart</code> to start the device transmitting (if it isnâ€™t already), and returns. The only situation in which <code>uartputc</code> waits is if the buffer is already full.</p>
<blockquote>
<p>å¯ä»¥çœ‹åˆ°UARTè¿™éƒ¨åˆ†çš„ä»£ç ä¹Ÿç”¨åˆ°äº†**æ¶ˆè´¹è€…-ç”Ÿäº§è€…æ¨¡å¼**ï¼Œä»–ä¹Ÿç»´æŠ¤äº†ä¸€ä¸ªbufferç”¨æ¥æš‚å­˜åƒ<code>printf()</code>è¿™æ ·çš„å‡½æ•°å‘æ¥çš„å­—ç¬¦ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// add a character to the output buffer and tell the</span>
<span class="c1">// UART to start sending if it isn't already.</span>
<span class="c1">// blocks if the output buffer is full.</span>
<span class="c1">// because it may block, it can't be called</span>
<span class="c1">// from interrupts; it's only suitable for use</span>
<span class="c1">// by write().</span>

<span class="cp">##define UART_TX_BUF_SIZE 32</span>
<span class="kt">char</span><span class="w"> </span><span class="n">uart_tx_buf</span><span class="p">[</span><span class="n">UART_TX_BUF_SIZE</span><span class="p">];</span>
<span class="n">uint64</span><span class="w"> </span><span class="n">uart_tx_w</span><span class="p">;</span><span class="w"> </span><span class="c1">// write next to uart_tx_buf[uart_tx_w % UART_TX_BUF_SIZE]</span>
<span class="n">uint64</span><span class="w"> </span><span class="n">uart_tx_r</span><span class="p">;</span><span class="w"> </span><span class="c1">// read next from uart_tx_buf[uart_tx_r % UART_TX_BUF_SIZE]</span>

<span class="kt">void</span>
<span class="nf">uartputc</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">panicked</span><span class="p">){</span>
<span class="w">    </span><span class="k">for</span><span class="p">(;;)</span>
<span class="w">      </span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">uart_tx_w</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">uart_tx_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">UART_TX_BUF_SIZE</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// buffer is full.</span>
<span class="w">      </span><span class="c1">// wait for uartstart() to open up space in the buffer.</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_r</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">uart_tx_buf</span><span class="p">[</span><span class="n">uart_tx_w</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">UART_TX_BUF_SIZE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="n">uart_tx_w</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">uartstart</span><span class="p">();</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uart_tx_lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>Each time the UART finishes sending a byte, it generates an interrupt</strong>. <code>uartintr</code> calls <code>uartstart</code>, which checks that the device really has finished sending, and hands the device the next buffered output character. Thus if a process writes multiple bytes to the console, typically the first byte will be sent by <code>uartputcâ€™s</code> call to <code>uartstart</code>, and the remaining buffered bytes will be sent by <code>uartstart</code> calls from <code>uartintr</code> as transmit complete interrupts arrive.</p>
<blockquote>
<p>ä¸‹é¢è¯´æ˜Žäº†ç”Ÿäº§è€…æ¶ˆè´¹è€…æ¨¡åž‹çš„é‡è¦æ€§</p>
</blockquote>
<p><u><strong>A general pattern to note is the decoupling of device activity from process activity via buffering and interrupts.</strong></u></p>
<p><u><strong>The console driver can process input even when no process is waiting to read it; a subsequent read will see the input. Similarly, processes can send output without having to wait for the device.</strong></u></p>
<p>This decoupling can increase performance by allowing processes to execute concurrently with device I/O, and is particularly important when the device is slow (as with the UART) or needs immediate attention (as with echoing typed characters). This idea is sometimes called I/O concurrency.</p>
<h3 id="53-concurrency-in-drivers">5.3 Concurrency in drivers<a class="headerlink" href="#53-concurrency-in-drivers" title="Permanent link">Â¶</a></h3>
<p>You may have noticed calls to acquire in <code>consoleread</code> and in <code>consoleintr</code>. These calls acquire a lock, which protects the console driverâ€™s data structures from concurrent access.</p>
<p>There are <strong>three concurrency dangers</strong> here:</p>
<ul>
<li>two processes on different CPUs might call <code>consoleread</code> at the same time;</li>
<li>the hardware might ask a CPU to deliver a console (really UART) interrupt while that CPU is already executing inside <code>consoleread</code>;</li>
<li>the hardware might deliver a console interrupt on a different CPU while <code>consoleread</code> is executing.</li>
</ul>
<p>Another way in which concurrency requires care in drivers is that <strong>one process may be waiting for input from a device, but the interrupt signaling arrival of the input may arrive when a different process (or no process at all) is running.</strong> Thus interrupt handlers are not allowed to think about the process or code that they have interrupted. For example, an interrupt handler cannot safely call <code>copyout</code> with the current processâ€™s page table. Interrupt handlers typically do relatively little work (e.g., just copy the input data to a buffer), and wake up top-half code to do the rest.</p>
<h3 id="54-timer-interrupts">5.4 Timer interrupts<a class="headerlink" href="#54-timer-interrupts" title="Permanent link">Â¶</a></h3>
<p>Xv6 uses timer interrupts to maintain its clock and to enable it to switch among compute-bound processes; the yield calls in usertrap and kerneltrap cause this switching. Timer interrupts come from clock hardware attached to each RISC-V CPU. Xv6 programs this clock hardware to interrupt each CPU periodically.</p>
<p><strong>RISC-V requires that timer interrupts be taken in machine mode, not supervisor mode.</strong> RISCV machine mode executes without paging, and with a separate set of control registers, so itâ€™s not practical to run ordinary xv6 kernel code in machine mode. <strong>As a result, xv6 handles timer interrupts completely separately from the trap mechanism laid out above.</strong></p>
<p><strong>Code executed in machine mode in <code>start.c</code>, before main,</strong> sets up to receive timer interrupts (kernel/start.c:57). Part of the job is to program the <strong>CLINT hardware (core-local <code>interruptor</code>) to generate an interrupt after a certain delay.</strong> Another part is to set up a <code>scratch area</code>, analogous to the <code>trapframe</code>, to help the timer interrupt handler save registers and the address of the CLINT registers. Finally, start sets <code>mtvec</code> to <code>timervec</code> and enables timer interrupts.</p>
<p><strong>A timer interrupt can occur at any point when user or kernel code is executing;</strong> thereâ€™s no way for the kernel to disable timer interrupts during critical operations. Thus the <u>timer interrupt handler must do its job in a way guaranteed not to disturb interrupted kernel code.</u> The basic strategy is for the handler to ask the RISC-V to raise a â€œsoftware interruptâ€ and immediately return. The RISC-V delivers software interrupts to the kernel with the ordinary trap mechanism, and allows the kernel to disable them. The code to handle the software interrupt generated by a timer interrupt can be seen in <code>devintr</code> (kernel/trap.c:204).</p>
<p>The machine-mode timer interrupt vector is <code>timervec</code> (kernel/kernelvec.S:93). It saves a few registers in the scratch area prepared by start, tells the CLINT when to generate the next timer interrupt, asks the RISC-V to raise a software interrupt, restores registers, and returns. Thereâ€™s no C code in the timer interrupt handler.</p>
<h3 id="55-real-world">5.5 Real world<a class="headerlink" href="#55-real-world" title="Permanent link">Â¶</a></h3>
<ul>
<li>DMA</li>
</ul>
<p>The UART driver retrieves data a byte at a time by reading the UART control registers; this pattern is called programmed I/O, since software is driving the data movement. Programmed I/O is simple, but too slow to be used at high data rates. Devices that need to move lots of data at high speed typically use <strong>direct memory access</strong> <strong>(DMA</strong>). <strong>DMA device hardware directly writes incoming data to RAM, and reads outgoing data from RAM.</strong> Modern disk and network devices use DMA. A driver for a DMA device would prepare data in RAM, and then use a single write to a control register to tell the device to process the prepared data.</p>
<ul>
<li>Polling</li>
</ul>
<p>Interrupts make sense when a device needs attention at unpredictable times, and not too often. But <strong>interrupts have high CPU overhead</strong>. Thus <strong>high speed devices, such networks and disk controllers, use tricks that <u>reduce the need for interrupts</u>.</strong></p>
<ul>
<li>One trick is to raise a single interrupt for a whole batch of incoming or outgoing requests.</li>
<li>Another trick is for the driver to <strong>disable interrupts entirely, and to check the device <u>periodically</u> to see if it needs attention</strong>. This technique is called <code>polling</code>. Polling makes sense if the device performs operations very quickly, but it wastes CPU time if the device is mostly idle. Some drivers dynamically switch between polling and interrupts depending on the current device load.</li>
</ul>
<h2 id="chapter6-locking">Chapter6. Locking<a class="headerlink" href="#chapter6-locking" title="Permanent link">Â¶</a></h2>
<p>Most kernels, including xv6, interleave the execution of multiple activities. One source of interleaving is multiprocessor hardware: computers with multiple CPUs executing independently, such as xv6â€™s RISC-V. These multiple CPUs share physical RAM, and xv6 exploits the sharing to maintain data structures that all CPUs read and write. <strong>This sharing raises the possibility of one CPU reading a data structure while another CPU is mid-way through updating it, or even multiple CPUs updating the same data simultaneously;</strong> without careful design such parallel access is likely to yield incorrect results or a broken data structure. Even on a uniprocessor, the kernel may switch the CPU among a number of threads, causing their execution to be interleaved. Finally, a device interrupt handler that modifies the same data as some interruptible code could damage the data if the interrupt occurs at just the wrong time. <strong>The word concurrency refers to situations in which multiple instruction streams are interleaved, due to multiprocessor parallelism, thread switching, or interrupts.</strong></p>
<p>Kernels are full of concurrently-accessed data. For example, two CPUs could simultaneously call <code>kalloc</code>, thereby concurrently popping from the head of the free list. Kernel designers like to allow for lots of concurrency, since it can yield increased performance though parallelism, and increased responsiveness. However, as a result kernel designers spend a lot of effort convincing themselves of correctness despite such concurrency. There are many ways to arrive at correct code, some easier to reason about than others. Strategies aimed at correctness under concurrency, and abstractions that support them, are called <strong>concurrency control techniques</strong>.</p>
<p>Xv6 uses a number of concurrency control techniques, depending on the situation; many more are possible. This chapter focuses on a widely used technique: <strong>the lock</strong>. A lock provides <strong>mutual exclusion, ensuring that only one CPU at a time can hold the lock</strong>. If the programmer associates a lock with each shared data item, and the code always holds the associated lock when using an item, then the item will be used by only one CPU at a time. In this situation, we say that the lock protects the data item. Although locks are an easy-to-understand concurrency control mechanism, <strong>the downside of locks is that they can kill performance, because they serialize concurrent operations.</strong></p>
<p>The rest of this chapter explains why xv6 needs locks, how xv6 implements them, and how it uses them.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220605000625203.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220605000625203" src="../../../../assets/Operating%20Systems.assets/image-20220605000625203.png"></a></p>
<h3 id="61-race-conditions">6.1 Race conditions<a class="headerlink" href="#61-race-conditions" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>2ä¸ªCPUåŒæ—¶åœ¨è¿›è¡Œå­è¿›ç¨‹çš„<code>kfree</code>, ç„¶è€Œkernelç»´æŠ¤çš„é“¾è¡¨åªæœ‰ä¸€ä¸ªï¼Œæ­¤æ—¶æ— æ³•å¹¶è¡Œ</p>
</blockquote>
<p>As an example of why we need locks, consider two processes calling wait on two different CPUs. wait frees the childâ€™s memory. Thus on each CPU, the kernel will call <code>kfree</code> to free the childrenâ€™s pages. The kernel allocator maintains a linked list: <code>kalloc()</code> (kernel/kalloc.c:69) pops a page of memory from a list of free pages, and <code>kfree()</code> (kernel/kalloc.c:47) pushes a page onto the free list. For best performance, we might hope that the <code>kfrees</code> of the two parent processes would execute in parallel without either having to wait for the other, but this would not be correct given xv6â€™s <code>kfree</code> implementation.</p>
<p><strong>Figure 6.1</strong> illustrates the setting in more detail: <strong>the linked list is in memory that is shared by the two CPUs</strong>, which manipulate the linked list using load and store instructions. <strong>(In reality, the processors have caches</strong>, but conceptually multiprocessor systems behave as if there were a single, shared memory.) If there were no concurrent requests, you might implement a list push operation as follows:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">;</span>

<span class="w">    </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="w">    </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="w">    </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/image-20220605223756692.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/image-20220605223756692.png" alt="image-20220605223756692" style="zoom: 80%;"></a></p>
<p>This implementation is correct if executed in isolation. However, the code is not correct if more than one copy executes concurrently. If two CPUs execute push at the same time, both might execute line 15 as shown in Fig 6.1, before either executes line 16, which results in an incorrect outcome as illustrated by Figure 6.2. There would then be two list elements with next set to the former value of list. When the two assignments to list happen at line 16, <strong>the second one will overwrite the first; the element involved in the first assignment will be lost.</strong></p>
<hr>
<p>The lost update at line 16 is an example of a <strong>race condition</strong>.</p>
<p>A race condition is a situation in which <strong><u>a memory location is accessed concurrently, and at least one access is a write</u></strong>. A race is often a sign of a bug, either a lost update (if the accesses are writes) or a read of an incompletely-updated data structure. <strong>The outcome of a race depends on the exact timing of the two CPUs involved and how their memory operations are ordered by the memory system, which can make race-induced errors difficult to reproduce and debug.</strong> For example, adding print statements while debugging push might change the timing of the execution enough to make the race disappear.</p>
<hr>
<p>The usual way to avoid races is to use a <strong>lock</strong>. Locks ensure <strong>mutual exclusion</strong>, so that <u>only one CPU at a time can execute the sensitive lines of push</u>; this makes the scenario above impossible. The correctly locked version of the above code adds just a few lines :</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="o">*</span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">lock</span><span class="w"> </span><span class="n">listlock</span><span class="p">;</span>

<span class="kt">void</span>
<span class="nf">push</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">element</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="w">    </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>

<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
<span class="w">    </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="w">    </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The sequence of instructions between acquire and release is often called a <strong>critical section</strong>. The lock is typically said to be protecting list.</p>
<hr>
<p>When we say that a lock protects data, we really mean that the lock protects some collection of <strong>invariants</strong> that apply to the data. I**nvariants are properties of data structures that are maintained across operations**. Typically, an operationâ€™s correct behavior depends on the invariants being true when the operation begins. The operation may temporarily violate the invariants but must reestablish them before finishing. For example, in the linked list case, the invariant is that list points at the first element in the list and that each elementâ€™s next field points at the next element. The implementation of push violates this invariant temporarily: in line 17, l points to the next list element, but list does not point at l yet (reestablished at line 18). <strong>The race condition we examined above happened because a second CPU executed code that depended on the list invariants while they were (temporarily) violated.</strong> Proper use of a lock ensures that only one CPU at a time can operate on the data structure in the critical section, so that no CPU will execute a data structure operation when the data structureâ€™s invariants do not hold.</p>
<p>You can think of a lock as</p>
<ul>
<li><strong>serializing concurrent critical sections so that they run one at a time</strong>, and thus preserve invariants (assuming the critical sections are correct in isolation). You can also think of critical sections guarded by the same lock as</li>
<li><strong>being atomic with respect to each other</strong>, so that each sees only the complete set of changes from earlier critical sections, and never sees partially-completed updates.</li>
</ul>
<hr>
<p>Although correct use of locks can make incorrect code correct, <strong>locks limit performance</strong>.</p>
<p>For example, if two processes call <code>kfree</code> concurrently, the locks will serialize the two calls, and <strong>we obtain no benefit from running them on different CPUs</strong>.</p>
<p>We say that <strong>multiple processes conflict if they want the same lock at the same time,</strong> or that the lock experiences <strong><code>contention</code></strong>.</p>
<p><strong>A major challenge in kernel design is to avoid lock contention</strong>. Xv6 does little of that, but sophisticated kernels organize data structures and algorithms specifically to avoid lock contention. In the list example, a kernel may maintain a free list per CPU and only touch another CPUâ€™s free list if the CPUâ€™s list is empty and it must steal memory from another CPU. Other use cases may require more complicated designs.</p>
<p>The placement of locks is also important for performance. For example, it would be correct to move acquire earlier in push: it is fine to move the call to acquire up to before line 13. This may reduce performance because then the calls to malloc are also serialized. The section â€œUsing locksâ€ below provides some guidelines for where to insert acquire and release invocations.</p>
<h3 id="62-code-locks">6.2 Code: Locks<a class="headerlink" href="#62-code-locks" title="Permanent link">Â¶</a></h3>
<p>Xv6 has two types of locks:</p>
<p><strong><code>spinlocks</code></strong> and <strong><code>sleep-locks</code></strong></p>
<hr>
<h4 id="spinlocks"><code>Spinlocks</code><a class="headerlink" href="#spinlocks" title="Permanent link">Â¶</a></h4>
<p>Weâ€™ll start with spinlocks. Xv6 represents a spinlock as a struct spinlock (kernel/spinlock.h:2). The important field in the structure is locked, a word that is zero when the lock is available and non-zero when it is held. Logically, xv6 should acquire a lock by executing code like</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Mutual exclusion lock.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">locked</span><span class="p">;</span><span class="w">       </span><span class="c1">// Is the lock held?</span>

<span class="w">  </span><span class="c1">// For debugging:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">        </span><span class="c1">// Name of lock.</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">cpu</span><span class="p">;</span><span class="w">   </span><span class="c1">// The cpu holding the lock.</span>
<span class="p">}</span>

<span class="mi">21</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">22</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span><span class="w"> </span><span class="c1">// does not work!</span>
<span class="mi">23</span><span class="w"> </span><span class="p">{</span>
<span class="mi">24</span><span class="w">      </span><span class="k">for</span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span>
<span class="mi">25</span><span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="mi">26</span><span class="w">              </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">27</span><span class="w">               </span><span class="k">break</span><span class="p">;</span>
<span class="mi">28</span><span class="w">           </span><span class="p">}</span>
<span class="mi">29</span><span class="w">      </span><span class="p">}</span>
<span class="mi">30</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>Unfortunately, this implementation does not guarantee mutual exclusion on a multiprocessor. <strong>It could happen that two CPUs simultaneously reach line 25, see that <code>lk-&gt;locked</code> is zero, and then both grab the lock by executing line 26</strong>. At this point, two different CPUs hold the lock, which violates the mutual exclusion property. What we need is a way to make lines 25 and 26 execute as an atomic (i.e., indivisible) step.</p>
<hr>
<p>Because locks are widely used, <strong>multi-core processors usually provide instructions that implement an atomic version</strong> of lines 25 and 26. On the RISC-V this instruction is <code>amoswap r, a</code>.</p>
<p><code>amoswap</code> reads the value at the memory address a, writes the contents of register r to that address, and puts the value it read into r. That is, <strong>it swaps the contents of the register and the memory address</strong>. It performs this sequence <strong>atomically</strong>, using <strong>special hardware</strong> to prevent any other CPU from using the memory address between the read and the write.</p>
<h4 id="acquire">Acquire<a class="headerlink" href="#acquire" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>é”ä¾é çš„æ˜¯ç¡¬ä»¶çš„æŠ€æœ¯ï¼Œç¡¬ä»¶ä½¿å¾—æŒ‡ä»¤å¯ä»¥åŽŸå­çš„æ‰§è¡Œã€‚ä¸Šé”çš„è¿‡ç¨‹å°±æ˜¯ç”¨åŽŸå­æŒ‡ä»¤<code>amoswap</code>ä¸æ–­åœ°ç”¨1å’ŒæŸä¸ªå¯„å­˜å™¨ä¸­çš„å€¼è¿›è¡Œäº¤æ¢ï¼Œè‹¥äº¤æ¢åŽä¸º0ï¼Œåˆ™è¯æ˜Žå…¶ä»–CPUå·²ç»å¼€äº†é”ï¼Œå½“å‰CPUä¹ŸæŠŠ1æ”¾è¿›äº†è¯¥å¯„å­˜å™¨ä¸­ï¼›è‹¥äº¤æ¢åŽä¸º1ï¼Œè¯´æ˜Žæœ‰å…¶ä»–CPUè¿˜åœ¨å ç”¨ï¼Œä½†æˆ‘ä»¬æ˜¯ç”¨1æ¢äº†1ï¼Œæ‰€ä»¥å¹¶æ²¡æœ‰å¯¹ä¸Šé”æœ¬èº«é€ æˆå½±å“ã€‚</p>
</blockquote>
<p>Xv6â€™s acquire (kernel/spinlock.c:22) uses the portable C library call <code>__sync_lock_test_and_set</code>, which boils down to(å½’ç»“ä¸º) the <code>amoswap</code> instruction; the return value is the old (swapped) contents of <code>lk-&gt;locked</code>. The acquire function wraps the swap in a loop, retrying (spinning) until it has acquired the lock. Each iteration swaps one into <code>lk-&gt;locked</code> and checks the previous value; if the previous value is zero, then weâ€™ve acquired the lock, and the swap will have set <code>lk-&gt;locked</code> to one. If the previous value is one, then some other CPU holds the lock, and the fact that we atomically swapped one into <code>lk-&gt;locked</code> didnâ€™t change its value.</p>
<div class="highlight"><pre><span></span><code><span class="o">/</span><span class="w"> </span><span class="n">Acquire</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">lock</span><span class="p">.</span>
<span class="c1">// Loops (spins) until the lock is acquired.</span>
<span class="kt">void</span>
<span class="n">acquire</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">push_off</span><span class="p">();</span><span class="w"> </span><span class="c1">// disable interrupts to avoid deadlock.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">holding</span><span class="p">(</span><span class="n">lk</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"acquire"</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// On RISC-V, sync_lock_test_and_set turns into an atomic swap:</span>
<span class="w">  </span><span class="c1">//   a5 = 1</span>
<span class="w">  </span><span class="c1">//   s1 = &amp;lk-&gt;locked</span>
<span class="w">  </span><span class="c1">//   amoswap.w.aq a5, a5, (s1)</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Tell the C compiler and the processor to not move loads or stores</span>
<span class="w">  </span><span class="c1">// past this point, to ensure that the critical section's memory</span>
<span class="w">  </span><span class="c1">// references happen strictly after the lock is acquired.</span>
<span class="w">  </span><span class="c1">// On RISC-V, this emits a fence instruction.</span>
<span class="w">  </span><span class="n">__sync_synchronize</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Record info about lock acquisition for holding() and debugging.</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>Once the lock is acquired, acquire records, for debugging, the CPU that acquired the lock. The <code>lk-&gt;cpu</code> field is protected by the lock and must only be changed while holding the lock.</p>
<h4 id="release">Release<a class="headerlink" href="#release" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>releaseå°±æ˜¯acquireçš„åé¢äº†ï¼Œå¥¹å°±æ˜¯ç”¨0åŽ»æ¢1ã€‚</p>
</blockquote>
<p>The function release (kernel/spinlock.c:47) is the opposite of acquire: it clears the <code>lk-&gt;cpu</code> field and then releases the lock.</p>
<p>Conceptually, the release just requires assigning zero to <code>lk-&gt;locked</code>. The C standard allows compilers to implement an assignment with multiple store instructions, so a <strong>C assignment might be non-atomic with respect to concurrent code</strong>. Instead, release uses the C library function <code>__sync_lock_release</code> that performs an atomic assignment. This function also boils down to a RISC-V <code>amoswap</code> instruction.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Release the lock.</span>
<span class="kt">void</span>
<span class="nf">release</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holding</span><span class="p">(</span><span class="n">lk</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"release"</span><span class="p">);</span>

<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">cpu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Tell the C compiler and the CPU to not move loads or stores</span>
<span class="w">  </span><span class="c1">// past this point, to ensure that all the stores in the critical</span>
<span class="w">  </span><span class="c1">// section are visible to other CPUs before the lock is released,</span>
<span class="w">  </span><span class="c1">// and that loads in the critical section occur strictly before</span>
<span class="w">  </span><span class="c1">// the lock is released.</span>
<span class="w">  </span><span class="c1">// On RISC-V, this emits a fence instruction.</span>
<span class="w">  </span><span class="n">__sync_synchronize</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Release the lock, equivalent to lk-&gt;locked = 0.</span>
<span class="w">  </span><span class="c1">// This code doesn't use a C assignment, since the C standard</span>
<span class="w">  </span><span class="c1">// implies that an assignment might be implemented with</span>
<span class="w">  </span><span class="c1">// multiple store instructions.</span>
<span class="w">  </span><span class="c1">// On RISC-V, sync_lock_release turns into an atomic swap:</span>
<span class="w">  </span><span class="c1">//   s1 = &amp;lk-&gt;locked</span>
<span class="w">  </span><span class="c1">//   amoswap.w zero, zero, (s1)</span>
<span class="w">  </span><span class="n">__sync_lock_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">);</span>

<span class="w">  </span><span class="n">pop_off</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="63-code-using-locks">6.3 Code: Using locks<a class="headerlink" href="#63-code-using-locks" title="Permanent link">Â¶</a></h3>
<p>Xv6 uses locks in many places to avoid race conditions. As described above, <code>kalloc</code> (kernel/kalloc.c:69) and <code>kfree</code> (kernel/kalloc.c:47) form a good example. Try Exercises 1 and 2 to see what happens if those functions omit the locks. Youâ€™ll likely find that itâ€™s difficult to trigger incorrect behavior, suggesting that itâ€™s hard to reliably test whether code is free from locking errors and races. It is not unlikely that xv6 has some races.</p>
<hr>
<p>A hard part about using locks is deciding <strong>how many locks to use</strong> and <strong>which data and invariants each lock should protect</strong>.</p>
<p>There are a few basic principles.</p>
<ul>
<li>First, any time a variable can be written by one CPU at the same time that another CPU can read or write it, a lock should be used to keep the two operations from overlapping.</li>
<li>Second, remember that locks protect invariants: if an invariant involves multiple memory locations, typically all of them need to be protected by a single lock to ensure the invariant is maintained.</li>
</ul>
<p>The rules above say when locks are necessary but say nothing about when locks are unnecessary, and it is important for efficiency not to lock too much, because locks reduce parallelism. If parallelism isnâ€™t important, then one could arrange to have only a single thread and not worry about locks. A simple kernel can do this on a multiprocessor by having a single lock that must be acquired on entering the kernel and released on exiting the kernel (though system calls such as pipe reads or wait would pose a problem). Many uniprocessor operating systems have been converted to run on multiprocessors using this approach, sometimes called a â€œbig kernel lock,â€ but the approach sacrifices parallelism: only one CPU can execute in the kernel at a time. If the kernel does any heavy computation, it would be more efficient to use a larger set of more fine-grained locks, so that the kernel could execute on multiple CPUs simultaneously.</p>
<blockquote>
<p>Xv6åœ¨ç‰©ç†å†…å­˜ç®¡ç†ä¸Šç”¨é”æ˜¯å¾ˆç²—ç²’åº¦çš„ï¼Œä¹Ÿå°±æ˜¯åªæœ‰ä¸€ä¸ªCPUå¯ä»¥åŽ»è¯»å†™ç‰©ç†å†…å­˜çš„é“¾è¡¨ã€‚å…¶ä»–éœ€è¦ç‰©ç†å†…å­˜æ“ä½œCPUå°±åªèƒ½åœ¨é”çš„ä»£ç ä¸­ä¸€ç›´å¾ªçŽ¯ã€‚</p>
</blockquote>
<p>As an example of <strong>coarse-grained(ç²—ç²’åº¦) locking</strong>, xv6â€™s <code>kalloc.c</code> allocator has a single free list protected by a single lock. If multiple processes on different CPUs try to allocate pages at the same time, each will have to wait for its turn by spinning in acquire. Spinning reduces performance, since itâ€™s not useful work. If contention for the lock wasted a significant fraction of CPU time, <strong>perhaps performance could be improved by changing the allocator design to have multiple free lists, each with its own lock, to allow truly parallel allocation.</strong></p>
<p>As an example of <strong>fine-grained locking</strong>, <strong>xv6 has a separate lock for each file</strong>, so that processes that manipulate different files can often proceed without waiting for each otherâ€™s locks. The file locking scheme could be made even more fine-grained if one wanted to allow processes to simultaneously write different areas of the same file. Ultimately lock granularity decisions need to be driven by performance measurements as well as complexity considerations.</p>
<h3 id="64-deadlock-and-lock-ordering">6.4 Deadlock and lock ordering<a class="headerlink" href="#64-deadlock-and-lock-ordering" title="Permanent link">Â¶</a></h3>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220605234049019.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220605234049019" src="../../../../assets/Operating%20Systems.assets/image-20220605234049019.png"></a></p>
<p>If a code path through the kernel must hold several locks at the same time, it is important that all code paths acquire those locks in the same order. If they donâ€™t, there is a risk of deadlock.</p>
<blockquote>
<p>é”çš„é¡ºåºä¸Žæ­»é”çš„ä¾‹å­</p>
<p>çº¿ç¨‹T1æŒ‰é¡ºåºè¦ä¸¤æŠŠé”Aï¼ŒBï¼›çº¿ç¨‹T2æŒ‰é¡ºåºè¦ä¸¤æŠŠé”Bï¼ŒAã€‚</p>
<p>æŸç§æƒ…å½¢ä¸‹ï¼ŒT1æ‹¿åˆ°äº†Açš„é”ï¼ŒT2æ‹¿åˆ°äº†Bçš„é”ã€‚é‚£ä¹ˆæŽ¥ä¸‹æ¥ï¼ŒT1å°±ä¼šç­‰å¾…é”Bè¢«releaseï¼ŒT2å°±ä¼šç­‰å¾…é”Aè¢«releaseã€‚è¿™æ ·çš„æƒ…å†µä¸‹ï¼ŒT1æ‹¿ä¸åˆ°é”Bæ‰€ä»¥ä¹Ÿå°±ä¸å¯èƒ½æ‰§è¡Œåˆ°é‡Šæ”¾Açš„ä»£ç ã€‚T2ä¹Ÿæ˜¯åŒç†ã€‚</p>
<p>è§£å†³çš„æ–¹æ¡ˆå°±æ˜¯è®©æ‰€æœ‰pathä½¿ç”¨é”çš„é¡ºåºä¸€è‡´</p>
</blockquote>
<p>Letâ€™s say two code paths in xv6 need locks A and B, but code path 1 acquires locks in the order A then B, and the other path acquires them in the order B then A. Suppose thread T1 executes code path 1 and acquires lock A, and thread T2 executes code path 2 and acquires lock B. Next T1 will try to acquire lock B, and T2 will try to acquire lock A. Both acquires will block indefinitely, because in both cases the other thread holds the needed lock, and wonâ€™t release it until its acquire returns. <strong>To avoid such deadlocks, all code paths must acquire locks in the same order.</strong> The need for a global lock acquisition order means that locks are effectively part of each functionâ€™s specification: <strong>callers must invoke functions in a way that causes locks to be acquired in the agreed-on order.</strong></p>
<hr>
<p><strong>Xv6 has many lock-order chains</strong> of length two involving per-process locks (the lock in each struct proc) due to the way that sleep works (see Chapter 7).</p>
<blockquote>
<p><code>con.lock</code> â†’ <code>p.lock</code></p>
</blockquote>
<p>For example, <code>consoleintr</code> (kernel/console.c:138) is the interrupt routine which handles typed characters. When a newline arrives, any process that is waiting for console input should be woken up. To do this,<code>consoleintr</code> holds <code>cons.lock</code> while calling wakeup, which acquires the waiting processâ€™s lock in order to wake it up. In consequence, the global deadlock-avoiding lock order includes the rule that <code>cons.lock</code> must be acquired before any process lock.</p>
<blockquote>
<p><code>ip.lock</code> â†’ <code>buf.lock</code> â†’<code>vdisk_lock</code>â†’<code>p-&gt;lock</code></p>
</blockquote>
<p>The file-system code contains xv6â€™s longest lock chains. For example, creating a file requires simultaneously holding a lock on the directory, a lock on the new fileâ€™s <code>inode</code>, a lock on a disk block buffer, the disk driverâ€™s <code>vdisk_lock</code>, and the calling processâ€™s <code>p-&gt;lock</code>. To avoid deadlock, file-system code always acquires locks in the order mentioned in the previous sentence.</p>
<hr>
<p>Honoring a global deadlock-avoiding order can be surprisingly difficult.</p>
<p>Sometimes the <strong>lock order conflicts with logical program structure</strong>, e.g., perhaps code module M1 calls module M2, but the lock order requires that a lock in M2 be acquired before a lock in M1. Sometimes <strong>the identities of locks arenâ€™t known in advance</strong>, perhaps because one lock must be held in order to discover the identity of the lock to be acquired next. This kind of situation arises in the file system as it looks up successive components in a path name, and in the code for wait and exit as they search the table of processes looking for child processes. Finally, the danger of deadlock is often a constraint on how fine-grained one can make a locking scheme, since <strong>more locks often means more opportunity for deadlock</strong>. The need to avoid deadlock is often a major factor in kernel implementation.</p>
<h3 id="65-locks-and-interrupt-handlers">6.5 Locks and interrupt handlers<a class="headerlink" href="#65-locks-and-interrupt-handlers" title="Permanent link">Â¶</a></h3>
<p>Some xv6 spinlocks protect data that is used by both threads and interrupt handlers. For example, the <code>clockintr</code> timer interrupt handler might increment ticks (kernel/trap.c:163) at about the same time that a kernel thread reads ticks in sys_sleep (kernel/sysproc.c:64). The lock <code>tickslock</code> serializes the two accesses.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">clockintr</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="w">  </span><span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">);</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">uint64</span>
<span class="nf">sys_sleep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">ticks0</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="w">  </span><span class="n">ticks0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ticks</span><span class="p">;</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">ticks</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ticks0</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tickslock</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>The <strong>interaction of spinlocks and interrupts raises a potential danger</strong>. Suppose sys_sleep holds <code>tickslock</code>, and its CPU is interrupted by a timer interrupt. <code>clockintr</code> would try to acquire <code>tickslock</code>, see it was held, and wait for it to be released. In this situation, <code>tickslock</code> will never be released: only sys_sleep can release it, but sys_sleep will not continue running until <code>clockintr</code> returns. So the CPU will deadlock, and any code that needs either lock will also freeze.</p>
<blockquote>
<p>è¿™é‡Œæè¿°äº†ä¸­æ–­å¯èƒ½å¸¦æ¥çš„æ­»é”é—®é¢˜ï¼Œä¸­æ–­å¯èƒ½ä¼šå¯¼è‡´é¢„è®¾çš„é¡ºåºè¢«æ‰“ä¹±ã€‚</p>
</blockquote>
<p>To avoid this situation, <strong>if a spinlock is used by an interrupt handler, a CPU must never hold that lock with interrupts enabled</strong>. Xv6 is more conservative: when a CPU acquires any lock, xv6 always disables interrupts on that CPU. Interrupts may still occur on other CPUs, so an interruptâ€™s acquire can wait for a thread to release a spinlock; just not on the same CPU.</p>
<hr>
<p><strong>xv6 re-enables interrupts when a CPU holds no spinlocks</strong>;</p>
<p>it must do a little book-keeping to cope with nested critical sections. acquire calls <code>push_off</code> (kernel/spinlock.c:89) and release calls <code>pop_off</code> (kernel/spinlock.c:100) to <strong>track the nesting level of locks on the current CPU</strong>. When that count reaches zero, <code>pop_off</code> restores the interrupt enable state that existed at the start of the outermost critical section. The <code>intr_off</code>and <code>intr_on</code> functions execute RISC-V instructions to disable and enable interrupts, respectively.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// push_off/pop_off are like intr_off()/intr_on() except that they are matched:</span>
<span class="c1">// it takes two pop_off()s to undo two push_off()s.  Also, if interrupts</span>
<span class="c1">// are initially off, then push_off, pop_off leaves them off.</span>

<span class="kt">void</span>
<span class="nf">push_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intr_get</span><span class="p">();</span>

<span class="w">  </span><span class="n">intr_off</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old</span><span class="p">;</span>
<span class="w">  </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">pop_off</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">intr_get</span><span class="p">())</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"pop_off - interruptible"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"pop_off"</span><span class="p">);</span>
<span class="w">  </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">intena</span><span class="p">)</span>
<span class="w">    </span><span class="n">intr_on</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>It is important that acquire call push_off strictly before setting <code>lk-&gt;locked</code> (kernel/spinlock.c:28). If the two were reversed, there would be a brief window when the lock was held with interrupts enabled, and an unfortunately timed interrupt would deadlock the system. Similarly, it is important that release call <code>pop_off</code> only after releasing the lock (kernel/spinlock.c:66).</p>
<h3 id="66-instruction-and-memory-ordering">6.6 Instruction and memory ordering<a class="headerlink" href="#66-instruction-and-memory-ordering" title="Permanent link">Â¶</a></h3>
<p>It is natural to think of programs executing in the order in which source code statements appear. <strong>Many compilers and CPUs, however, execute code out of order to achieve higher performance.</strong> If an instruction takes many cycles to complete, a CPU may issue the instruction early so that it can overlap with other instructions and avoid CPU stalls(åœé¡¿). For example, a CPU may notice that in a serial sequence of instructions A and B are not dependent on each other. The CPU may start instruction B first, either because its inputs are ready before Aâ€™s inputs, or in order to overlap execution of A and B. A compiler may perform a similar re-ordering by emitting instructions for one statement before the instructions for a statement that precedes it in the source.</p>
<blockquote>
<p>CPUå’ŒCompilerä¼šä¸ºäº†ç¨‹åºçš„æœ‰æ›´é«˜çš„æ€§èƒ½æ‰“ä¹±æ‰§è¡Œçš„é¡ºåºï¼Œè¿™å¯¹çº¿æ€§æ‰§è¡Œçš„ä»£ç åŠŸèƒ½æ²¡æœ‰å½±å“ï¼Œä½†å¯¹äºŽå¹¶å‘çš„ä»£ç å°±å¸¦æ¥äº†é—®é¢˜ï¼Œ</p>
</blockquote>
<p>Compilers and CPUs follow rules when they re-order to ensure that they donâ€™t change the results of correctly-written serial code. However, the rules do allow re-ordering that changes the results of concurrent code, and can easily lead to incorrect behavior on multiprocessors . <u>The CPUâ€™s ordering rules are called the <strong><code>memory model</code></strong>.</u></p>
<p>For example, in this code for push, it would be a disaster if the compiler or CPU moved the store corresponding to line 4 to a point after the release on line 6:</p>
<div class="highlight"><pre><span></span><code><span class="mi">1</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="w"> </span><span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="mi">2</span><span class="w"> </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data</span><span class="p">;</span>
<span class="mi">3</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
<span class="mi">4</span><span class="w"> </span><span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">list</span><span class="p">;</span>
<span class="mi">5</span><span class="w"> </span><span class="n">list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="mi">6</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">listlock</span><span class="p">);</span>
</code></pre></div>
<p>If such a re-ordering occurred, there would be a window during which another CPU could acquire the lock and observe the updated list, but see an uninitialized list-&gt;next.</p>
<p><strong>To tell the hardware and compiler not to perform such re-orderings</strong>, xv6 uses <strong><code>__sync_synchronize()</code></strong> in both acquire (kernel/spinlock.c:22) and release (kernel/spinlock.c:47).<code>__sync_synchronize()</code> is a <strong>memory barrier</strong>: it tells the compiler and CPU to not reorder loads or stores across the barrier. The barriers in xv6â€™s acquire and release force order in almost all cases where it matters, since xv6 uses locks around accesses to shared data. Chapter 9 discusses a few exceptions.</p>
<h3 id="67-sleep-locks">6.7 Sleep locks<a class="headerlink" href="#67-sleep-locks" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>é”å¸¦æ¥é—®é¢˜çš„æƒ…å†µä¹‹ä¸€ï¼šå‘ç£ç›˜è¯»å†™æ–‡ä»¶æ—¶ï¼Œå› ä¸ºé”çš„åŽŸå› ï¼Œå…¶ä»–çš„è¿›ç¨‹ä¹Ÿæ— æ³•ä½¿ç”¨CPUï¼Œåªèƒ½ç­‰å¾…CPUæ‰§è¡Œåˆ°ç£ç›˜è¿”å›žæ¶ˆæ¯å¹¶è§£å¼€é”ï¼Œä½†ç£ç›˜çš„è¯»å†™æ˜¯éžå¸¸æ…¢çš„ã€‚æˆ‘ä»¬å…¶å®žå¯ä»¥åœ¨å½“å‰è¿›ç¨‹ç­‰å¾…I/Oæ“ä½œçš„ç©ºé—²æ—¶é—´ï¼ŒæŠŠCPUè®©ç»™å…¶ä»–çš„è¿›ç¨‹ã€‚</p>
<p>ä½†æ˜¯åœ¨æ‹¥æœ‰é”çš„æ—¶å€™åˆ‡æ¢è¿›ç¨‹æ˜¯ä¸åˆæ³•çš„ï¼Œ</p>
<p>è¿™é‡Œçš„ä¸åˆæ³•æ²¡æœ‰å¤ªæ˜Žç™½ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ä¹‹åŽè¡¥å……</p>
<p>ç¬¬ä¸ƒç« ä¼šæ·±å…¥è¯´æ˜Ž</p>
</blockquote>
<p>Sometimes xv6 needs to hold a lock for a long time. For example, the file system (Chapter 8) keeps a file locked while reading and writing its content on the disk, and these disk operations can take tens of milliseconds. Holding a spinlock that long would lead to waste if another process wanted to acquire it, since the acquiring process would waste CPU for a long time while spinning. Another drawback of spinlocks is that <strong>a process cannot yield the CPU while retaining a spinlock</strong>; <strong>weâ€™d like to do this so that other processes can use the CPU while the process with the lock waits for the disk.</strong> Yielding while holding a spinlock is illegal because it might lead to deadlock if a second thread then tried to acquire the spinlock; since acquire doesnâ€™t yield the CPU, the second threadâ€™s spinning might prevent the first thread from running and releasing the lock. Yielding while holding a lock would also violate the requirement that interrupts must be off while a spinlock is held. <strong>Thus weâ€™d like a type of lock that yields the CPU while waiting to acquire, and allows yields (and interrupts) while the lock is held.</strong></p>
<p>Xv6 provides such locks in the form of <strong>sleep-locks</strong>. <code>acquiresleep</code> (kernel/sleeplock.c:22) yields the CPU while waiting, using techniques that will be explained in Chapter 7. At a high level, a sleep-lock has a locked field that is protected by a spinlock, and <code>acquiresleep</code> â€™s call to sleep atomically yields the CPU and releases the spinlock. The result is that other threads can execute while <code>acquiresleep</code> waits.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">acquiresleep</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>Because sleep-locks leave interrupts enabled, they cannot be used in interrupt handlers. Because <code>acquiresleep</code> may yield the CPU, sleep-locks cannot be used inside spinlock critical sections (though spinlocks can be used inside sleep-lock critical sections). <strong>Spin-locks are best suited to short critical sections, since waiting for them wastes CPU time; sleep-locks work well for lengthy operations.</strong></p>
<h2 id="chapter-7-scheduling">Chapter 7 Scheduling<a class="headerlink" href="#chapter-7-scheduling" title="Permanent link">Â¶</a></h2>
<p>Any operating system is likely to run with more processes than the computer has CPUs, so a plan is needed to time-share the CPUs among the processes. Ideally the sharing would be transparent to user processes. A common approach is to provide each process with the illusion that it has its own virtual CPU by multiplexing the processes onto the hardware CPUs. This chapter explains how xv6 achieves this multiplexing.</p>
<h3 id="71-multiplexing">7.1 Multiplexing<a class="headerlink" href="#71-multiplexing" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>xv6åœ¨ä¸¤ç§æƒ…å†µä¸‹å®žçŽ°äº†å¯¹CPUçš„å¤ç”¨</p>
<ol>
<li>sleepå’Œwakeupæœºåˆ¶</li>
<li>timeræ—¶é—´ç‰‡æœºåˆ¶</li>
</ol>
<p>å…³äºŽxv6çš„çº¿ç¨‹é—®é¢˜</p>
<p>xv6å¹¶æ²¡æœ‰å®žçŽ°ç”¨æˆ·çº§åˆ«çš„å¤šçº¿ç¨‹ï¼Œxv6çš„æ¯ä¸ªprocesså¯ä»¥è¢«çœ‹åšæœ‰ä¸¤ä¸ªçº¿ç¨‹ï¼Œä¸€ä¸ªæ˜¯å†…æ ¸çº¿ç¨‹ï¼Œå¦ä¸€ä¸ªæ˜¯ç”¨æˆ·çº¿ç¨‹ã€‚çº¿ç¨‹é—´çš„contextåˆ‡æ¢ä¹Ÿåªæ˜¯é’ˆå¯¹kernel threadã€‚</p>
</blockquote>
<p>Xv6 <strong>multiplexes by switching each CPU</strong> from one process to another in <strong>two situations.</strong></p>
<ul>
<li>
<p>First, <strong>xv6â€™s sleep and wakeup mechanism</strong> switches when a process <u>waits for device or pipe I/O to complete</u>, or <u>waits for a child to exit</u>, or <u>waits in the sleep system call.</u></p>
</li>
<li>
<p>Second, <strong>xv6 periodically forces a switch to cope with processes that compute for long periods without sleeping</strong>. This multiplexing creates the illusion that each process has its own CPU, just as xv6 uses the memory allocator and hardware page tables to create the illusion that each process has its own memory.</p>
</li>
</ul>
<hr>
<p>Implementing <strong>multiplexing</strong> poses a few <strong>challenges</strong>.</p>
<ul>
<li>First, <strong>how to switch</strong> from one process to another? Although the idea of context switching is simple, the implementation is some of the most opaque code in xv6.</li>
<li>Second, how to force switches in a way that is transparent to user processes? Xv6 uses the standard technique of driving context switches with timer interrupts.</li>
<li>Third, many CPUs may be <strong>switching</strong> among processes <strong>concurrently</strong>, and <strong>a locking plan</strong> is necessary to avoid races.</li>
<li>Fourth, a <strong>processâ€™s memory and other resources must be freed when the process exits</strong>, <strong>but it cannot do all of this itself because (for example) it canâ€™t free its own kernel stack while still using it.</strong></li>
<li>Fifth, <strong>each core</strong> of a multi-core machine <strong>must remember which process it is executing</strong> so that system calls affect the correct processâ€™s kernel state.</li>
<li>Finally, <strong>sleep and wakeup</strong> allow a process to give up the CPU and sleep waiting for an event, and allows another process to wake the first process up. Care is needed to <strong>avoid races that result in the loss of wakeup notifications</strong>. Xv6 tries to solve these problems as simply as possible, but nevertheless the resulting code is tricky.</li>
</ul>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220610234710788.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220610234710788" src="../../../../assets/Operating%20Systems.assets/image-20220610234710788.png"></a></p>
<h3 id="72-code-context-switching">7.2 Code: Context switching<a class="headerlink" href="#72-code-context-switching" title="Permanent link">Â¶</a></h3>
<p>Figure 7.1 outlines the <strong>steps involved in switching from one user process to another</strong>:</p>
<blockquote>
<p>è¿™é‡Œä»¥timerä¸­æ–­æœºåˆ¶è§¦å‘schedulingä¸ºä¾‹</p>
<ol>
<li><code>è¿›ç¨‹A</code>æ”¶åˆ°æ—¶é—´ä¸­æ–­ï¼Œä»Žè€Œè¿›å…¥è¯¥è¿›ç¨‹çš„kernelçº¿ç¨‹</li>
<li><code>è¿›ç¨‹Açš„å†…æ ¸çº¿ç¨‹</code>ä¿å­˜å½“å‰çš„å¯„å­˜å™¨å€¼åˆ°p-&gt;context</li>
<li><code>è¿›ç¨‹Açš„å†…æ ¸çº¿ç¨‹</code>å°†å¯„å­˜å™¨æ¢å¤åˆ°CPUçš„schedulerçº¿ç¨‹åˆ‡æ¢å‰çš„çŠ¶æ€</li>
<li><code>CPUçš„schedulerçº¿ç¨‹</code>å¯»æ‰¾åˆ°ä¸‹ä¸€ä¸ª<code>RUNNABLE</code>è¿›ç¨‹Bï¼Œæ‰¾åˆ°åŽå°†å½“å‰å¯„å­˜å™¨ä¸­çš„å€¼ä¿å­˜åˆ°<code>cpu-&gt;context</code>ï¼Œ å°†å¯„å­˜å™¨ä¸­çš„å€¼æ¢å¤ä¸ºè¿›ç¨‹Bä¸­ä¿å­˜çš„<code>p-&gt;context</code></li>
<li><code>è¿›ç¨‹B</code>ä¸€è·¯returnå›žåˆ°è¿›ç¨‹Bçš„user spaceç„¶åŽç»§ç»­æ‰§è¡Œ<code>è¿›ç¨‹Bçš„ç”¨æˆ·çº¿ç¨‹</code></li>
</ol>
</blockquote>
<ul>
<li>
<p>a user-kernel transition (system call or interrupt) to the old processâ€™s kernel thread,</p>
</li>
<li>
<p>a context switch to the current CPUâ€™s scheduler thread,</p>
</li>
<li>
<p>a context switch to a new processâ€™s kernel thread, and</p>
</li>
<li>
<p>a trap return to the user-level process.</p>
</li>
</ul>
<blockquote>
<p><strong>æ¯ä¸ªCPUéƒ½æœ‰ä¸€ä¸ªscheduler threadï¼Œä»–æœ‰ç€è‡ªå·±ç‹¬ç«‹çš„æ ˆå’Œä¸€äº›ç›¸åº”çš„å¯„å­˜å™¨å€¼</strong>ã€‚xv6çš„è¿›ç¨‹åˆ‡æ¢æ˜¯é€šè¿‡CPUè°ƒåº¦çº¿ç¨‹å®Œæˆçš„ï¼Œä¹Ÿå°±æ˜¯è¯´</p>
<p>process A -&gt; scheduler -&gt; process B</p>
<p>æ¯ä¸ªscheduler threadæ˜¯æ‹¥æœ‰è‡ªå·±çš„ç‹¬ç«‹æ ˆçš„ï¼Œè¿™äº›æ ˆåœ¨<code>start.c</code>ä¸­è¢«è®¾ç½®ã€‚è¿™æ ·è®¾è®¡çš„åŽŸå› è¦é€šè¿‡ä»£ç ç†è§£ã€‚</p>
</blockquote>
<p>The xv6 scheduler has a dedicated thread (saved registers and stack) per CPU because it is not safe for the scheduler execute on the old processâ€™s kernel stack: some other core might wake the process up and run it, and it would be a disaster to use the same stack on two different cores. In this section weâ€™ll examine the mechanics of switching between a kernel thread and a scheduler thread.</p>
<hr>
<blockquote>
<p><code>switch contextï¼ˆä¸Šä¸‹æ–‡åˆ‡æ¢ï¼‰</code>è¿™ä¸ªæœ¯è¯­ä¸€èˆ¬ç”¨äºŽå†…æ ¸å‘ç”Ÿçš„çº¿ç¨‹è°ƒåº¦ï¼Œè¿™é‡Œè¿™æ ·è¯´æ˜Žæ˜¯å› ä¸ºuser trapè¿›å…¥å†…æ ¸å‰å°†ä¸»è¦çš„å¯„å­˜å™¨ä¿å­˜åˆ°<code>trapframe</code>ä¸­çš„è¡Œä¸ºä¹Ÿå¯ä»¥è¢«çœ‹ä½œæ˜¯ä¸€ç§contextçš„åˆ‡æ¢ã€‚</p>
<p>çº¿ç¨‹è°ƒåº¦çš„æ ¸å¿ƒå‡½æ•°å°±æ˜¯<code>swtch()</code>äº†ï¼Œä»–æ‰€åšçš„äº‹å°±æ˜¯ä¿å­˜å½“å‰çš„å¯„å­˜å™¨ä¸­çš„å€¼ï¼Œç„¶åŽæŠŠå¯„å­˜å™¨ä¸­çš„å€¼è®¾ç½®ä¸ºCPUè°ƒåº¦å™¨çš„ä¸Šä¸‹æ–‡ã€‚ä¹‹åŽå°†è¯¦ç»†è§£é‡Šã€‚</p>
<p>contextæ˜¯ä»€ä¹ˆï¼Ÿå…¶å®žæœ¬è´¨å°±æ˜¯ä¸€äº›<code>callee saved</code>registerå’Œ<code>ra, sp</code>å¯„å­˜å™¨ã€‚ä¸ºä»€ä¹ˆæ˜¯ä»–ä»¬å‘¢ï¼Œä¹‹åŽä¼šè§£é‡Šã€‚</p>
</blockquote>
<p>Switching from one thread to another involves saving the old threadâ€™s CPU registers, and restoring the previously-saved registers of the new thread; the fact that the stack pointer and program counter are saved and restored means that the CPU will switch stacks and switch what code it is executing.</p>
<p>The function <code>swtch</code> performs the <strong>saves and restores for a kernel thread switch</strong>. <code>swtch</code> doesnâ€™t directly know about threads; <strong>it just saves and restores register sets, called <code>contexts</code></strong>.</p>
<p>When it is time for a process to give up the CPU, <strong>the processâ€™s kernel thread calls <code>swtch</code> to save its own context and return to the scheduler context.</strong> Each context is contained in a <code>struct context</code> (kernel/proc.h:2), itself contained in a processâ€™s struct proc or a CPUâ€™s <code>struct cpu</code>. <code>Swtch</code> takes two arguments: <code>struct context *old</code> and <code>struct context *new</code>. It saves the current registers in old, loads registers from new, and returns.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">ra</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">sp</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// callee-saved</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s0</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s3</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s4</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s5</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s6</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s7</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s8</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s9</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s10</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">s11</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// Per-CPU state.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">proc</span><span class="p">;</span><span class="w">          </span><span class="c1">// The process running on this cpu, or null.</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w">     </span><span class="c1">// swtch() here to enter scheduler().</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">noff</span><span class="p">;</span><span class="w">                   </span><span class="c1">// Depth of push_off() nesting.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">intena</span><span class="p">;</span><span class="w">                 </span><span class="c1">// Were interrupts enabled before push_off()?</span>
<span class="p">};</span>
</code></pre></div>
<p>Letâ€™s follow a process through <code>swtch</code> into the scheduler. We saw in Chapter 4 that one possibility at the end of an interrupt is that <code>usertrap</code> calls <code>yield</code>. <code>Yield</code> in turn calls <code>sched</code>, which calls <code>swtch</code> to save the current context in p-&gt;context and switch to the scheduler context previously saved in <code>cpu-&gt;scheduler</code> (kernel/proc.c:509).</p>
<blockquote>
<p>è¿™é‡Œä»¥timer interruptä¸ºä¾‹å­ï¼Œæ¦‚è¿°äº†æ•´ä¸ªå‡½æ•°è°ƒç”¨çš„è¿‡ç¨‹</p>
<p><code>process A kernel thread: usertrap() -&gt; yield() -&gt; sched() -&gt; swtch()</code></p>
<p><code>CPU scheduler thread(process Aæ˜¯é€šè¿‡å®ƒè¢«è°ƒåº¦æ‰§è¡Œçš„): swtch() return -&gt; scheduler() for loop -&gt; find process B -&gt; swtch()</code></p>
<p><code>process B kernel thread: swtch() return -&gt; sched() return -&gt; yield() return -&gt; usertrap()</code></p>
<p><code>sched()</code>å‡½æ•°ä¸»è¦ç”¨æ¥å¯¹<code>yield()</code>è¿›è¡ŒäºŒæ¬¡æ£€æŸ¥</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Give up the CPU for one scheduling round.</span>
<span class="kt">void</span>
<span class="nf">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">;</span>
<span class="w">  </span><span class="n">sched</span><span class="p">();</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Switch to scheduler.  Must hold only p-&gt;lock</span>
<span class="c1">// and have changed proc-&gt;state. Saves and restores</span>
<span class="c1">// intena because intena is a property of this</span>
<span class="c1">// kernel thread, not this CPU. It should</span>
<span class="c1">// be proc-&gt;intena and proc-&gt;noff, but that would</span>
<span class="c1">// break in the few places where a lock is held but</span>
<span class="c1">// there's no process.</span>
<span class="kt">void</span>
<span class="nf">sched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">intena</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched p-&gt;lock"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched locks"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched running"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">intr_get</span><span class="p">())</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched interruptible"</span><span class="p">);</span>

<span class="w">  </span><span class="n">intena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="p">;</span>
<span class="w">  </span><span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intena</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Swtch</code> (kernel/swtch.S:3) saves only <code>callee-saved</code> registers; <strong>caller-saved registers are saved on the stack (if needed) by the calling C code</strong>. <code>Swtch</code> knows the offset of each registerâ€™s field in struct context.</p>
<p>It does not save the program counter. <strong>Instead, <code>swtch</code> saves the <code>ra</code> register, which holds the return address from which <code>swtch</code> was called.</strong> Now <code>swtch</code> restores registers from the new context, which holds register values saved by a previous <code>swtch</code>. When <code>swtch</code> returns, it returns to the instructions pointed to by the restored <code>ra</code> register, that is, the instruction from which the new thread previously called <code>swtch</code>.</p>
<p>In addition, it returns on the <strong>new threadâ€™s stack.</strong></p>
<blockquote>
<p><code>swtch()</code>çš„ä»£ç éžå¸¸ç®€å•ï¼Œå°±æ˜¯ç®€å•çš„storeå’Œrestoreã€‚</p>
<p>è¿™é‡Œéœ€è¦ç•™æ„çš„æ˜¯ï¼Œæˆ‘ä»¬åœ¨ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶ä»…ä»…ä¿å­˜äº†<code>callee saved</code>å¯„å­˜å™¨ï¼Œè¿™äº›å¯„å­˜å™¨çš„ç‰¹ç‚¹å°±æ˜¯ä»–ä»¬ä¼šè¢«è¢«è°ƒç”¨å‡½æ•°çš„æ ˆå¸§ä¿å­˜ï¼Œå› ä¸ºè¢«è°ƒç”¨å‡½æ•°ä¼šç»§ç»­ç”¨ä»–ä»¬æ‰§è¡Œè‡ªå·±çš„ä»»åŠ¡ï¼Œè¿™æ ·å½“è¢«è°ƒç”¨å‡½æ•°è¿”å›žæ—¶ï¼Œè¿™äº›å¯„å­˜å™¨å°±ä¼šæ¢å¤ä»–ä»¬åœ¨è°ƒç”¨è€…é‚£æ—¶çš„çŠ¶æ€ã€‚ç„¶è€Œï¼Œ<code>swtch()</code>å‡½æ•°ä¸ä¼šå†æœ‰<code>callee</code>æ¥ä¸ºå®ƒä¿å­˜è¿™äº›å¯„å­˜å™¨äº†ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿™é‡Œåªä¿å­˜<code>callee saved</code>ã€‚</p>
<p>å¦ä¸€ç‚¹éœ€è¦ç•™æ„çš„å°±æ˜¯æˆ‘ä»¬åªä¿å­˜å’Œæ¢å¤äº†<code>ra å’Œ sp</code>ã€‚<code>sp</code>å¾ˆå¥½ç†è§£ï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„æ ˆï¼›<code>ra</code>æŒ‡çš„æ˜¯return addressï¼Œå½“ä¸‹è¾¹çš„æ±‡ç¼–ä»£ç æ‰§è¡Œåˆ°retæ—¶ï¼Œæˆ‘ä»¬çš„pcå°±ä¼šæŒ‡å‘<code>ra</code>ä¸­çš„åœ°å€, æ‰€ä»¥åœ¨è¿™é‡Œè®¾ç½®pcçš„å€¼æ˜¯æ²¡æœ‰å¿…è¦çš„ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code>## Context switch
##
##   void swtch(struct context *old, struct context *new);
##
## Save current registers in old. Load from new.


.globl swtch
swtch:
        sd ra, 0(a0)
        sd sp, 8(a0)
        sd s0, 16(a0)
        sd s1, 24(a0)
        sd s2, 32(a0)
        sd s3, 40(a0)
        sd s4, 48(a0)
        sd s5, 56(a0)
        sd s6, 64(a0)
        sd s7, 72(a0)
        sd s8, 80(a0)
        sd s9, 88(a0)
        sd s10, 96(a0)
        sd s11, 104(a0)

        ld ra, 0(a1)
        ld sp, 8(a1)
        ld s0, 16(a1)
        ld s1, 24(a1)
        ld s2, 32(a1)
        ld s3, 40(a1)
        ld s4, 48(a1)
        ld s5, 56(a1)
        ld s6, 64(a1)
        ld s7, 72(a1)
        ld s8, 80(a1)
        ld s9, 88(a1)
        ld s10, 96(a1)
        ld s11, 104(a1)

        ret
</code></pre></div>
<blockquote>
<p>éœ€è¦å†å¼ºè°ƒä¸€æ¬¡ï¼Œçº¿ç¨‹çš„åˆ‡æ¢æ˜¯è¦ç»è¿‡CPU schedulerçº¿ç¨‹çš„ã€‚</p>
</blockquote>
<p>In our example, <code>sched</code> called <code>swtch</code> to switch to <code>cpu-&gt;scheduler</code>, the per-CPU scheduler context. That context had been saved by schedulerâ€™s call to <code>swtch</code> (kernel/proc.c:475). <strong>When the <code>swtch</code> we have been tracing returns, it returns not to <code>sched</code> but to scheduler, and its stack pointer points at the current CPUâ€™s scheduler stack.</strong></p>
<h3 id="73-code-scheduling">7.3 Code: Scheduling<a class="headerlink" href="#73-code-scheduling" title="Permanent link">Â¶</a></h3>
<p>The last section looked at the low-level details of <code>swtch</code>; now letâ€™s take <code>swtch</code> as a given and examine switching from one processâ€™s kernel thread through the scheduler to another process. <strong>The scheduler exists in the form of a special thread per CPU, each running the scheduler function.</strong> This function is in charge of choosing which process to run next.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Per-CPU process scheduler.</span>
<span class="c1">// Each CPU calls scheduler() after setting itself up.</span>
<span class="c1">// Scheduler never returns.  It loops, doing:</span>
<span class="c1">//  - choose a process to run.</span>
<span class="c1">//  - swtch to start running that process.</span>
<span class="c1">//  - eventually that process transfers control</span>
<span class="c1">//    via swtch back to the scheduler.</span>
<span class="kt">void</span>
<span class="nf">scheduler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">();</span>

<span class="w">  </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(;;){</span>
<span class="w">    </span><span class="c1">// Avoid deadlock by ensuring that devices can interrupt.</span>
<span class="w">    </span><span class="n">intr_on</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Switch to chosen process.  It is the process's job</span>
<span class="w">        </span><span class="c1">// to release its lock and then reacquire it</span>
<span class="w">        </span><span class="c1">// before jumping back to us.</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">;</span>
<span class="w">        </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Process is done running for now.</span>
<span class="w">        </span><span class="c1">// It should have changed its p-&gt;state before coming back.</span>
<span class="w">        </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p><strong>A process that wants to give up the CPU must acquire its own process lock p-&gt;lock, release any other locks it is holding, update its own state (p-&gt;state), and then call <code>sched</code>.</strong> Yield (kernel/proc.c:515) follows this convention, as do sleep and exit, which we will examine later. Sched double-checks those conditions (kernel/proc.c:499-504) and then an implication of those conditions: since a lock is held, interrupts should be disabled. Finally, <code>sched</code> calls <code>swtch</code> to save the current context in p-&gt;context and switch to the scheduler context in <code>cpu-&gt;scheduler</code>. <code>Swtch</code> returns on the schedulerâ€™s stack as though schedulerâ€™s <code>swtch</code> had returned. The scheduler continues the for loop, finds a process to run, switches to it, and the cycle repeats.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Give up the CPU for one scheduling round.</span>
<span class="kt">void</span>
<span class="nf">yield</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">;</span>
<span class="w">  </span><span class="n">sched</span><span class="p">();</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Switch to scheduler.  Must hold only p-&gt;lock</span>
<span class="c1">// and have changed proc-&gt;state. Saves and restores</span>
<span class="c1">// intena because intena is a property of this</span>
<span class="c1">// kernel thread, not this CPU. It should</span>
<span class="c1">// be proc-&gt;intena and proc-&gt;noff, but that would</span>
<span class="c1">// break in the few places where a lock is held but</span>
<span class="c1">// there's no process.</span>
<span class="kt">void</span>
<span class="nf">sched</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">intena</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched p-&gt;lock"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">noff</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched locks"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched running"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">intr_get</span><span class="p">())</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"sched interruptible"</span><span class="p">);</span>

<span class="w">  </span><span class="n">intena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="p">;</span>
<span class="w">  </span><span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>
<span class="w">  </span><span class="n">mycpu</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">intena</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intena</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>We just saw that xv6 holds p-&gt;lock across calls to <code>swtch</code>: the caller of <code>swtch</code> must already hold the lock, and control of the lock passes to the switched-to code. This convention is unusual with locks; usually the thread that acquires a lock is also responsible for releasing the lock, which makes it easier to reason about correctness.</p>
<p>For context switching it is necessary to break this convention because p-&gt;lock protects invariants on the processâ€™s state and context fields that are not true while executing in <code>swtch</code>. <u>One example of a problem that could arise if p-&gt;lock were not held during <code>swtch</code>: a different CPU might decide to run the process after yield had set its state to RUNNABLE, but before <code>swtch</code> caused it to stop using its own kernel stack. The result would be two CPUs running on the same stack, which cannot be right.</u></p>
<blockquote>
<p>ä¸‹å›¾å¯¹æ•´ä¸ªè°ƒåº¦çš„è¿‡ç¨‹è¿›è¡Œäº†æ±‡æ€»ï¼Œè¿™é‡Œå¯¹é”çš„ä½¿ç”¨æ˜¯ååˆ†å·§å¦™åœ°ï¼Œä¸ºäº†é¿å…ä¸Šè¿°å¯èƒ½å‘ç”Ÿçš„æƒ…å†µã€‚æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œprocess Aåœ¨yieldä¸­èŽ·å¾—é”ï¼Œåœ¨è¿›å…¥schedulerçº¿ç¨‹ä¸­æ—¶é‡Šæ”¾äº†é”ï¼Œè¿™æ ·ä¿è¯äº†åˆ‡æ¢åˆ°è°ƒåº¦è¿›ç¨‹çš„åŽŸå­æ€§ã€‚ä¹‹åŽCPUçº¿ç¨‹å°±ä¼šç»§ç»­forå¾ªçŽ¯ï¼Œç›´åˆ°æ‰¾åˆ°äº†æ–°çš„è¿›ç¨‹process Bï¼Œschedulerçº¿ç¨‹ç»™è¿›ç¨‹Bä¸Šäº†é”ï¼Œåœ¨yieldä¸­é‡Šæ”¾äº†é”ï¼Œè¿™æ ·ä¿è¯äº†åˆ‡æ¢åˆ°æ–°çº¿ç¨‹çš„åŽŸå­æ€§ã€‚</p>
<p>é€šè¿‡ä¸‹å›¾ï¼Œ<code>p-&gt;context</code>å’Œ<code>c-&gt;context</code>ä¹‹ä¸­ä¿å­˜äº†ä»€ä¹ˆä¹Ÿå°±æ¸…æ™°äº†ã€‚process Aåœ¨<code>swtch()</code>æ—¶å°†å½“å‰å¯„å­˜å™¨çš„ç›¸å…³å€¼ä¿å­˜åˆ°äº†<code>p-&gt;context</code>, è¿™æ—¶<code>cpu-&gt;context</code>ä¸­å­˜å‚¨çš„æ˜¯schedulerçº¿ç¨‹è¿›è¡Œæ‰¾åˆ°process AåŽæ‰§è¡Œ<code>swtch()</code>æ—¶å¯„å­˜å™¨çš„çŠ¶æ€ï¼Œ<code>cpu-&gt;context</code>ä¼šè¢«restoreåˆ°å¯„å­˜å™¨ä¸­ï¼Œä»Žè€Œæˆ‘ä»¬å°±å›žåˆ°äº†schedulerçº¿ç¨‹ã€‚</p>
<p>schedulerçº¿ç¨‹é€šè¿‡forå¾ªçŽ¯æ‰¾åˆ°çš„æ–°çš„è¿›ç¨‹process Bï¼Œåˆå°†<code>swtch()</code>æ—¶çš„contextä¿å­˜åˆ°<code>cpu-&gt;context</code>ï¼Œç„¶åŽå°†process Bä¸­ä¹‹å‰ä¿å­˜çš„<code>p-&gt;context</code>restoreåˆ°å¯„å­˜å™¨ä¸­ï¼ŒæŽ¥ç€æˆ‘ä»¬å°±åˆ‡æ¢åˆ°äº†process Bçš„å†…æ ¸çº¿ç¨‹ä¸­ã€‚</p>
</blockquote>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220613001313654.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220613001313654" src="../../../../assets/Operating%20Systems.assets/image-20220613001313654.png"></a></p>
<p><strong>A kernel thread always gives up its CPU in <code>sched</code> and always switches to the same location in the scheduler, which (almost) always switches to some kernel thread that previously called <code>sched</code>.</strong> Thus, if one were to print out the line numbers where xv6 switches threads, one would observe the following simple pattern: (kernel/proc.c:475), (kernel/proc.c:509), (kernel/proc.c:475), (kernel/proc.c:509), and so on. <strong>The procedures in which this stylized switching between two threads happens are sometimes referred to as <code>coroutines</code></strong>; in this example, <strong><code>sched</code> and <code>scheduler</code> are co-routines of each other</strong>.</p>
<blockquote>
<p>å¯ä»¥çœ‹å‡ºï¼Œå†…æ ¸çº¿ç¨‹é—´çš„åˆ‡æ¢çš„å‡½æ•°è°ƒç”¨éƒ½æ˜¯<code>sched</code> and <code>scheduler</code>äº¤æ›¿ç€è¿›è¡Œçš„ï¼Œä»–ä»¬å¯ä»¥è¢«ç§°ä¸º<code>coroutines</code></p>
<p>ä¸Šå›¾ä¹Ÿç›¸åº”çš„å¼•å‡ºäº†ä¸€ä¸ªé—®é¢˜ï¼Œçœ‹ä¸ŠåŽ»è¿›ç¨‹ä¹‹é—´éƒ½æ˜¯åœ¨ä¸åœçš„äº¤æ¢contextï¼Œé‚£ä¹ˆä¸€å¼€å§‹è¿™äº›processä¸­çš„contextæ˜¯å“ªé‡Œæ¥çš„å‘¢ï¼Ÿä¸‹é¢çš„å†…å®¹è§£ç­”äº†è¿™ä¸€é—®é¢˜ã€‚</p>
<p>å¯ä»¥çœ‹åˆ°<code>allocproc</code>åœ¨ä¸€å¼€å§‹åˆå§‹åŒ–æ¯ä¸€ä¸ª<code>proc</code>çš„æ—¶å€™ï¼Œå°±é¢„å…ˆå°†ä»–ä»¬çš„contextä¸­çš„è¿”å›žåœ°å€è®¾ä¸ºäº†<code>forkret</code>, è¿™é‡Œæœ‰ä¸€ä¸ªå‡çš„<code>usertrapret</code>è®©æ–°çš„è¿›ç¨‹å¯ä»¥è¿”å›žç”¨æˆ·ç©ºé—´æ‰§è¡Œä»–çš„ç”¨æˆ·çº¿ç¨‹ã€‚</p>
</blockquote>
<p><strong>There is one case when the schedulerâ€™s call to <code>swtch</code> does not end up in <code>sched</code>.</strong> When a new process is first scheduled, it begins at <code>forkret</code> (kernel/proc.c:527). <code>Forkret</code> exists to release the p-&gt;lock; otherwise, the new process could start at <code>usertrapret</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// A fork child's very first scheduling by scheduler()</span>
<span class="c1">// will swtch to forkret.</span>
<span class="kt">void</span>
<span class="nf">forkret</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Still holding p-&gt;lock from scheduler.</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// File system initialization must be run in the context of a</span>
<span class="w">    </span><span class="c1">// regular process (e.g., because it calls sleep), and thus cannot</span>
<span class="w">    </span><span class="c1">// be run from main().</span>
<span class="w">    </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">fsinit</span><span class="p">(</span><span class="n">ROOTDEV</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">usertrapret</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// Look in the process table for an UNUSED proc.</span>
<span class="c1">// If found, initialize state required to run in the kernel,</span>
<span class="c1">// and return with p-&gt;lock held.</span>
<span class="c1">// If there are no free procs, or a memory allocation fails, return 0.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="o">*</span>
<span class="n">allocproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="w"> </span><span class="p">...................</span>

<span class="nl">found</span><span class="p">:</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">allocpid</span><span class="p">();</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">USED</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Allocate a trapframe page.</span>
<span class="w">    </span><span class="p">................</span>
<span class="w">  </span><span class="c1">// An empty user page table.</span>
<span class="w">    </span><span class="p">................</span>
<span class="w">  </span><span class="c1">// Set up new context to start executing at forkret,</span>
<span class="w">  </span><span class="c1">// which returns to user space.</span>
<span class="w">  </span><span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">));</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">ra</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="n">forkret</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">.</span><span class="n">sp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">kstack</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Scheduler (kernel/proc.c:457) runs a simple loop: find a process to run, run it until it yields, repeat. The scheduler loops over the process table looking for a runnable process, one that has p-&gt;state == RUNNABLE. Once it finds a process, it sets the per-CPU current process variable c-&gt;proc, marks the process as RUNNING, and then calls <code>swtch</code> to start running it (kernel/proc.c:470- 475).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Per-CPU process scheduler.</span>
<span class="c1">// Each CPU calls scheduler() after setting itself up.</span>
<span class="c1">// Scheduler never returns.  It loops, doing:</span>
<span class="c1">//  - choose a process to run.</span>
<span class="c1">//  - swtch to start running that process.</span>
<span class="c1">//  - eventually that process transfers control</span>
<span class="c1">//    via swtch back to the scheduler.</span>
<span class="kt">void</span>
<span class="nf">scheduler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">();</span>

<span class="w">  </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(;;){</span>
<span class="w">    </span><span class="c1">// Avoid deadlock by ensuring that devices can interrupt.</span>
<span class="w">    </span><span class="n">intr_on</span><span class="p">();</span>

<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Switch to chosen process.  It is the process's job</span>
<span class="w">        </span><span class="c1">// to release its lock and then reacquire it</span>
<span class="w">        </span><span class="c1">// before jumping back to us.</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNING</span><span class="p">;</span>
<span class="w">        </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">        </span><span class="n">swtch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">context</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// Process is done running for now.</span>
<span class="w">        </span><span class="c1">// It should have changed its p-&gt;state before coming back.</span>
<span class="w">        </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="locks-in-scheduling-code">Locks in scheduling code<a class="headerlink" href="#locks-in-scheduling-code" title="Permanent link">Â¶</a></h4>
<p>One way to think about the structure of the scheduling code is that it enforces a set of invariants about each process, and holds p-&gt;lock whenever those invariants are not true. One invariant is that if a process is RUNNING, a timer interruptâ€™s yield must be able to safely switch away from the process; this means that the CPU registers must hold the processâ€™s register values (i.e. <code>swtch</code> hasnâ€™t moved them to a context), and c-&gt;proc must refer to the process. Another invariant is that if a process is RUNNABLE, it must be safe for an idle CPUâ€™s scheduler to run it; this means that p-&gt;context must hold the processâ€™s registers (i.e., they are not actually in the real registers), that no CPU is executing on the processâ€™s kernel stack, and that no CPUâ€™s c-&gt;proc refers to the process. Observe that these properties are often not true while p-&gt;lock is held.</p>
<p>Maintaining the above invariants is the reason why xv6 often acquires p-&gt;lock in one thread and releases it in other, for example acquiring in yield and releasing in scheduler. Once yield has started to modify a running processâ€™s state to make it RUNNABLE, the lock must remain held until the invariants are restored: the earliest correct release point is after scheduler (running on its own stack) clears c-&gt;proc. Similarly, once scheduler starts to convert a RUNNABLE process to RUNNING, the lock cannot be released until the kernel thread is completely running (after the <code>swtch</code>, for example in yield).</p>
<p>p-&gt;lock protects other things as well: the interplay between exit and wait, the machinery to avoid lost wakeups (see Section 7.5), and avoidance of races between a process exiting and other processes reading or writing its state (e.g., the exit system call looking at <code>p-&gt;pid</code> and setting <code>p-&gt;killed</code> (kernel/proc.c:611)). It might be worth thinking about whether the different functions of p-&gt;lock could be split up, for clarity and perhaps for performance.</p>
<h3 id="74-code-mycpu-and-myproc">7.4 Code: <code>mycpu</code> and <code>myproc</code><a class="headerlink" href="#74-code-mycpu-and-myproc" title="Permanent link">Â¶</a></h3>
<p>Xv6 often needs a pointer to the current processâ€™s proc structure. On a uniprocessor one could have a global variable pointing to the current proc. This doesnâ€™t work on a multi-core machine, since each core executes a different process. The way to solve this problem is to exploit the fact that each core has its own set of registers; we can use one of those registers to help find per-core information.</p>
<p>Xv6 maintains a struct <code>cpu</code> for each CPU (kernel/proc.h:22), which records the process currently running on that CPU (if any), saved registers for the CPUâ€™s scheduler thread, and the count of nested spinlocks needed to manage interrupt disabling. The function <code>mycpu</code> (kernel/proc.c:60) returns a pointer to the current CPUâ€™s struct <code>cpu</code>. RISC-V numbers its CPUs, giving each a <code>hartid</code>. Xv6 ensures that each CPUâ€™s <code>hartid</code> is stored in that CPUâ€™s <strong><code>tp</code> register while in the kernel</strong>. This allows <code>mycpu</code> to use tp to index an array of <code>cpu</code> structures to find the right one.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Return this CPU's cpu struct.</span>
<span class="c1">// Interrupts must be disabled.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="o">*</span>
<span class="n">mycpu</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpuid</span><span class="p">();</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">cpus</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Must be called with interrupts disabled,</span>
<span class="c1">// to prevent race with process being moved</span>
<span class="c1">// to a different CPU.</span>
<span class="kt">int</span>
<span class="n">cpuid</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_tp</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">id</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// read and write tp, the thread pointer, which holds</span>
<span class="c1">// this core's hartid (core number), the index into cpus[].</span>
<span class="k">static</span><span class="w"> </span><span class="kr">inline</span><span class="w"> </span><span class="n">uint64</span>
<span class="n">r_tp</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mv %0, tp"</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s">"=r"</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Ensuring that a CPUâ€™s tp always holds the CPUâ€™s <code>hartid</code> is a little involved. <code>mstart</code> sets the tp register early in the CPUâ€™s boot sequence, while still in machine mode (kernel/start.c:46). <code>usertrapret</code> saves tp in the trampoline page, because the user process might modify tp. Finally, <code>uservec</code> restores that saved tp when entering the kernel from user space (kernel/trampoline.S:70). <strong>The compiler guarantees never to use the tp register</strong>. It would be more convenient if RISC-V allowed xv6 to read the current <code>hartid</code> directly, but that is allowed only in machine mode, not in supervisor mode.</p>
<p><strong>The return values of <code>cpuid</code> and <code>mycpu</code> are fragile</strong>: if the <u>timer were to interrupt</u> and cause the thread to <u>yield and then move to a different CPU, a previously returned value would no longer be correct</u>. To avoid this problem, xv6 requires that <strong>callers disable interrupts</strong>, and only enable them after they finish using the returned struct <code>cpu</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">start</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// set M Previous Privilege mode to Supervisor, for mret.</span>

<span class="w">  </span><span class="c1">// set M Exception Program Counter to main, for mret.</span>
<span class="w">  </span><span class="c1">// requires gcc -mcmodel=medany</span>

<span class="w">  </span><span class="c1">// disable paging for now.</span>

<span class="w">  </span><span class="c1">// delegate all interrupts and exceptions to supervisor mode.</span>

<span class="w">  </span><span class="c1">// configure Physical Memory Protection to give supervisor mode</span>
<span class="w">  </span><span class="c1">// access to all of physical memory.</span>

<span class="w">  </span><span class="c1">// ask for clock interrupts.</span>
<span class="w">  </span><span class="n">timerinit</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// keep each CPU's hartid in its tp register, for cpuid().</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_mhartid</span><span class="p">();</span>
<span class="w">  </span><span class="n">w_tp</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// switch to supervisor mode and jump to main().</span>
<span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="p">(</span><span class="s">"mret"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The function <code>myproc</code> (kernel/proc.c:68) returns the struct proc pointer for the process that is running on the current CPU. <code>myproc</code> disables interrupts, invokes <code>mycpu</code>, fetches the current process pointer (c-&gt;proc) out of the struct <code>cpu</code>, and then enables interrupts. The return value of <code>myproc</code> is safe to use even if interrupts are enabled: if a timer interrupt moves the calling process to a different CPU, its struct proc pointer will stay the same.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Return the current struct proc *, or zero if none.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="o">*</span>
<span class="n">myproc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">push_off</span><span class="p">();</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">cpu</span><span class="w"> </span><span class="o">*</span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mycpu</span><span class="p">();</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">-&gt;</span><span class="n">proc</span><span class="p">;</span>
<span class="w">  </span><span class="n">pop_off</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="75-sleep-and-wakeup">7.5 Sleep and wakeup<a class="headerlink" href="#75-sleep-and-wakeup" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>æœ‰äº†è¿›ç¨‹è°ƒåº¦å’Œé”ï¼Œä¸ºä»€ä¹ˆè¿˜éœ€è¦sleepå’Œwakeupå‘¢ï¼Ÿ</p>
</blockquote>
<p>Scheduling and locks help conceal the existence of one process from another, but so far we have no abstractions that help processes intentionally interact. Many mechanisms have been invented to solve this problem. Xv6 uses one called sleep and wakeup, which allow one process to sleep waiting for an event and another process to wake it up once the event has happened. <code>Sleep</code> and <code>wakeup</code> are often called <strong>sequence coordination</strong> or <strong>conditional synchronization mechanisms.</strong></p>
<blockquote>
<p>ä¸‹é¢æ˜¯ä¸€ä¸ªä¿¡å·é‡çš„ä¾‹å­ã€‚ç”Ÿäº§è€…çº¿ç¨‹è°ƒç”¨Væ¥è®©è®©countå¢žåŠ ï¼Œæ¶ˆè´¹è€…çº¿ç¨‹è°ƒç”¨Pä¸€ç›´ç›‘æŽ§ç€countï¼Œä¸€å‘çŽ°ç”Ÿäº§å‡ºä¸œè¥¿å°±ç«‹åˆ»æ¶ˆè´¹ã€‚ç„¶è€Œï¼Œå¦‚æžœç”Ÿäº§è€…é•¿æ—¶é—´ä¸ç”Ÿäº§ï¼Œé‚£ä¹ˆæ¶ˆè´¹è€…çº¿ç¨‹ä¼šä¸€ç›´å ç”¨CPUï¼Œæˆ‘ä»¬åº”è¯¥æƒ³åŠžæ³•è®©æ¶ˆè´¹è€…åœ¨ç­‰å¾…çš„è¿™æ®µæ—¶é—´è®©å‡ºCPUã€‚</p>
</blockquote>
<p>To illustrate, letâ€™s consider a synchronization mechanism called a <strong>semaphore</strong>(ä¿¡å·) that coordinates producers and consumers. A semaphore maintains a count and provides two operations. The â€œVâ€ operation (for the producer) increments the count. The â€œPâ€ operation (for the consumer) waits until the count is non-zero, and then decrements it and returns. If there were only one producer thread and one consumer thread, and they executed on different CPUs, and the compiler didnâ€™t optimize too aggressively, this implementation would be correct:</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="p">{</span>
<span class="mi">101</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="mi">102</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="mi">103</span><span class="w"> </span><span class="p">};</span>
<span class="mi">104</span>
<span class="mi">105</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">106</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">107</span><span class="w"> </span><span class="p">{</span>
<span class="mi">108</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">109</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">110</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">111</span><span class="w"> </span><span class="p">}</span>
<span class="mi">112</span>
<span class="mi">113</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">114</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">115</span><span class="w"> </span><span class="p">{</span>
<span class="mi">116</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="mi">117</span><span class="w"> </span><span class="p">;</span>
<span class="mi">118</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">119</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">120</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">121</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>The implementation above is expensive. If the producer acts rarely, the consumer will spend most of its time spinning in the while loop hoping for a non-zero count. The consumerâ€™s CPU could find more productive work than with busy waiting by repeatedly polling s-&gt;count. <strong>Avoiding busy waiting requires a way for the consumer to yield the CPU and resume only after V increments the count.</strong></p>
<hr>
<p>Hereâ€™s a step in that direction, though as we will see it is not enough. Letâ€™s imagine a pair of calls, sleep and wakeup, that work as follows. Sleep(<code>chan</code>) sleeps on the arbitrary value <code>chan</code>, called the <code>wait channel</code>. <code>Sleep</code> puts the calling process to sleep, releasing the CPU for other work. <code>Wakeup(chan)</code>wakes all processes sleeping on<code>chan</code> (if any), causing their <code>sleep</code> calls to return. If no processes are waiting on <code>chan</code>, <code>wakeup</code> does nothing. We can change the semaphore implementation to use sleep and wakeup (changes highlighted in yellow):</p>
<div class="highlight"><pre><span></span><code><span class="mi">200</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">201</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">202</span><span class="w"> </span><span class="p">{</span>
<span class="mi">203</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">204</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">205</span><span class="w"> </span><span class="n">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="c1">//change</span>
<span class="mi">206</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">207</span><span class="w"> </span><span class="p">}</span>
<span class="mi">208</span>
<span class="mi">209</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">210</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">211</span><span class="w"> </span><span class="p">{</span>
<span class="mi">212</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="mi">213</span><span class="w">     </span><span class="n">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span><span class="c1">//change</span>
<span class="mi">214</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">215</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">216</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">217</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>P now gives up the CPU instead of spinning, which is nice. However, it turns out not to be straightforward to design sleep and wakeup with this interface without suffering from what is known as the <strong>lost wake-up problem</strong>.</p>
<blockquote>
<p>è¿™ç§è®¾è®¡å¹¶ä¸å®Œç¾Žï¼Œä»–ä¼šå¸¦æ¥**lost wake-up problem**ï¼Œå…·ä½“çš„æƒ…æ™¯å°±æ˜¯ï¼Œæ¶ˆè´¹è€…å’Œç”Ÿäº§è€…è¿è¡Œåœ¨ä¸¤ä¸ªCPUä¸Šï¼Œå½“æ¶ˆè´¹è€…å¤„åœ¨è¿›å…¥ç¡çœ çŠ¶æ€çš„è¿‡ç¨‹ä¸­æ—¶ï¼Œç”Ÿäº§è€…å®Œæˆäº†ç”Ÿäº§å¹¶å°†countå˜ä¸º1ï¼Œç„¶åŽé€šçŸ¥ç¡çœ ä¸­çš„è¿›ç¨‹è‹é†’ï¼Œç„¶è€Œè¿™æ—¶æ¶ˆè´¹è€…è¿˜æ²¡æœ‰è¿›å…¥ç¡çœ ï¼Œ ä»Žè€Œæ¶ˆè´¹è€…é¢å¯¹count = 1æ—¶ä¿æŒç€ç¡çœ çš„çŠ¶æ€ã€‚æœ€åŽé€ æˆçš„ç»“æžœå°±æ˜¯ï¼Œè‹¥ç”Ÿäº§è€…ä¹‹åŽä¸å†è°ƒç”¨æ¶ˆè´¹è€…ï¼Œé‚£ä¹ˆæ¶ˆè´¹è€…å°±ä¼šæ°¸è¿œçš„æ²‰ç¡ã€‚</p>
</blockquote>
<p>Suppose that P finds that s-&gt;count == 0 on line 212. While P is between lines 212 and 213, V runs on another CPU: it changes s-&gt;count to be nonzero and calls wakeup, which finds no processes sleeping and thus does nothing. Now P continues executing at line 213: it calls sleep and goes to sleep. This causes a problem: P is asleep waiting for a V call that has already happened. Unless we get lucky and the producer calls V again, the consumer will wait forever even though the count is non-zero.</p>
<hr>
<blockquote>
<p>åº”å¯¹ä¸Šé¢è¯´çš„**lost wake-up problem**ï¼Œä¸‹é¢çš„ä»£ç åšäº†ä¸€äº›æ”¹å˜ã€‚çœ‹èµ·æ¥ï¼Œç”Ÿäº§è€…å¿…é¡»ç­‰åˆ°æ¶ˆè´¹è€…è¿›å…¥ç¡çœ çŠ¶æ€åŽæ‰èƒ½å¢žåŠ countã€‚ç„¶è€Œï¼Œå½“æ¶ˆè´¹è€…è¿›å…¥ç¡çœ ä¹‹åŽï¼Œä»–ä¼šä¸€ç›´æ‹¥æœ‰é”ï¼Œä»Žè€Œç”Ÿäº§è€…æ°¸è¿œæ— æ³•æ‹¿åˆ°é”è¿›è¡Œç”Ÿäº§ï¼Œè¿™å°±é€ æˆäº†**æ­»é”**ã€‚</p>
</blockquote>
<p>The root of this problem is that the invariant that P only sleeps when s-&gt;count == 0 is violated by V running at just the wrong moment. An incorrect way to protect the invariant would be to move the lock acquisition (highlighted in yellow below) in P so that its check of the count and its call to sleep are atomic:</p>
<div class="highlight"><pre><span></span><code><span class="mi">300</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">301</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">302</span><span class="w"> </span><span class="p">{</span>
<span class="mi">303</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">304</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">305</span><span class="w"> </span><span class="n">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="mi">306</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">307</span><span class="w"> </span><span class="p">}</span>
<span class="mi">308</span>
<span class="mi">309</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">310</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">311</span><span class="w"> </span><span class="p">{</span>
<span class="mi">312</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//change</span>
<span class="mi">313</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="mi">314</span><span class="w">     </span><span class="n">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="mi">315</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">316</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">// è¿™é‡Œæ°¸è¿œæ‰§è¡Œä¸åˆ°</span>
<span class="mi">317</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>One might hope that this version of P would avoid the lost wakeup because the lock prevents V from executing between lines 313 and 314. It does that, but it also deadlocks: P holds the lock while it sleeps, so V will block forever waiting for the lock.</p>
<hr>
<blockquote>
<p>ä¸ºäº†è§£å†³æ­»é”çš„é—®é¢˜ï¼Œsleepåº”è¯¥åšåˆ°ä¸¤ä»¶äº‹</p>
<ol>
<li>æŽ¥å—æ¶ˆè´¹è€…çš„é”ä¸ºå‚æ•°ï¼Œå½“æ¶ˆè´¹è€…å®Œå…¨è¿›å…¥sleep channelåŽï¼Œåœ¨sleepå‡½æ•°å†…éƒ¨è§£é”ï¼Œä»Žè€Œç”Ÿäº§è€…å°±å¯ä»¥å¾—åˆ°é”ç»§ç»­æ‰§è¡Œã€‚</li>
<li>å½“æ¶ˆè´¹è€…wakeupæ—¶ï¼Œsleepå‡½æ•°è¦é‡æ–°èŽ·å¾—é”ï¼Œç„¶åŽè¿”å›žã€‚</li>
</ol>
</blockquote>
<p>Weâ€™ll fix the preceding scheme by changing sleepâ€™s interface: <strong>the caller must pass the condition lock to sleep so it can release the lock after the calling process is marked as asleep and waiting on the sleep channel</strong>. The lock will force a concurrent V to wait until P has finished putting itself to sleep, so that the wakeup will find the sleeping consumer and wake it up. <strong>Once the consumer is awake again sleep reacquires the lock before returning</strong>. Our new correct sleep/wakeup scheme is usable as follows (change highlighted in yellow):</p>
<div class="highlight"><pre><span></span><code><span class="mi">400</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">401</span><span class="w"> </span><span class="n">V</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">402</span><span class="w"> </span><span class="p">{</span>
<span class="mi">403</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">404</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">405</span><span class="w"> </span><span class="n">wakeup</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="mi">406</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">407</span><span class="w"> </span><span class="p">}</span>
<span class="mi">408</span>
<span class="mi">409</span><span class="w"> </span><span class="kt">void</span>
<span class="mi">410</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">semaphore</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="mi">411</span><span class="w"> </span><span class="p">{</span>
<span class="mi">412</span><span class="w"> </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">413</span><span class="w"> </span><span class="k">while</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="mi">414</span><span class="w"> </span><span class="n">sleep</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//change</span>
<span class="mi">415</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">count</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="mi">416</span><span class="w"> </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="mi">417</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>
<p>The fact that P holds s-&gt;lock prevents V from trying to wake it up between Pâ€™s check of c-&gt;count and its call to sleep. Note, however, that we need sleep to atomically release s-&gt;lock and put the consuming process to sleep.</p>
<h3 id="76-code-sleep-and-wakeup">7.6 Code: Sleep and wakeup<a class="headerlink" href="#76-code-sleep-and-wakeup" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>æŽ¥ä¸‹æ¥å°±è¯¥çœ‹çœ‹sleepå’Œwakeupç©¶ç«Ÿæ˜¯æ€Žä¹ˆå®žçŽ°çš„äº†</p>
</blockquote>
<p>Letâ€™s look at the implementation of sleep (kernel/proc.c:548) and wakeup (kernel/proc.c:582). The basic idea is to have sleep mark the current process as SLEEPING and then call <code>sched</code> to release the CPU; wakeup looks for a process sleeping on the given wait channel and marks it as RUNNABLE. Callers of sleep and wakeup can use any mutually convenient number as the channel. Xv6 often uses the address of a kernel data structure involved in the waiting.</p>
<h4 id="sleep">Sleep<a class="headerlink" href="#sleep" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// Atomically release lock and sleep on chan.</span>
<span class="c1">// Reacquires lock when awakened.</span>
<span class="kt">void</span>
<span class="nf">sleep</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">chan</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Must acquire p-&gt;lock in order to</span>
<span class="w">  </span><span class="c1">// change p-&gt;state and then call sched.</span>
<span class="w">  </span><span class="c1">// Once we hold p-&gt;lock, we can be</span>
<span class="w">  </span><span class="c1">// guaranteed that we won't miss any wakeup</span>
<span class="w">  </span><span class="c1">// (wakeup locks p-&gt;lock),</span>
<span class="w">  </span><span class="c1">// so it's okay to release lk.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">lk</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span><span class="w">  </span><span class="c1">//DOC: sleeplock0</span>
<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w">  </span><span class="c1">//DOC: sleeplock1</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Go to sleep.</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">chan</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SLEEPING</span><span class="p">;</span>

<span class="w">  </span><span class="n">sched</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Tidy up.</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Reacquire original lock.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">lk</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">){</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p><code>lk</code>æ˜¯wakeupå¯ä»¥å¼€å§‹çš„æ¡ä»¶ï¼Œsleepåœ¨æ‹¿åˆ°<code>p-&gt;lock</code>åŽå°±ç«‹åˆ»é‡Šæ”¾äº†<code>lk</code>ï¼Œä»Žè€Œwakeupå°±å¯ä»¥å¼€å§‹å·¥ä½œäº†ã€‚</p>
<p>ä½†è¿™å¹¶ä¸ä¼šå¯¼è‡´missing wake upçš„é—®é¢˜ï¼Œè™½ç„¶æˆ‘ä»¬é‡Šæ”¾äº†<code>lk</code>è®©wakeupå¾—ä»¥è¿›å…¥for loopå¼€å§‹å¯»æ‰¾éœ€è¦è¢«å”¤é†’çš„è¿›ç¨‹ï¼Œä½†æ˜¯for loopä¸­éœ€è¦èŽ·å–æ¯ä¸ªè¿›ç¨‹çš„é”ã€‚æ­£åœ¨å‡†å¤‡sleepingçš„è¿›ç¨‹æ­£æŒæœ‰ç€è¿™ä¸ªé”ï¼Œä»Žè€Œwakeupå¿…é¡»ç­‰å¾…sleepè¿›ç¨‹å½»åº•å…¥ç¡åŽæ‰èƒ½è¿›è¡Œå”¤é†’ä»»åŠ¡ã€‚</p>
<p>è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªxv6çš„å‡†åˆ™éœ€è¦æ³¨æ„ï¼Œæˆ‘ä»¬**åœ¨è¿›å…¥<code>sched</code>ä¹‹å‰ï¼Œå¿…é¡»ä¿è¯åªæœ‰<code>p-&gt;lock</code>è¿™ä¸€æŠŠé”**ï¼Œå› ä¸ºè¿™æŠŠé”ä¼šåœ¨è°ƒåº¦è¿›ç¨‹é‚£é‡Œè¢«releaseã€‚å¦‚æžœæˆ‘ä»¬æœ‰å…¶ä»–é”çš„è¯ï¼Œé‚£ä¹ˆä»–ä»¬åœ¨<code>sched</code>ä¹‹åŽå°†æ— æ³•é‡Šæ”¾ï¼Œä»Žè€Œå½“å¦å¤–ä¸€äº›è¿›ç¨‹éœ€è¦è¿™äº›é”çš„æ—¶å€™ï¼Œå¯¼è‡´æ­»é”ã€‚</p>
</blockquote>
<p>Sleep acquires p-&gt;lock (kernel/proc.c:559). Now the process going to sleep holds both <code>p-&gt;lock</code> and <code>lk</code>. Holding <code>lk</code> was necessary in the caller (in the example, P): it ensured that no other process (in the example, one running V) could start a call to <code>wakeup(chan)</code>. <u>Now that sleep holds <code>p-&gt;lock</code>, it is safe to release <code>lk</code>: some other process may start a call to <code>wakeup(chan)</code>, but wakeup will wait to acquire <code>p-&gt;lock</code>, and thus will wait until sleep has finished putting the process to sleep, keeping the wakeup from missing the sleep.</u></p>
<hr>
<blockquote>
<p>sleepæœ‰ä¸€ä¸ªç‰¹æ®Šçš„æƒ…å½¢ï¼Œå¦‚æžœ<code>lk</code>å°±æ˜¯<code>p-&gt;lock</code>æ€Žä¹ˆåŠžå‘¢ï¼Ÿ</p>
<p>é‚£ä¹ˆæˆ‘ä»¬å…¶å®žä»€ä¹ˆä¹Ÿä¸ç”¨åšï¼Œç­‰åˆ°sleepingè¿›ç¨‹åˆ‡æ¢åˆ°è°ƒåº¦è¿›ç¨‹è¢«é‡Šæ”¾åŽï¼Œå¯¹åº”çš„wakeupå°±å¯ä»¥è¿›å…¥forå¾ªçŽ¯å–å”¤é†’å®ƒäº†ã€‚</p>
<p>è¿™ç§æƒ…å½¢å‡ºçŽ°åœ¨<code>wait()</code>ç³»ç»Ÿè°ƒç”¨è¿™é‡Œï¼Œä¼šåœ¨ä¹‹åŽè¯´æ˜Žã€‚</p>
</blockquote>
<p><strong>There is a minor complication: if <code>lk</code> is the same lock as <code>p-&gt;lock</code>, then sleep would deadlock with itself if it tried to acquire p-&gt;lock</strong>. But if the process calling sleep already holds <code>p-&gt;lock</code>, it doesnâ€™t need to do anything more in order to avoiding missing a concurrent wakeup. This case arises when wait (kernel/proc.c:582) calls sleep with p-&gt;lock.</p>
<hr>
<blockquote>
<p>ä¸ºä»€ä¹ˆ<code>p-&gt;lock</code> is not released (by scheduler) until after the process is marked SLEEPING?</p>
</blockquote>
<p>Now that sleep holds p-&gt;lock and no others, it can put the process to sleep by recording the sleep channel, changing the process state to SLEEPING, and calling <code>sched</code> (kernel/proc.c:564-567). In a moment it will be clear why itâ€™s critical that <code>p-&gt;lock</code> is not released (by scheduler) until after the process is marked SLEEPING.</p>
<hr>
<h4 id="wakeup">Wakeup<a class="headerlink" href="#wakeup" title="Permanent link">Â¶</a></h4>
<p>At some point, a process will acquire the condition lock, set the condition that the sleeper is waiting for, and call <code>wakeup(chan</code>). Itâ€™s important that wakeup is called while holding the condition lock . Wakeup loops over the process table (kernel/proc.c:582). It acquires the p-&gt;lock of each process it inspects, both because it may manipulate that processâ€™s state and because p-&gt;lock ensures that sleep and wakeup do not miss each other. When wakeup finds a process in state SLEEPING with a matching <code>chan</code>, it changes that processâ€™s state to RUNNABLE. The next time the scheduler runs, it will see that the process is ready to be run.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Wake up all processes sleeping on chan.</span>
<span class="c1">// Must be called without any p-&gt;lock.</span>
<span class="kt">void</span>
<span class="nf">wakeup</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">chan</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SLEEPING</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">chan</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>ä¸ºä½•è¿™ç§è®¾è®¡ä¸ä¼šmiss wakeupï¼Ÿ</p>
<ol>
<li>wakeupè¿è¡Œæ—¶ä¸€ç›´æ‹¿ç€ä¸¤æŠŠé”ï¼šè¿›ç¨‹é”å’Œconditioné”ï¼ˆconditioné”æ˜¯wakeupå‡½æ•°æ‰§è¡Œçš„å‰ä¸€æ­¥ï¼‰</li>
<li>conditioné”ä¿è¯äº†åœ¨è¿›å…¥wakeupä¹‹å‰ï¼Œå·²ç»åŽŸå­æ€§çš„å®Œæˆäº†è¯¥åšçš„ä¸šåŠ¡é€»è¾‘ï¼ˆä¾‹å¦‚ï¼Œç»™bufferä¸­å†™å…¥å†…å®¹ï¼‰</li>
<li>è¿›ç¨‹é”ä¿è¯äº†åœ¨sleepingè¿›ç¨‹å®Œæˆç¡çœ è¿‡ç¨‹ä¹‹å‰ï¼Œwakeupä¸å¯ä»¥å¿½ç•¥ä»–ï¼ˆä¾‹å¦‚ï¼Œbufferä¸­å·²ç»æœ‰äº†ä¸€äº›å†…å®¹ï¼Œä½†<code>bufferReader</code>è¿˜æ²¡æœ‰è¿›å…¥ç¡çœ ï¼Œåªæœ‰åœ¨<code>bufferReader</code>è¿›å…¥ç¡çœ åŽï¼Œwakeupæ‰ä¼šå«é†’ä»–ï¼‰</li>
</ol>
</blockquote>
<p><strong>Why do the locking rules for sleep and wakeup ensure a sleeping process wonâ€™t miss a wakeup?</strong> The sleeping process holds either the condition lock or its own p-&gt;lock or both from a point before it checks the condition to a point after it is marked SLEEPING. The process calling wakeup holds both of those locks in wakeupâ€™s loop. Thus the <code>waker</code> either makes the condition true before the consuming thread checks the condition; or the <code>wakerâ€™s</code> wakeup examines the sleeping thread strictly after it has been marked SLEEPING. Then wakeup will see the sleeping process and wake it up (unless something else wakes it up first).</p>
<blockquote>
<p><strong>å¤šä¸ªè¿›ç¨‹éƒ½åœ¨åŒä¸€ä¸ªchannelä¸­ç¡çœ çš„æƒ…å†µ</strong></p>
<p>ç„¶è€Œï¼Œåªæœ‰ä¸€ä¸ªè¿›ç¨‹ä¼šåœ¨sleepä¸­è‹é†’åŽæŠ¢åˆ°condition lockç„¶åŽè¯»å–ç”Ÿäº§è€…ç”Ÿäº§çš„å†…å®¹</p>
<p>å½“å…¶ä»–è¢«å”¤é†’çš„æ•™ç¨‹ä¹‹åŽæ‹¿åˆ°condition lockï¼Œåªä¼šå‘çŽ°ä»€ä¹ˆéƒ½æ²¡äº†ï¼Œåªèƒ½åœ¨whileå¾ªçŽ¯ä¸­å†æ¬¡è¿›å…¥ç¡çœ </p>
<p>è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆsleepä¸ºä»€ä¹ˆæ€»æ˜¯åœ¨whileå¾ªçŽ¯ä¸­è¢«è°ƒç”¨</p>
</blockquote>
<p>It is sometimes the case that multiple processes are sleeping on the same channel; for example, more than one process reading from a pipe. A single call to wakeup will wake them all up. One of them will run first and acquire the lock that sleep was called with, and (in the case of pipes) read whatever data is waiting in the pipe. The other processes will find that, despite being woken up, there is no data to be read. From their point of view the wakeup was â€œ<strong>spurious(è™šå‡çš„)</strong>,â€ and they must sleep again. <strong>For this reason sleep is always called inside a loop that checks the condition.</strong></p>
<p>No harm is done if two uses of sleep/wakeup accidentally choose the same channel: they will see spurious wakeups, but looping as described above will tolerate this problem. Much of the charm of sleep/wakeup is that it is both lightweight (no need to create special data structures to act as sleep channels) and provides a layer of indirection (callers need not know which specific process they are interacting with).</p>
<h3 id="77-code-pipes">7.7 Code: Pipes<a class="headerlink" href="#77-code-pipes" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>ç®¡é“æ˜¯ä½¿ç”¨sleepå’Œwakeupæ¥å®žçŽ°è¿›ç¨‹åŒæ­¥çš„</p>
</blockquote>
<p>A more complex example that uses sleep and wakeup to synchronize producers and consumers is xv6â€™s implementation of pipes. We saw the interface for pipes in Chapter 1: bytes written to one end of a pipe are copied to an in-kernel buffer and then can be read from the other end of the pipe. Future chapters will examine the file descriptor support surrounding pipes, but letâ€™s look now at the implementations of <code>pipewrite</code> and <code>piperead</code>.</p>
<p>Each pipe is represented by a struct pipe, which contains a lock and a data buffer. The fields <code>nread</code> and <code>nwrite</code> count the total number of bytes read from and written to the buffer. The buffer wraps around: the next byte written after <code>buf[PIPESIZE-1]</code> is <code>buf[0]</code>. The counts do not wrap. This convention lets the implementation distinguish a <strong>full buffer (<code>nwrite == nread+PIPESIZE</code>)</strong> from an <strong>empty buffer (<code>nwrite == nread</code>),</strong> but it means that indexing into the buffer must use <code>buf[nread % PIPESIZE]</code> instead of just <code>buf[nread]</code> (and similarly for <code>nwrite</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">PIPESIZE</span><span class="p">];</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">nread</span><span class="p">;</span><span class="w">     </span><span class="c1">// number of bytes read</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">nwrite</span><span class="p">;</span><span class="w">    </span><span class="c1">// number of bytes written</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">readopen</span><span class="p">;</span><span class="w">   </span><span class="c1">// read fd is still open</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">writeopen</span><span class="p">;</span><span class="w">  </span><span class="c1">// write fd is still open</span>
<span class="p">};</span>
</code></pre></div>
<hr>
<p>Letâ€™s suppose that calls to <code>piperead</code> and <code>pipewrite</code> happen simultaneously on two different CPUs. <code>Pipewrite</code> (kernel/pipe.c:77) begins by acquiring the pipeâ€™s lock, which protects the counts, the data, and their associated invariants. <code>Piperead</code> (kernel/pipe.c:103) then tries to acquire the lock too, but cannot. It spins in acquire (kernel/spinlock.c:22) waiting for the lock. While <code>piperead</code> waits, <code>pipewrite</code> loops over the bytes being written (<code>addr[0..n-1]</code>), adding each to the pipe in turn (kernel/pipe.c:95). During this loop, it could happen that the buffer fills (kernel/pipe.c:85). In this case, <code>pipewrite</code> calls wakeup to alert any sleeping readers to the fact that there is data waiting in the buffer and then sleeps on <code>&amp;pi-&gt;nwrite</code> to wait for a reader to take some bytes out of the buffer. Sleep releases <code>pi-&gt;lock</code> as part of putting <code>pipewrite</code>â€™s process to sleep.</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span>
<span class="nf">pipewrite</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">pr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">readopen</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">PIPESIZE</span><span class="p">){</span><span class="w"> </span><span class="c1">//DOC: pipewrite-full</span>
<span class="w">      </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">copyin</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="o">++</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PIPESIZE</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span>
<span class="w">      </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">);</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">int</span>
<span class="nf">piperead</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">pr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">ch</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">writeopen</span><span class="p">){</span><span class="w">  </span><span class="c1">//DOC: pipe-empty</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w"> </span><span class="c1">//DOC: piperead-sleep</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w">  </span><span class="c1">//DOC: piperead-copy</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">)</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="n">ch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="o">++</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">PIPESIZE</span><span class="p">];</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">pr</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ch</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="p">);</span><span class="w">  </span><span class="c1">//DOC: piperead-wakeup</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Now that <code>pi-&gt;lock</code> is available, <code>piperead</code> manages to acquire it and enters its critical section: it finds that <code>pi-&gt;nread != pi-&gt;nwrite</code> (kernel/pipe.c:110) (<code>pipewrite</code> went to sleep because <code>pi-&gt;nwrite == pi-&gt;nread+PIPESIZE</code> (kernel/pipe.c:85)), so it falls through to the for loop, copies data out of the pipe (kernel/pipe.c:117), and increments <code>nread</code> by the number of bytes copied. That many bytes are now available for writing, so <code>piperead</code> calls wakeup (kernel/pipe.c:124) to wake any sleeping writers before it returns. Wakeup finds a process sleeping on <code>&amp;pi-&gt;nwrite</code>, the process that was running <code>pipewrite</code> but stopped when the buffer filled. It marks that process as RUNNABLE.</p>
<blockquote>
<p>ä¸‹é¢è¿™ä¸€éƒ¨åˆ†å¬è¯¾è¡¥å…… ä¸ºä»€ä¹ˆä¸¤ä¸ªchannelæ›´é«˜æ•ˆï¼Ÿæ²¡è¯´:(</p>
</blockquote>
<p><strong>The pipe code uses separate sleep channels for reader and writer</strong> (<code>pi-&gt;nread</code> and <code>pi-&gt;nwrite</code>); this might make the system more efficient in the unlikely event that there are lots of readers and writers waiting for the same pipe. The pipe code sleeps inside a loop checking the sleep condition; if there are multiple readers or writers, all but the first process to wake up will see the condition is still false and sleep again.</p>
<h3 id="78-code-wait-exit-and-kill">7.8 Code: Wait, exit, and kill<a class="headerlink" href="#78-code-wait-exit-and-kill" title="Permanent link">Â¶</a></h3>
<p><code>Sleep</code> and <code>wakeup</code> can be used for many kinds of waiting. An interesting example, introduced in Chapter 1, is the interaction between a childâ€™s <code>exit</code> and its parentâ€™s <code>wait</code>.</p>
<p>At the time of the childâ€™s death, the parent may already be sleeping in <code>wait</code>, or may be doing something else; in the latter case, a subsequent call to wait must observe the childâ€™s death, perhaps long after it calls <code>exit</code>.</p>
<ul>
<li>The way that xv6 records the childâ€™s <strong>demise(ç­äº¡)</strong> until wait observes it is for exit to put the caller into the ZOMBIE state, where it stays until the parentâ€™s wait notices it, changes the childâ€™s state to UNUSED, copies the childâ€™s exit status, and returns the childâ€™s process ID to the parent.</li>
<li>If <strong>the parent exits before the child</strong>, the parent gives the child to the <code>init process</code>, which <strong>perpetually(æ°¸è¿œ)</strong> calls wait; <u>thus every child has a parent to clean up after it</u>. The main implementation challenge is the possibility of races and deadlock between parent and child wait and exit, as well as exit and exit.</li>
</ul>
<hr>
<h4 id="wait">Wait<a class="headerlink" href="#wait" title="Permanent link">Â¶</a></h4>
<p><strong>Wait</strong> uses the calling processâ€™s <code>p-&gt;lock</code> as the condition lock to <strong>avoid lost wakeups</strong>, and it acquires that lock at the start (kernel/proc.c:398).</p>
<p>Then it <strong>scans the process table</strong>.</p>
<ul>
<li>
<p>If it finds a child in ZOMBIE state, it frees that childâ€™s resources and its proc structure, <strong>copies the childâ€™s exit status to the address supplied to wait</strong> (if it is not 0), and returns the childâ€™s process ID.</p>
</li>
<li>
<p>If wait finds children but none have exited, it calls sleep to wait for one of them to exit (kernel/proc.c:445), then scans again.</p>
</li>
</ul>
<blockquote>
<p>è¿™é‡Œå°±è¦è§£ç­”ç›´æŽ¥æå‡ºçš„sleepçš„ç‰¹æ®Šæƒ…å†µäº†ï¼šsleepä¸­ä¼ å…¥çš„condition lockæ˜¯è¿›ç¨‹é”æœ¬èº«æ€Žä¹ˆåŠž</p>
<p>// Wait for a child to exit.
<code>sleep(p, &amp;p-&gt;lock);  //DOC: wait-sleep</code></p>
<p>ä¸ºäº†é¿å…æ­»é”ï¼Œæˆ‘ä»¬å°±è¦ä¸¥æ ¼éµå®ˆä¸Šé”çš„é¡ºåºï¼Œå…ˆparentå†child</p>
</blockquote>
<p>Here, the condition lock being released in sleep is the waiting processâ€™s p-&gt;lock, the special case mentioned above. Note that wait often holds two locks; that it acquires its own lock before trying to acquire any childâ€™s lock; and that thus all of xv6 must obey the same locking order (parent, then child) in order to avoid deadlock.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Wait for a child process to exit and return its pid.</span>
<span class="c1">// Return -1 if this process has no children.</span>
<span class="kt">int</span>
<span class="nf">wait</span><span class="p">(</span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">np</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">havekids</span><span class="p">,</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// hold p-&gt;lock for the whole time to avoid lost</span>
<span class="w">  </span><span class="c1">// wakeups from a child's exit().</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="p">(;;){</span>
<span class="w">    </span><span class="c1">// Scan through table looking for exited children.</span>
<span class="w">    </span><span class="n">havekids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">np</span><span class="o">++</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// this code uses np-&gt;parent without holding np-&gt;lock.</span>
<span class="w">      </span><span class="c1">// acquiring the lock first would cause a deadlock,</span>
<span class="w">      </span><span class="c1">// since np might be an ancestor, and we already hold p-&gt;lock.</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// np-&gt;parent can't change between the check and the acquire()</span>
<span class="w">        </span><span class="c1">// because only the parent changes it, and we're the parent.</span>
<span class="w">        </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">        </span><span class="n">havekids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ZOMBIE</span><span class="p">){</span>
<span class="w">          </span><span class="c1">// Found one.</span>
<span class="w">          </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">addr</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">,</span>
<span class="w">                                  </span><span class="k">sizeof</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">          </span><span class="p">}</span>
<span class="w">          </span><span class="n">freeproc</span><span class="p">(</span><span class="n">np</span><span class="p">);</span>
<span class="w">          </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">          </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">          </span><span class="k">return</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// No point waiting if we don't have any children.</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">havekids</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="p">){</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Wait for a child to exit.</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="w">  </span><span class="c1">//DOC: wait-sleep</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Wait looks at every processâ€™s np-&gt;parent to find its children.</p>
<p><strong>It uses np-&gt;parent without holding np-&gt;lock, which is a violation of the usual rule that shared variables must be protected by locks.</strong></p>
<blockquote>
<p>è¿™åˆæœ‰ä¸€å¤„è¿åè§„åˆ™çš„åœ°æ–¹ï¼Œæˆ‘ä»¬åœ¨æ£€æŸ¥æ¯ä¸ªprocessçš„parentæ—¶å¹¶æ²¡æœ‰ç»™è¿™ä¸ªprocessä¸Šé”ã€‚å¦‚æžœä¸Šé”çš„è¯ï¼Œå¯èƒ½å¸¦æ¥ä¸€ä¸ªé—®é¢˜ï¼šä¹Ÿå°±æ˜¯å¦‚æžœ<code>np</code>æ˜¯å½“å‰è¿›ç¨‹çš„ç¥–å…ˆï¼Œè¿™æ ·çš„è¯æˆ‘ä»¬å¦‚æžœç»™<code>np</code>ä¸Šé”å°±ä¼šå¯¼è‡´å­è¿›ç¨‹pçš„é”åœ¨å…¶çˆ¶è¿›ç¨‹npä¹‹å‰è¢«èŽ·å¾—äº†ï¼Œè¿™å°±è¿åäº†èŽ·å¾—é”åº”è¯¥éµå®ˆçš„é¡ºåºã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">// å¦‚æžœæˆ‘ä»¬åœ¨ifåˆ¤æ–­å‰åŠ é”å¯èƒ½é‡åˆ°çš„æƒ…å†µ</span>
<span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">// child</span>
<span class="k">for</span><span class="p">(</span><span class="n">np</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">np</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">np</span><span class="o">++</span><span class="p">){</span>
<span class="w">      </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span><span class="c1">//parent</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">np</span><span class="o">-&gt;</span><span class="n">parent</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="p">){</span>
</code></pre></div>
<p>è¿™é‡Œæ²¡æœ‰é—®é¢˜çš„åŽŸå› æ˜¯ï¼š</p>
<ol>
<li>å­è¿›ç¨‹çš„parentåªèƒ½è¢«çˆ¶è¿›ç¨‹æ”¹å˜ï¼Œç„¶è€Œæˆ‘ä»¬å·²ç»æ‹¥æœ‰çˆ¶è¿›ç¨‹çš„é”äº†</li>
</ol>
</blockquote>
<p>It is possible that np is an ancestor of the current process, in which case acquiring np-&gt;lock could cause a deadlock since that would violate the order mentioned above. Examining np-&gt;parent without a lock seems safe in this case; a processâ€™s parent field is only changed by its parent, so if np-&gt;parent==p is true, the value canâ€™t change unless the current process changes it.</p>
<hr>
<h4 id="exit">Exit<a class="headerlink" href="#exit" title="Permanent link">Â¶</a></h4>
<p><strong>Exit</strong> (kernel/proc.c:333)</p>
<ol>
<li>
<p>records the exit status, frees some resources,</p>
</li>
<li>
<p>gives any children to the <code>init</code> process,</p>
</li>
<li>
<p>wakes up the parent in case it is in wait, marks the caller as a zombie, and permanently yields the CPU.</p>
</li>
</ol>
<blockquote>
<p>ä¸ºä»€ä¹ˆå­è¿›ç¨‹åœ¨æœ€åŽè®¾ç½®ZOMBIEå’Œwakeupå…¶çˆ¶è¿›ç¨‹æ—¶ä¸€ç›´æ‹¿ç€å®ƒparentçš„é”</p>
<p>çˆ¶è¿›ç¨‹çš„é”æ˜¯condition lockï¼Œæ²¡æœ‰ä»–çˆ¶è¿›ç¨‹å°±æ— æ³•è¿›å…¥forå¾ªçŽ¯å¼€å§‹å¯»æ‰¾å­è¿›ç¨‹</p>
<p>å­è¿›ç¨‹è‡ªå·±çš„é”ç”¨äºŽä¿è¯çˆ¶è¿›ç¨‹ä¸ä¼šçœ‹åˆ°è‡ªå·±æ˜¯ZOMBIEå°±å¼€å§‹<code>freeproc</code>ï¼Œ</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Give any children to init.</span>
<span class="w">  </span><span class="n">reparent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Parent might be sleeping in wait().</span>
<span class="w">  </span><span class="n">wakeup1</span><span class="p">(</span><span class="n">original_parent</span><span class="p">);</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZOMBIE</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div>
<p>**é”çš„èŽ·å¾—é¡ºåº**å¯¹äºŽ**é¿å…æ­»é”**æ˜¯éžå¸¸é‡è¦çš„ï¼Œwaitå’Œexitå°±æ˜¯ä¸€å¯¹å¯èƒ½å¼•å‘race conditionçš„è¿›ç¨‹ï¼Œä»–ä»¬å°±å¿…é¡»éµå¾ªåŒæ ·çš„èŽ·å¾—é”çš„é¡ºåº</p>
</blockquote>
<p>The final sequence is a little tricky. <strong>The exiting process must hold its parentâ€™s lock while it sets its state to ZOMBIE and wakes the parent up, since the parentâ€™s lock is the condition lock that guards against lost wakeups in wait.</strong> The child must also hold its own <code>p-&gt;lock</code>, since otherwise the parent might see it in state ZOMBIE and free it while it is still running. <strong>The lock <u>acquisition</u> order is important to avoid deadlock: since wait acquires the parentâ€™s lock before the childâ€™s lock, exit must use the same order.</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// Exit the current process.  Does not return.</span>
<span class="c1">// An exited process remains in the zombie state</span>
<span class="c1">// until its parent calls wait().</span>
<span class="kt">void</span>
<span class="nf">exit</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">initproc</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"init exiting"</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Close all open files.</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NOFILE</span><span class="p">;</span><span class="w"> </span><span class="n">fd</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]){</span>
<span class="w">      </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">];</span>
<span class="w">      </span><span class="n">fileclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">begin_op</span><span class="p">();</span>
<span class="w">  </span><span class="n">iput</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>
<span class="w">  </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// we might re-parent a child to init. we can't be precise about</span>
<span class="w">  </span><span class="c1">// waking up init, since we can't acquire its lock once we've</span>
<span class="w">  </span><span class="c1">// acquired any other proc lock. so wake up init whether that's</span>
<span class="w">  </span><span class="c1">// necessary or not. init may miss this wakeup, but that seems</span>
<span class="w">  </span><span class="c1">// harmless.</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">wakeup1</span><span class="p">(</span><span class="n">initproc</span><span class="p">);</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initproc</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// grab a copy of p-&gt;parent, to ensure that we unlock the same</span>
<span class="w">  </span><span class="c1">// parent we locked. in case our parent gives us away to init while</span>
<span class="w">  </span><span class="c1">// we're waiting for the parent lock. we may then race with an</span>
<span class="w">  </span><span class="c1">// exiting parent, but the result will be a harmless spurious wakeup</span>
<span class="w">  </span><span class="c1">// to a dead or wrong process; proc structs are never re-allocated</span>
<span class="w">  </span><span class="c1">// as anything else.</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">original_parent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// we need the parent's lock in order to wake it up from wait().</span>
<span class="w">  </span><span class="c1">// the parent-then-child rule says we have to lock it first.</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Give any children to init.</span>
<span class="w">  </span><span class="n">reparent</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Parent might be sleeping in wait().</span>
<span class="w">  </span><span class="n">wakeup1</span><span class="p">(</span><span class="n">original_parent</span><span class="p">);</span>

<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">xstate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">status</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ZOMBIE</span><span class="p">;</span>

<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">original_parent</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Jump into the scheduler, never to return.</span>
<span class="w">  </span><span class="n">sched</span><span class="p">();</span>
<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"zombie exit"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>Exit</code> calls a specialized wakeup function, <code>wakeup1</code>, that <strong>wakes up only the parent</strong>, and only if it is sleeping in wait (kernel/proc.c:598). It may look incorrect for the child to wake up the parent before setting its state to ZOMBIE, but that is safe: although <code>wakeup1</code> may cause the parent to run, the loop in wait cannot examine the child until the childâ€™s p-&gt;lock is released by scheduler, so wait canâ€™t look at the exiting process until well after exit has set its state to ZOMBIE (kernel/proc.c:386)</p>
<blockquote>
<p>åœ¨æˆ‘çœ‹æ¥è¿™é‡Œä½¿ç”¨wakeup1è¿™ç§è®¾è®¡æœ‰ç‚¹åƒæ˜¯ä¸ºäº†å…‹æœsleepçš„condition lockæ˜¯çˆ¶è¿›ç¨‹é”çš„å¼Šç«¯ï¼Œå¦‚æžœä¸ä½¿ç”¨wakeup1ï¼Œé‚£ä¹ˆçˆ¶è¿›ç¨‹è°ƒç”¨waitå°±è¦ç­‰åˆ°å­è¿›ç¨‹åœ¨è°ƒåº¦çº¿ç¨‹è¢«è§£é”æ—¶æ‰èƒ½æ‰§è¡Œã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Wake up p if it is sleeping in wait(); used by exit().</span>
<span class="c1">// Caller must hold p-&gt;lock.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">wakeup1</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holding</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"wakeup1"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">chan</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SLEEPING</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="kill">Kill<a class="headerlink" href="#kill" title="Permanent link">Â¶</a></h4>
<p>While exit allows a process to terminate itself, <strong>kill</strong> (kernel/proc.c:611) lets one process request that another terminate. It would be too complex for kill to directly destroy the victim process, since the victim might be executing on another CPU, perhaps in the middle of a sensitive sequence of updates to kernel data structures.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Kill the process with the given pid.</span>
<span class="c1">// The victim won't exit until it tries to return</span>
<span class="c1">// to user space (see usertrap() in trap.c).</span>
<span class="kt">int</span>
<span class="nf">kill</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proc</span><span class="p">;</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">proc</span><span class="p">[</span><span class="n">NPROC</span><span class="p">];</span><span class="w"> </span><span class="n">p</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">pid</span><span class="p">){</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SLEEPING</span><span class="p">){</span>
<span class="w">        </span><span class="c1">// Wake process from sleep().</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RUNNABLE</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Thus <strong>kill does very little: it just sets the victimâ€™s p-&gt;killed and, if it is sleeping, wakes it up</strong>.</p>
<p>Eventually the victim will enter or leave the kernel, at which point <strong>code in <code>usertrap</code> will call <code>exit</code> if p-&gt;killed is set</strong>.</p>
<ul>
<li>
<p>If the victim is running in user space, it will soon enter the kernel by making a system call or because the timer (or some other device) interrupts.</p>
</li>
<li>
<p>If the victim process is in sleep, <code>kill</code>â€™s call to <code>wakeup</code> will cause the victim to return from sleep.</p>
</li>
</ul>
<blockquote>
<p>killå¹¶ä¸èƒ½ç›´æŽ¥è®©ä¸€ä¸ªè¿›ç¨‹ç›´æŽ¥ç»“æŸï¼Œä»–åªèƒ½é€šè¿‡è°ƒåº¦çš„æ–¹å¼è®©killedè¿›ç¨‹åœ¨ä¸‹ä¸€æ¬¡è¢«è°ƒåº¦æ—¶è¢«æ€æ­»ã€‚æ€æ­»çš„æ–¹å¼å°±æ˜¯è®©ä»–è‡ªå·±è°ƒç”¨<code>exit()</code>é€€å‡ºã€‚</p>
<p>ä¸‹ä¸€æ¬¡çš„è°ƒåº¦å¯ä»¥å‘ç”Ÿåœ¨ä¸¤ä¸ªåœ°æ–¹</p>
<ol>
<li>ç”¨æˆ·ç©ºé—´ï¼Œtimerå°†è¯¥è¿›ç¨‹ä»Žç”¨æˆ·ç©ºé—´å¸¦å…¥<code>usertrap</code>ï¼Œç„¶åŽè¿›è¡Œkill</li>
<li>å†…æ ¸ç©ºé—´ï¼Œä»Žsleepä¸­è‹é†’ï¼Œè¢«sleepæ‰€åœ¨çš„forå¾ªçŽ¯æ€æ­»ï¼ˆsleepæ€»æ˜¯å¤„åœ¨forå¾ªçŽ¯ä¸­ï¼Œç”¨æ¥é¢„å¤‡è¿™ç§æƒ…å†µï¼‰</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(....)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">KILLED</span><span class="p">)</span>
<span class="w">        </span><span class="n">exit</span><span class="p">();</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
</blockquote>
<p><strong>This is potentially dangerous because the condition being waiting for may not be true.</strong> <u>However, xv6 calls to sleep are always wrapped in a while loop that re-tests the condition after sleep returns. Some calls to sleep also test p-&gt;killed in the loop, and abandon the current activity if it is set.</u> This is only done when such abandonment would be correct. For example, the pipe read and write code returns if the killed flag is set; eventually the code will return back to trap, which will again check the flag and exit.</p>
<blockquote>
<p>sleepä¸åœ¨forå¾ªçŽ¯ä¸­çš„ä¾‹å¤–</p>
</blockquote>
<p>Some xv6 sleep loops do not check <code>p-&gt;killed</code> <strong>because the code is in the middle of a multistep system call that should be atomic</strong>. The <code>virtio driver</code>(kernel/<code>virtio_disk.c</code>:242) is an example: it does not check <code>p-&gt;killed</code> because a disk operation may be one of a set of writes that are all needed in order for the file system to be left in a correct state.</p>
<p><strong>A process that is killed while waiting for disk I/O wonâ€™t exit until it completes the current system call and <code>usertrap</code> sees the killed flag.</strong></p>
<h3 id="79-real-world">7.9 Real world<a class="headerlink" href="#79-real-world" title="Permanent link">Â¶</a></h3>
<h4 id="different-scheduling-policy">Different scheduling policy<a class="headerlink" href="#different-scheduling-policy" title="Permanent link">Â¶</a></h4>
<p>The xv6 scheduler implements a simple scheduling policy, which runs each process in turn. This policy is called <strong>round robin</strong>.</p>
<p>Real operating systems implement more sophisticated policies that, for example, <strong>allow processes to have priorities</strong>. The idea is that a runnable high-priority process will be preferred by the scheduler over a runnable low-priority process.</p>
<hr>
<p>These policies can become complex quickly because there are often competing goals:</p>
<p>for example, the operating might also want to <u>guarantee fairness and high <strong>throughputï¼ˆåžåé‡ï¼‰</strong></u>. In addition, complex policies may lead to unintended interactions such as <strong>priority inversion and convoys</strong>.</p>
<ul>
<li><strong>Priority inversion</strong> can happen when a low-priority and high-priority process share a lock, which when acquired by the low-priority process can prevent the high-priority process from making progress.</li>
<li><strong>A long convoy(æŠ¤èˆªé˜Ÿ) of waiting processes</strong> can form when many high-priority processes are waiting for a low-priority process that acquires a shared lock; once a convoy has formed it can persist for long time. To avoid these kinds of problems additional mechanisms are necessary in sophisticated schedulers.</li>
</ul>
<hr>
<h4 id="different-synchronization-method">Different synchronization method<a class="headerlink" href="#different-synchronization-method" title="Permanent link">Â¶</a></h4>
<p><code>Sleep</code> and <code>wakeup</code> are a simple and effective <strong>synchronization method</strong>, but there are many others.</p>
<p>The first challenge in all of them is to avoid the <strong>â€œlost wakeupsâ€ problem</strong> we saw at the beginning of the chapter.</p>
<blockquote>
<p>sleepçš„ä¸åŒå®žçŽ°</p>
</blockquote>
<p>The original Unix kernelâ€™s sleep simply disabled interrupts, which sufficed(è¶³å¤Ÿ) because Unix ran on a single-CPU system. Because xv6 runs on multiprocessors, it adds an explicit lock to sleep. FreeBSDâ€™s <code>msleep</code> takes the same approach. Plan 9â€™s <code>sleep</code> uses a callback function that runs with the scheduling lock held just before going to sleep; the function serves as a last-minute check of the sleep condition, to avoid lost wakeups. <u>The Linux kernelâ€™s sleep uses an explicit process queue, called a wait queue, instead of a wait channel; the queue has its own internal lock.</u></p>
<blockquote>
<p>wakeupçš„ä¸åŒå®žçŽ°</p>
<p>ä¸€ç§è¢«å«åšconditional variableçš„æ•°æ®ç»“æž„</p>
</blockquote>
<p><strong>Scanning</strong> the entire process list in wakeup for processes with a matching <code>chan</code> is <strong>inefficient</strong>.</p>
<p><strong>A better solution is to replace the <code>chan</code> in both sleep and wakeup with a <u><code>data structure</code></u> that holds a list of processes sleeping on that structure, such as Linuxâ€™s wait queue.</strong> Plan 9â€™s sleep and wakeup call that structure a rendezvous point or <code>Rendez</code>. Many thread libraries refer to the same structure as a <strong>condition variable</strong>; in that context, the operations sleep and wakeup are called wait and signal. <u>All of these mechanisms share the same flavor: the sleep condition is protected by some kind of lock dropped atomically during sleep</u>.</p>
<blockquote>
<p>xv6 wakeup å”¤é†’å…¨éƒ¨ç­‰å¾…è¿›ç¨‹çš„é—®é¢˜</p>
<p>è§£å†³æ–¹æ¡ˆï¼šsignalå’Œbroadcast</p>
</blockquote>
<p>The implementation of <code>wakeup</code> wakes up all processes that are waiting on a particular channel, and it might be the case that many processes are waiting for that particular channel. The operating system will schedule all these processes and <strong>they will race to check the sleep condition</strong>. Processes that behave in this way are sometimes called a <strong>thundering herd</strong>, and it is best avoided.</p>
<p><strong>Most condition variables have two primitives for wakeup</strong>: <strong><code>signal</code></strong>, which wakes up one process, and <strong><code>broadcast</code></strong>, which wakes up all waiting processes.</p>
<hr>
<p><strong>Semaphores</strong> are often used for synchronization. The count typically corresponds to something like the number of bytes available in a pipe buffer or the number of zombie children that a process has. Using an explicit count as part of the abstraction avoids the â€œlost wakeupâ€ problem: there is an explicit count of the number of wakeups that have occurred. The count also avoids the spurious wakeup and thundering herd problems.</p>
<hr>
<h4 id="terminating-process">Terminating Process<a class="headerlink" href="#terminating-process" title="Permanent link">Â¶</a></h4>
<p>Terminating processes and cleaning them up introduces much complexity in xv6. In most operating systems it is even more complex, because, for example, the victim process may be deep inside the kernel sleeping, and unwindingï¼ˆå±•å¼€ï¼‰ its stack requires much careful programming. Many operating systems unwind the stack using explicit mechanisms for exception handling, such as <code>longjmp</code>.</p>
<p>Furthermore, there are other events that can cause a sleeping process to be woken up, even though the event it is waiting for has not happened yet. For example, when a Unix process is sleeping, another process may send a signal to it. In this case, the process will return from the interrupted system call with the value -1 and with the error code set to EINTR. The application can check for these values and decide what to do. Xv6 doesnâ€™t support signals and this complexity doesnâ€™t arise.</p>
<h4 id="kill-problem">Kill Problem<a class="headerlink" href="#kill-problem" title="Permanent link">Â¶</a></h4>
<p>Xv6â€™s support for kill is not entirely satisfactory: there are sleep loops which probably should check for p-&gt;killed. A related problem is that, <strong>even for sleep loops that check p-&gt;killed, there is a race between sleep and kill</strong>; the latter may set p-&gt;killed and try to wake up the victim just after the victimâ€™s loop checks p-&gt;killed but before it calls sleep. If this problem occurs, the victim wonâ€™t notice the p-&gt;killed until the condition it is waiting for occurs. This may be quite a bit later (e.g., when the <code>virtio</code> driver returns a disk block that the victim is waiting for) or never (e.g., if the victim is waiting from input from the console, but the user doesnâ€™t type any input).</p>
<hr>
<p>A real operating system would find free proc structures with an explicit free list in constant time instead of the linear-time search in <code>allocproc</code>; xv6 uses the linear scan for simplicity.</p>
<h2 id="chapter-8-file-system">Chapter 8 File system<a class="headerlink" href="#chapter-8-file-system" title="Permanent link">Â¶</a></h2>
<p>The purpose of a file system is to organize and store data. File systems typically support sharing of data among users and applications, as well as persistence so that data is still available after a reboot.</p>
<p>The xv6 file system provides Unix-like files, directories, and pathnames (see Chapter 1), and stores its data on a <code>virtio</code> disk for persistence (see Chapter 4). The file system addresses several <strong>challenges</strong>:</p>
<ul>
<li>
<p>The file system needs <strong>on-disk data structures</strong> to represent the tree of named directories and files, to record the identities of the blocks that hold each fileâ€™s content, and to record which areas of the disk are free.</p>
</li>
<li>
<p>The file system must support <strong>crash recovery</strong>. That is, if a crash (e.g., power failure) occurs, the file system must still work correctly after a restart. The risk is that a crash might interrupt a sequence of updates and leave inconsistent on-disk data structures (e.g., a block that is both used in a file and marked free).</p>
</li>
<li>
<p><strong>Different processes</strong> may <strong>operate</strong> on the file system at the <strong>same time</strong>, so the file-system code must coordinate to maintain invariants.</p>
</li>
<li>
<p>Accessing a disk is orders of magnitude slower than accessing memory, so the file system must maintain an <strong>in-memory cache of popular blocks</strong>.</p>
</li>
</ul>
<p>The rest of this chapter explains how xv6 addresses these challenges.</p>
<h3 id="81-overview">8.1 Overview<a class="headerlink" href="#81-overview" title="Permanent link">Â¶</a></h3>
<p>The xv6 file system implementation is organized in <strong>seven layers</strong>, shown in Figure 8.1.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220618234931008.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220618234931008" src="../../../../assets/Operating%20Systems.assets/image-20220618234931008.png"></a></p>
<ul>
<li>
<p>The <strong>disk layer</strong> reads and writes blocks on an <code>virtio</code> <u>hard drive</u>.</p>
</li>
<li>
<p>The <strong>buffer cache layer</strong> <u>caches disk blocks and synchronizes access to them</u>, making sure that only one kernel process at a time can modify the data stored in any particular block.</p>
</li>
<li>
<p>The <strong>logging layer</strong> allows <u>higher layers to wrap updates to several blocks in a transaction</u>, and ensures that the blocks are updated atomically in the face of crashes (i.e., all of them are updated or none).</p>
</li>
<li>
<p>The <strong><code>inode</code> layer</strong> <u>provides individual files</u>, each represented as an <code>inode</code> with a unique<code>i-number</code> and some blocks holding the fileâ€™s data.</p>
</li>
<li>
<p>The <strong>directory layer</strong> implements each <u>directory as a special kind of <code>inode</code> whose content is a sequence of directory entries</u>, each of which contains a fileâ€™s name and <code>i-number</code>.</p>
</li>
<li>
<p>The <strong>pathname layer</strong> provides <u>hierarchical path names</u> like <code>/usr/rtm/xv6/fs.c</code>, and resolves them with recursive lookup.</p>
</li>
<li>
<p>The <strong>file descriptor layer</strong> <u>abstracts many Unix resources</u> (e.g., pipes, devices, files, etc.) using the file system interface, simplifying the lives of application programmers.</p>
</li>
</ul>
<hr>
<p>The file system must have a plan for <strong>where it stores <code>inodes</code> and content blocks on the disk</strong>. To do so, xv6 divides the disk into several sections, as Figure 8.2 shows.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220618235633337.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220618235633337" src="../../../../assets/Operating%20Systems.assets/image-20220618235633337.png"></a></p>
<ul>
<li>
<p>The file system does not use <strong>block 0</strong> (it holds the <strong>boot sector</strong>).</p>
</li>
<li>
<p><strong>Block 1</strong> is called the <strong>superblock</strong>; it contains <strong>metadata about the file system</strong> (the file system size in blocks, the number of data blocks, the number of <code>inodes</code>, and the number of blocks in the log).</p>
</li>
<li>
<p>Blocks starting at 2 hold the <strong>log</strong>.</p>
</li>
<li>
<p>After the log are the <strong><code>inodes</code>,</strong> with multiple <code>inodes</code> per block.</p>
</li>
<li>
<p>After those come <strong>bitmap</strong> blocks <u>tracking which data blocks are in use</u>.</p>
</li>
<li>
<p>The remaining blocks are <strong>data blocks</strong>; each is either marked free in the bitmap block, or holds content for a file or directory.</p>
</li>
</ul>
<p>The superblock is filled in by a separate program, called <code>mkfs</code>, which builds an initial file system.</p>
<blockquote>
<p>super blockæ˜¯å¯¹æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„æè¿°ã€‚æˆ‘ä»¬åœ¨ä¹‹åŽè¿›è¡Œå®šä½<code>inode</code>ç­‰æ“ä½œçš„æ—¶å€™ï¼Œå°±éœ€è¦super blockæ¥å‘Šè¯‰æˆ‘ä»¬å…·ä½“çš„èµ·å§‹ä½ç½®åœ¨å“ªé‡Œã€‚</p>
<div class="highlight"><pre><span></span><code><span class="cp">#define ROOTINO  1   </span><span class="c1">// root i-number</span>
<span class="cp">#define BSIZE 1024  </span><span class="c1">// block size</span>
</code></pre></div>
<p>æ‰€æœ‰çš„æ–‡ä»¶å’Œæ–‡ä»¶å¤¹éƒ½æ˜¯ç”±<code>inode</code>æ•°æ®ç»“æž„æ¥è¡¨ç¤ºçš„ï¼Œæˆ‘ä»¬å®šä½<code>inode</code>ä¸»è¦æ˜¯é€šè¿‡å®ƒçš„ç¼–å·ï¼ˆä¾‹å¦‚xï¼‰ä½œä¸ºåç§»é‡ï¼Œåœ¨ä¸Šå›¾æ‰€ç¤ºçš„ç»“æž„å›¾ä¸­å®šä½ä»–æ‰€å¤„çš„Blockã€‚å…·ä½“çš„è®¡ç®—æ–¹å¼æ˜¯ï¼š<code>sperblock.inodestart + x * inode_size / BSIZE</code>ã€‚åœ¨<code>xv6</code>ä¸­ï¼Œä¸€ä¸ª<code>inode</code>çš„å¤§å°æ˜¯64KBï¼Œä¸€ä¸ªBlockçš„å¤§å°æ˜¯1024KBã€‚åœ¨ç£ç›˜ä¸Šï¼Œé€šå¸¸ç”¨Sectorä½œä¸ºç£ç›˜çš„æœ€å°è®¡é‡å•ä½ï¼Œ1 sector = 512KBã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Disk layout:</span>
<span class="c1">// [ boot block | super block | log | inode blocks |</span>
<span class="c1">//                                          free bit map | data blocks]</span>
<span class="c1">//</span>
<span class="c1">// mkfs computes the super block and builds an initial file system. The</span>
<span class="c1">// super block describes the disk layout:</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">superblock</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">magic</span><span class="p">;</span><span class="w">        </span><span class="c1">// Must be FSMAGIC</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">         </span><span class="c1">// Size of file system image (blocks)</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">nblocks</span><span class="p">;</span><span class="w">      </span><span class="c1">// Number of data blocks</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">ninodes</span><span class="p">;</span><span class="w">      </span><span class="c1">// Number of inodes.</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">nlog</span><span class="p">;</span><span class="w">         </span><span class="c1">// Number of log blocks</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">logstart</span><span class="p">;</span><span class="w">     </span><span class="c1">// Block number of first log block</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">inodestart</span><span class="p">;</span><span class="w">   </span><span class="c1">// Block number of first inode block</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">bmapstart</span><span class="p">;</span><span class="w">    </span><span class="c1">// Block number of first free map block</span>
<span class="p">};</span>
</code></pre></div>
<h3 id="82-buffer-cache-layer">8.2 Buffer cache layer<a class="headerlink" href="#82-buffer-cache-layer" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>Buffer cacheæ˜¯å¯¹æ•´ä¸ªæ–‡ä»¶ç³»ç»Ÿçš„ç¼“å­˜ï¼Œåœ¨å…¶ä¹‹ä¸Šçš„å±‚å¯ä»¥é€šè¿‡å®ƒæ›´å¿«çš„å’Œdiskè¿›è¡Œäº¤äº’ã€‚</p>
</blockquote>
<p>The buffer cache has two jobs:</p>
<ul>
<li>
<p>(1) <strong>synchronize access to disk blocks</strong> to ensure that</p>
</li>
<li>
<p>only one copy of a block is in memory and that</p>
</li>
<li>
<p>only one kernel thread at a time uses that copy;</p>
</li>
<li>
<p>(2) <strong>cache popular blocks</strong> so that they donâ€™t need to be re-read from the slow disk. The code is in <code>bio.c</code>.</p>
</li>
</ul>
<hr>
<p>The main interface exported by the buffer cache consists of <code>bread</code> and <code>bwrite</code>;</p>
<ul>
<li>
<p>the former**(<code>bread</code>)** <u>obtains a <code>buf</code> containing a copy of a block</u> which can be read or modified <u>in memory,</u> and</p>
</li>
<li>
<p>the latter**(<code>bwriter</code>)** writes a <u>modified buffer to the appropriate block</u> on the disk.</p>
</li>
<li>
<p>A kernel thread must <u>release a buffer by calling</u> <strong><code>brelse</code></strong> when it is done with it. The buffer cache uses a <strong>per-buffer sleep-lock</strong> to ensure that only one thread at a time uses each buffer (and thus each disk block); bread returns a locked buffer, and <code>brelse</code> releases the lock.</p>
</li>
</ul>
<hr>
<blockquote>
<p>å½“ä¸Šå±‚è¦ä½¿ç”¨æ²¡æœ‰ç¼“å­˜åœ¨bufferä¸Šçš„diskå†…å®¹æ—¶ï¼Œä½¿ç”¨LRUç®—æ³•å°†æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„bufferä¸­çš„å†…å®¹æ›¿æ¢ä¸ºä¸Šå±‚éœ€è¦çš„å†…å®¹ã€‚</p>
</blockquote>
<p>Letâ€™s return to the buffer cache. <strong>The buffer cache has a <u>fixed number of buffers</u> to hold disk blocks</strong>, which means that if the file system asks for a block that is not already in the cache, <u>the buffer cache must recycle a buffer currently holding some other block</u>. The buffer cache recycles the least recently used buffer for the new block. The assumption is that the least recently used buffer is the one least likely to be used again soon.</p>
<h3 id="83-code-buffer-cache">8.3 Code: Buffer cache<a class="headerlink" href="#83-code-buffer-cache" title="Permanent link">Â¶</a></h3>
<h4 id="buffer-cache-data-structure">Buffer Cache Data Structure<a class="headerlink" href="#buffer-cache-data-structure" title="Permanent link">Â¶</a></h4>
<p>The <strong>buffer cache</strong> is a <strong>doubly-linked list of buffers</strong>. The function <code>binit</code>, called by main (kernel/- main.c:27), initializes the list with the NBUF buffers in the static array <code>buf</code> (kernel/bio.c:43-52). <strong>All other access to the buffer cache refer to the linked list via <code>bcache.head</code>, not the <code>buf</code> array.</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="n">buf</span><span class="p">[</span><span class="n">NBUF</span><span class="p">];</span>

<span class="w">  </span><span class="c1">// Linked list of all buffers, through prev/next.</span>
<span class="w">  </span><span class="c1">// Sorted by how recently the buffer was used.</span>
<span class="w">  </span><span class="c1">// head.next is most recent, head.prev is least.</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="n">head</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">bcache</span><span class="p">;</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">binit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"bcache"</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Create linked list of buffers</span>
<span class="w">  </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">buf</span><span class="o">+</span><span class="n">NBUF</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">initsleeplock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"buffer"</span><span class="p">);</span>
<span class="w">    </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="buf-data-structure"><code>Buf</code> Data Structure<a class="headerlink" href="#buf-data-structure" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>ä¸€ä¸ªbufferä¸­åªèƒ½å­˜æ”¾ä¸€ä¸ªblockä¸­çš„å†…å®¹ï¼Œä¹Ÿå°±æ˜¯1024Bå¤§å°çš„å†…å®¹ã€‚</p>
</blockquote>
<p>A buffer has two state fields associated with it. The field valid indicates that the buffer contains a copy of the block. The field disk indicates that the buffer content has been handed to the disk, which may change the buffer (e.g., write data from the disk into data).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">valid</span><span class="p">;</span><span class="w">   </span><span class="c1">// has data been read from disk?</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">disk</span><span class="p">;</span><span class="w">    </span><span class="c1">// does disk "own" buf?</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">blockno</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">refcnt</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">prev</span><span class="p">;</span><span class="w"> </span><span class="c1">// LRU cache list</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="n">uchar</span><span class="w"> </span><span class="n">data</span><span class="p">[</span><span class="n">BSIZE</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>
<h4 id="bread"><code>Bread</code><a class="headerlink" href="#bread" title="Permanent link">Â¶</a></h4>
<p><strong><code>Bread</code></strong> (kernel/bio.c:93) calls <code>bget</code> to <u>get a buffer for the given sector</u> (kernel/bio.c:97). If the buffer needs to be read from disk, <code>bread</code> calls <code>virtio_disk_rw</code> to do that before returning the buffer.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Return a locked buf with the contents of the indicated block.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="o">*</span>
<span class="n">bread</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">blockno</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">virtio_disk_rw</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="sleep-lock"><code>Sleep-Lock</code><a class="headerlink" href="#sleep-lock" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>ä»Žä¸‹ä¸€å°èŠ‚çš„ä»£ç ä¸­å¯ä»¥çŸ¥é“ï¼Œ<code>Sleep-Lock</code>æ˜¯ç”¨æ¥ä¿è¯ä¸€ä¸ªbuffer cacheçš„å”¯ä¸€è¯»å†™æƒé™çš„ã€‚æ¯ä¸ªbuffer cacheéƒ½æœ‰ä¸€å—è‡ªå·±çš„<code>Sleep-Lock</code>ã€‚</p>
<p><u>æ—¢ç„¶sleep lockæ˜¯åŸºäºŽspinlockå®žçŽ°çš„ï¼Œä¸ºä»€ä¹ˆå¯¹äºŽblock cacheï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯sleep lockè€Œä¸æ˜¯spinlockï¼Ÿ</u></p>
<p>å¯¹äºŽ**spinlock**æœ‰å¾ˆå¤šé™åˆ¶ï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯**åŠ é”æ—¶ä¸­æ–­å¿…é¡»è¦å…³é—­**ã€‚</p>
<p>æ‰€ä»¥å¦‚æžœä½¿ç”¨spinlockçš„è¯ï¼Œå½“æˆ‘ä»¬å¯¹block cacheåšæ“ä½œçš„æ—¶å€™éœ€è¦æŒæœ‰é”ï¼Œ<strong>é‚£ä¹ˆæˆ‘ä»¬å°±æ°¸è¿œä¹Ÿä¸èƒ½ä»Žç£ç›˜æ”¶åˆ°æ•°æ®</strong>ã€‚æˆ–è®¸å¦ä¸€ä¸ªCPUæ ¸å¯ä»¥æ”¶åˆ°ä¸­æ–­å¹¶è¯»åˆ°ç£ç›˜æ•°æ®ï¼Œä½†æ˜¯å¦‚æžœæˆ‘ä»¬åªæœ‰ä¸€ä¸ªCPUæ ¸çš„è¯ï¼Œæˆ‘ä»¬å°±æ°¸è¿œä¹Ÿè¯»ä¸åˆ°æ•°æ®äº†ã€‚</p>
<p><strong>å‡ºäºŽåŒæ ·çš„åŽŸå› ï¼Œä¹Ÿä¸èƒ½åœ¨æŒæœ‰spinlockçš„æ—¶å€™è¿›å…¥sleepçŠ¶æ€</strong>ã€‚</p>
<p>æ‰€ä»¥è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨sleep lockã€‚<strong>sleep lockçš„ä¼˜åŠ¿å°±æ˜¯</strong>ï¼Œ</p>
<ul>
<li><strong>æˆ‘ä»¬å¯ä»¥åœ¨æŒæœ‰é”çš„æ—¶å€™ä¸å…³é—­ä¸­æ–­ï¼ˆæŒæœ‰çš„æ˜¯sleep lockè€Œä¸æ˜¯ä»–é‡Œè¾¹çš„spin lockï¼‰</strong>ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ç£ç›˜æ“ä½œçš„è¿‡ç¨‹ä¸­æŒæœ‰é”ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥é•¿æ—¶é—´æŒæœ‰é”ã€‚</li>
<li><strong>å½“æˆ‘ä»¬åœ¨ç­‰å¾…sleep lockçš„æ—¶å€™ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰è®©CPUä¸€ç›´ç©ºè½¬</strong>ï¼Œæˆ‘ä»¬é€šè¿‡sleepå°†CPUå‡ºè®©å‡ºåŽ»äº†ã€‚</li>
</ul>
<p>ä»”ç»†è¯´è¯´è¿™ä¸€å—çš„ä»£ç å§ï¼Œsleep locké‡Œè¾¹æœ‰ä¸€ä¸ªspin lockï¼Œè¿™ä¸ªspinlockä¿è¯äº†ä¸€æ¬¡åªæœ‰ä¸€ä¸ªprocesså¯ä»¥èŽ·å¾—å¯¹è¿™ä¸ªbuffer cacheçš„è®¿é—®æƒé™ã€‚ç„¶è€Œï¼Œå¦‚ä¸Šæ–‡æ‰€è¯´ï¼Œspin lockå¯¼è‡´ä¸­æ–­è¢«åœæ­¢ï¼Œæ‰€ä»¥è¯»å†™å°±æ— æ³•è¿›è¡Œã€‚äºŽæ˜¯å°±æœ‰äº†ä¸‹è¾¹è¿™ä¸ªå·§å¦™çš„è®¾è®¡ã€‚</p>
<p>å¯¹äºŽç¬¬ä¸€ä¸ªæ‹¿åˆ°spin lockçš„è¿›ç¨‹ï¼Œä»–ä¸ä¼šæ‰§è¡Œwhile loopï¼Œè€Œæ˜¯ç›´æŽ¥ç»™sleep lockä¸­çš„å±žæ€§lockedç½®ä¸º1ï¼ˆè¡¨ç¤ºä¸Šé”ï¼‰ï¼Œæœ€åŽé‡Šæ”¾æŽ‰spin lockï¼Œä»Žè€Œä½¿å¾—è¯»å†™æ“ä½œå¯ä»¥è¿›è¡Œã€‚</p>
<p>å¯¹äºŽå…¶ä»–æƒ³è¦è¯»å†™è¿™ä¸€å—buffer cacheçš„è¿›ç¨‹æ¥è¯´ï¼Œä»–ä»¬èƒ½èŽ·å¾—spin lockï¼Œç„¶è€Œï¼Œä»–ä»¬ä¼šè¿›å…¥whileå¾ªçŽ¯ï¼Œå› ä¸ºsleep lockä¸­çš„lockedä¸º1ã€‚æ­¤æ—¶ï¼Œè¿™ä¸€å—buffer cacheè¢«å…¶ä»–è¿›ç¨‹å æœ‰ï¼Œè€Œä¸”ä¸èƒ½ç¦æ­¢ä¸­æ–­ï¼Œæ‰€ä»¥whileå¾ªçŽ¯ä¸­åˆè°ƒç”¨äº†sleepå‡½æ•°å°†è¿™ä¸ªè¿›ç¨‹çš„spinlocké‡Šæ”¾ï¼Œå¹¶ä¸”è®©å‡ºCPUä¾›å…¶ä»–è¿›ç¨‹æ‰§è¡Œã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Long-term locks for processes</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">locked</span><span class="p">;</span><span class="w">       </span><span class="c1">// Is the lock held?</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lk</span><span class="p">;</span><span class="w"> </span><span class="c1">// spinlock protecting this sleep lock</span>

<span class="w">  </span><span class="c1">// For debugging:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">        </span><span class="c1">// Name of lock.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w">           </span><span class="c1">// Process holding lock</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">acquiresleep</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">releasesleep</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">wakeup</span><span class="p">(</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="bget"><code>Bget</code><a class="headerlink" href="#bget" title="Permanent link">Â¶</a></h4>
<p><strong><code>Bget</code></strong> (kernel/bio.c:59) scans the buffer list for a buffer with the given device and sector numbers (kernel/bio.c:65-73). If there is such a buffer, <code>bget</code> acquires the <strong>sleep-lock</strong> for the buffer. <code>Bget</code> then returns the locked buffer.</p>
<blockquote>
<p>è¿™é‡Œä½¿ç”¨äº†ç¡çœ é”ï¼Œç¡çœ é”çš„æœ¬è´¨æ˜¯æ—‹è½¬é”ï¼Œä½†æ˜¯ä»–å¹¶ä¸ä¼šä¸€ç›´whileå¾ªçŽ¯å ç”¨CPUã€‚</p>
<p>è¿™é‡Œä½¿ç”¨ç¡çœ é”çš„ç›®çš„å…¶å®žå°±æ˜¯ä¸ºäº†åœ¨è¿›è¡ŒIOçš„è¿‡ç¨‹ä¸­ï¼ŒæŠŠCPUè®©æ¸¡å‡ºåŽ»ï¼Œè€Œä¸æ˜¯è®©å½“å‰è¿›ç¨‹åœ¨CPUä¸Šä¸€ç›´ç­‰å¾…IOã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Long-term locks for processes</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">locked</span><span class="p">;</span><span class="w">       </span><span class="c1">// Is the lock held?</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lk</span><span class="p">;</span><span class="w"> </span><span class="c1">// spinlock protecting this sleep lock</span>

<span class="w">  </span><span class="c1">// For debugging:</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">;</span><span class="w">        </span><span class="c1">// Name of lock.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w">           </span><span class="c1">// Process holding lock</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">acquiresleep</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="o">*</span><span class="n">lk</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">lk</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">locked</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lk</span><span class="o">-&gt;</span><span class="n">lk</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>If there is no cached buffer for the given sector, <code>bget</code> must make one, possibly reusing a buffer that held a different sector. It scans the buffer list a second time, looking for a buffer that is not in use (<code>b-&gt;refcnt = 0</code>); any such buffer can be used.</p>
<p><code>Bget</code> edits the buffer metadata to record the new device and sector number and acquires its sleep-lock. Note that the assignment <code>b-&gt;valid = 0</code> ensures that <code>bread</code> will read the block data from disk rather than incorrectly using the bufferâ€™s previous contents.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Look through buffer cache for block on device dev.</span>
<span class="c1">// If not found, allocate a buffer.</span>
<span class="c1">// In either case, return locked buffer.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="o">*</span>
<span class="n">bget</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">blockno</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Is the block already cached?</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">blockno</span><span class="p">){</span>
<span class="w">      </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Not cached.</span>
<span class="w">  </span><span class="c1">// Recycle the least recently used (LRU) unused buffer.</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">prev</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>
<span class="w">      </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockno</span><span class="p">;</span>
<span class="w">      </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"bget: no buffers"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>It is important that</p>
<ul>
<li>
<p>there is at most one cached buffer per disk sector,</p>
</li>
<li>
<p>to ensure that readers see writes,</p>
</li>
<li>
<p>and because the file system uses locks on buffers for synchronization.</p>
</li>
</ul>
<p><code>Bget</code> ensures this invariant by holding the <code>bache.lock</code> continuously from the first loopâ€™s check of whether the block is cached through the second loopâ€™s declaration that the block is now cached (by setting dev, <code>blockno</code>, and <code>refcnt</code>). This causes the check for a blockâ€™s presence and (if not present) the designation of a buffer to hold the block to be atomic.</p>
<blockquote>
<p><code>bache.lock</code>è´¯ç©¿äº†å¯¹bufferçš„å±žæ€§çš„ä¿®æ”¹ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯æ¬¡åªæœ‰ä¸€ä¸ªè¿›ç¨‹å¯ä»¥å¯¹æ•´ä¸ªbuffer cacheè¿›è¡Œæ“ä½œã€‚ä»Žè€Œï¼Œä¿è¯äº†ä¸Šè¿°çš„ä¸‰ç‚¹è¦æ±‚ã€‚</p>
</blockquote>
<p>It is safe for <code>bget</code> to acquire the bufferâ€™s sleep-lock outside of the <code>bcache.lock</code> critical section, since the non-zero <code>b-&gt;refcnt</code> prevents the buffer from being re-used for a different disk block. The sleep-lock protects reads and writes of the blockâ€™s buffered content, while the <code>bcache.lock</code> protects information about which blocks are cached.</p>
<blockquote>
<p>å¯ä»¥çœ‹åˆ°sleep lockæ˜¯åœ¨<code>bache.lock</code>è¢«é‡Šæ”¾åŽæ‰åŽ»èŽ·å¾—çš„ï¼Œè¿™ä¼šä¸ä¼šå¯¼è‡´å½“å‰çš„bufferè¢«å½“ä½œå¯æ›¿æ¢çš„bufferè€Œè¢«ä½¿ç”¨ï¼Œä»Žè€Œè¿›ä¸€æ­¥å¯¼è‡´å½“å‰è¿›ç¨‹çš„bufferé‡Œçš„å†…å®¹ä¸æ˜¯è¿›ç¨‹ä¸€å¼€å§‹æƒ³è¦çš„å†…å®¹å‘¢ï¼Ÿå¹¶ä¸ä¼šè¿™æ ·ï¼Œå› ä¸ºå½“å‰è¿›ç¨‹ä½¿å¾—bufferçš„<code>refcnt++</code>ï¼Œä¹Ÿå°±æ˜¯å½“å‰bufferå¿…ç„¶å¤§äºŽç­‰äºŽä¸€ï¼Œæ‰€ä»¥ä¸å­˜åœ¨è¢«é‡Šæ”¾çš„é£Žé™©ã€‚</p>
<p><code>bache.lock</code>ä¿è¯äº†æ¯ä¸ªç¼“å­˜å±žæ€§çš„å‡†ç¡®æ€§ï¼ˆä¾‹å¦‚<code>refcnt, blockno....</code>ï¼‰ï¼Œsleep lockè¢«ç”¨æ¥ä¿è¯bufferä¸­å†…å®¹(<code>char[BSIZE] data</code>)ä¸ä¼šè¢«é”™è¯¯çš„ä¿®æ”¹ã€‚</p>
</blockquote>
<p>If all the buffers are busy, then too many processes are simultaneously executing file system calls; <code>bget</code> panics. A more graceful response might be to sleep until a buffer became free, though there would then be a possibility of deadlock.</p>
<hr>
<blockquote>
<p>æ¯ä¸ªbufferè¢«è¿”å›žç»™ä¸Šå±‚æ—¶ï¼Œä»–éƒ½æ‹¿ç€è‡ªå·±çš„sleep lockï¼Œåªæœ‰ä¸Šå±‚æ‰€å¤„çš„è¿›ç¨‹å¯ä»¥å¯¹bufferé‡Œçš„å†…å®¹è¿›è¡Œæ“ä½œã€‚è‹¥bufferä¸­çš„å†…å®¹è¢«æ”¹å˜äº†ï¼Œé‚£ä¹ˆä¸Šå±‚å¿…é¡»è°ƒç”¨<code>bwrite</code>æ¥å°†bufferä¸­çš„å†…å®¹å†™å›ždiskã€‚</p>
</blockquote>
<p>Once <code>bread</code> has read the disk (if needed) and returned the buffer to its caller, the caller has exclusive use of the buffer and can read or write the data bytes. <u>If the caller does modify the buffer, it must call <code>bwrite</code> to write the changed data to disk before releasing the buffer</u>.</p>
<h4 id="bwrite"><code>Bwrite</code><a class="headerlink" href="#bwrite" title="Permanent link">Â¶</a></h4>
<p><strong><code>Bwrite</code></strong> (kernel/bio.c:107) calls <code>virtio_disk_rw</code> to talk to the disk hardware.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Write b's contents to disk.  Must be locked.</span>
<span class="kt">void</span>
<span class="nf">bwrite</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"bwrite"</span><span class="p">);</span>
<span class="w">  </span><span class="n">virtio_disk_rw</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="brelse"><code>Brelse</code><a class="headerlink" href="#brelse" title="Permanent link">Â¶</a></h4>
<p><u>When the caller is done with a buffer, it must call <code>brelse</code> to release it.</u> (The name <code>brelse</code>, a shortening of b-release, is cryptic but worth learning: it originated in Unix and is used in BSD, Linux, and Solaris too.)</p>
<blockquote>
<p>åœ¨bufferè¢«è¿”å›žç»™ä¸Šå±‚ä¹‹åŽï¼Œå½“å‰çš„è¿›ç¨‹å§‹ç»ˆæ‹¥æœ‰ç€å¯¹bufferä¸­å†…å®¹çš„å”¯ä¸€ä½¿ç”¨æƒï¼Œå½“ä½¿ç”¨å®Œæ¯•åŽï¼Œå°±è¦é‡Šæ”¾ä¿è¯è¿™ä¸€åˆ‡çš„sleep lockã€‚</p>
<p>æŽ¥ç€ï¼Œå¦‚æžœå½“å‰bufferçš„<code>refcnt==0</code>ï¼Œé‚£å°±è¯æ˜Žå½“å‰çš„è¿™ä¸ªbufferæ˜¯æœ€è¿‘åˆšä½¿ç”¨å®Œçš„ï¼Œæˆ‘ä»¬æŠŠå®ƒæ”¾åœ¨é“¾è¡¨çš„å¤´éƒ¨ã€‚ç”±æ­¤æŽ¨æ–­ï¼Œé“¾è¡¨çš„å°¾éƒ¨å°±æ˜¯å¾ˆä¹…ä»¥å‰å°±ä½¿ç”¨å®Œçš„bufferã€‚</p>
</blockquote>
<p><strong><code>Brelse</code></strong> (kernel/bio.c:117) <strong>releases the sleep-lock</strong> and <strong>moves the buffer to the front of the linked list</strong> (kernel/bio.c:128-133). Moving the buffer causes the list to be ordered by how recently the buffers were used (meaning released): <strong>the first buffer in the list is the most recently used, and the last is the least recently used</strong>.</p>
<blockquote>
<p>è¿™æ—¶åè§‚<code>bget</code>, å¯ä»¥å‘çŽ°åœ¨å¯»æ‰¾bufferä¸­æ˜¯å¦å­˜æœ‰ä¸Šå±‚è¦çš„å†…å®¹æ—¶ï¼Œæ˜¯ä»Žå‰å¾€åŽæ‰«æï¼Œè¿™æ ·é‡åˆ°æœ€è¿‘ä½¿ç”¨è¿‡çš„å‡ çŽ‡å¤§ã€‚åœ¨å¯»æ‰¾è¦è¢«freeå¹¶æ›¿ä»£çš„bufferæ—¶ï¼Œæ˜¯ä»ŽåŽå‘å‰æ‰«æï¼Œè¿™æ ·é‡åˆ°LRUçš„æ¦‚çŽ‡æ›´å¤§ä¸€äº›ã€‚</p>
</blockquote>
<p>The two loops in <code>bget</code> take advantage of this: the scan for an existing buffer must process the entire list in the worst case, but checking the most recently used buffers first (starting at <code>bcache.head</code> and following next pointers) will reduce scan time when there is good locality of reference. The scan to pick a buffer to reuse picks the least recently used buffer by scanning backward (following <code>prev</code> pointers).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Release a locked buffer.</span>
<span class="c1">// Move to the head of the most-recently-used list.</span>
<span class="kt">void</span>
<span class="nf">brelse</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">holdingsleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"brelse"</span><span class="p">);</span>

<span class="w">  </span><span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="o">--</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// no one is waiting for it.</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
<span class="w">    </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
<span class="w">    </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="n">bcache</span><span class="p">.</span><span class="n">head</span><span class="p">.</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bcache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="87-code-block-allocator">8.7 Code: Block allocator<a class="headerlink" href="#87-code-block-allocator" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>8.3è®²çš„çš„éƒ½æ˜¯Memoryé‡Œå­˜å‚¨çš„ç¼“å­˜ï¼Œä½†æˆ‘ä»¬åœ¨å»ºç«‹æ–‡ä»¶çš„æ—¶å€™ï¼Œæ˜¯è¦åœ¨ç£ç›˜ä¸Šç»™æ¯ä¸ªæ–‡ä»¶åˆ†é…ä¸€äº›åœ°æ–¹çš„ã€‚æ“ä½œç³»ç»Ÿå°†ç£ç›˜æŠ½è±¡æˆäº†è®¸å¤šçš„BLOCK, å¹¶æŠŠå…¶ä¸­ä¸€ä¸ªBLOCKç”¨ä½œbitmapç”¨æ¥è®°å½•å“ªäº›BLOCKå·²ç»è¢«åˆ†é…äº†ã€‚</p>
<p>bitmapæ˜¯ä¸€ä¸ªBLOCK SIZEå¤§å°çš„å—ï¼Œä¹Ÿå°±æ˜¯1024Bï¼Œä»–çš„æ¯ä¸€ä½å¯¹åº”ç€ä¸€ä¸ªå—æ˜¯å¦è¢«ä½¿ç”¨ã€‚</p>
</blockquote>
<p>File and directory content is stored in disk blocks, which must be allocated from a free pool. xv6â€™s block allocator maintains a free <strong>bitmap</strong> on disk, with one bit per block.</p>
<ul>
<li>
<p>A zero bit indicates that the corresponding block is free;</p>
</li>
<li>
<p>a one bit indicates that it is in use.</p>
</li>
</ul>
<p>The program <strong><code>mkfs</code> sets the bits corresponding to the boot sector, superblock, log blocks, <code>inode</code> blocks, and bitmap blocks.</strong></p>
<hr>
<p>The block allocator provides two functions:</p>
<h4 id="balloc"><code>Balloc</code><a class="headerlink" href="#balloc" title="Permanent link">Â¶</a></h4>
<p><strong><code>balloc</code></strong> allocates a new disk block, and <strong><code>bfree</code></strong> frees a block.</p>
<blockquote>
<p>å…ˆæ¥çœ‹çœ‹ä»£ç ä¸­çš„ä¸€äº›åè¯çš„æ„æ€</p>
<p><code>sb.size</code>: super blockä¸­è®°è½½ç€ç³»ç»Ÿçš„æè¿°ä¿¡æ¯ï¼ŒsizeæŒ‡çš„æ˜¯æ€»çš„blockæ•°é‡</p>
<p><code>BPB</code>: Bitmap bits per block (BSIZE*8) = 1024 x 8bits</p>
<p><code>BBLOCK(b, sb) ((b)/BPB + sb.bmapstart)</code> : // Block of free map containing bit for block b</p>
</blockquote>
<p>The loop in <code>balloc</code> at (kernel/fs.c:71) considers every block, starting at block 0 up to <code>sb.size</code>, the number of blocks in the file system. It looks for a block whose bitmap bit is zero, indicating that it is free. If <code>balloc</code> finds such a block, it updates the bitmap and returns the block. For efficiency, the loop is split into two pieces.</p>
<p>The outer loop reads each block of bitmap bits.</p>
<p>The inner loop checks all BPB bits in a single bitmap block.</p>
<p><strong>The race that might occur if two processes try to allocate a block at the same time is prevented by the fact that the buffer cache only lets one process use any one bitmap block at a time.</strong></p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220716230656087.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220716230656087" src="../../../../assets/Operating%20Systems.assets/image-20220716230656087.png"></a></p>
<blockquote>
<p><code>Balloc</code>åœ¨å¤–å±‚å¾ªçŽ¯éåŽ†æ¯ä¸€ä¸ªå—ï¼Œä»£ç ä¸­bæ‰€ä»£è¡¨çš„å°±æ˜¯æ¯ä¸ªå—çš„èµ·å§‹åœ°å€</p>
<p><code>bp</code>åœ¨è¿™é‡Œåº”è¯¥æŒ‡å‘çš„æ˜¯bitmapçš„ç¼“å­˜ï¼Œ</p>
<p>å†…å¾ªçŽ¯éåŽ†bitmapä¸­çš„æ¯ä¸€ä¸ªä½ï¼Œæ‰¾åˆ°ä¸€ä¸ªç©ºä½åŽï¼Œè¿”å›ž<code>b + bi</code>, ä¹Ÿå°±æ˜¯BLOCKçš„åºå·ï¼ˆæŒ‰ç…§å›¾ä¸­çš„è®¾è®¡æ‰€æœ‰çš„ç¼–å·ã€‚ä¾‹å¦‚46ï¼‰</p>
<p>è¿™é‡Œè¿˜å­˜æœ‰è®¸å¤šä¸è¿žè´¯çš„åœ°æ–¹ã€‚æˆ‘çš„è§£è¯»å¯¹å—ï¼Ÿä¸ºä»€ä¹ˆè¦è®¾ç«‹ä¸¤ä¸ªforå¾ªçŽ¯å‘¢ï¼Ÿå†…å­˜é‡Œçš„æ•°æ®æ˜¯æ€Žæ ·è¢«å†™å›žç£ç›˜çš„å‘¢ï¼Ÿ<code>bread</code>ä¸­çš„<code>blockno</code>ç©¶ç«Ÿæ˜¯ä»¥bitä¸ºå•ä½è¿˜æ˜¯ä»¥å›¾ä¸­çš„åºå·ä¸ºå•ä½ï¼Ÿ<code>balloc</code>åˆ°åº•è¿”å›žäº†ä»€ä¹ˆï¼Ÿ</p>
<p>è¿™é‡Œç›®å‰æ— æ³•ç†æ¸…ï¼Œä½†**è¿™æ®µä»£ç æ‰€åšçš„äº‹æ˜¯å¾ˆæ˜Žç¡®çš„ï¼Œåœ¨bitmapä¸­æ‰¾åˆ°ä¸€ä¸ªç©ºé—²çš„blockï¼Œç„¶åŽå°†è¿™ä¸ªblockä»¥æŸç§å½¢å¼è¿”å›ž**ã€‚</p>
<p>è¿™é‡Œéœ€è¦åŽç»­çš„è¡¥å……ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate a zeroed disk block.`</span>
<span class="k">static</span><span class="w"> </span><span class="n">uint</span>
<span class="nf">balloc</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">bi</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>

<span class="w">  </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">BPB</span><span class="p">){</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">BBLOCK</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">sb</span><span class="p">));</span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">BPB</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bi</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sb</span><span class="p">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">bi</span><span class="o">++</span><span class="p">){</span>
<span class="w">      </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w">  </span><span class="c1">// Is block free?</span>
<span class="w">        </span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">m</span><span class="p">;</span><span class="w">  </span><span class="c1">// Mark block in use.</span>
<span class="w">        </span><span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">        </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">        </span><span class="n">bzero</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bi</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bi</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"balloc: out of blocks"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="bfree"><code>Bfree</code><a class="headerlink" href="#bfree" title="Permanent link">Â¶</a></h4>
<p><code>Bfree</code> (kernel/fs.c:90) finds the right bitmap block and clears the right bit. Again the exclusive use implied by <code>bread</code> and <code>brelse</code> avoids the need for explicit locking.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Free a disk block.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">bfree</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">bi</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>

<span class="w">  </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">BBLOCK</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">sb</span><span class="p">));</span>
<span class="w">  </span><span class="n">bi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BPB</span><span class="p">;</span>
<span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">bi</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"freeing free block"</span><span class="p">);</span>
<span class="w">  </span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[</span><span class="n">bi</span><span class="o">/</span><span class="mi">8</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;=</span><span class="w"> </span><span class="o">~</span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">  </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="88-inode-layer">8.8 <code>Inode</code> layer<a class="headerlink" href="#88-inode-layer" title="Permanent link">Â¶</a></h3>
<blockquote>
<p><code>Inode</code>æ˜¯å¯¹BLOCKçš„å†ä¸€æ¬¡æŠ½è±¡ï¼Œæˆ‘ä»¬ä¸å¯èƒ½ä»…ä»…æŠŠæ–‡ä»¶å­˜å‚¨åœ¨ä¸€ä¸ªBLOCKé‡Œè¾¹ï¼Œ<code>Inode</code>å°±æ˜¯ä¸€ä¸ªBLOCKçš„é›†åˆï¼Œè®©æˆ‘ä»¬å¯ä»¥å­˜å‚¨æ›´å¤§çš„æ–‡ä»¶ã€‚</p>
</blockquote>
<p>The term <code>inode</code> can have one of <strong>two related meanings</strong>.</p>
<ul>
<li>
<p>It might refer to the <strong>on-disk data structure</strong> containing a fileâ€™s size and list of data block numbers. Or</p>
</li>
<li>
<p><code>â€œinodeâ€</code> might refer to an <strong><code>in-memory inode</code>,</strong> which contains a copy of the on-disk <code>inode</code> as well as extra information needed within the kernel.</p>
</li>
</ul>
<h4 id="on-disk-inodes"><strong>on-disk <code>inodes</code></strong><a class="headerlink" href="#on-disk-inodes" title="Permanent link">Â¶</a></h4>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/image-20220716230656087.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/image-20220716230656087.png" alt="image-20220716230656087" style="zoom:50%;"></a></p>
<blockquote>
<p><strong>on-disk <code>inodes</code></strong> å­˜å‚¨åœ¨BLOCK32 â†’ BLOCK44ä¹‹é—´ï¼Œæ¯ä¸ª**on-disk <code>inodes</code>** éƒ½æœ‰ç€å›ºå®šçš„å¤§å°64Bï¼Œä»Žè€Œï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“Xv6æ“ä½œç³»ç»Ÿèƒ½æœ‰å¤šå°‘**on-disk <code>inodes</code>** ï¼Œæ¢å¥è¯è¯´å°±æ˜¯èƒ½åˆ›å»ºå¤šå°‘ä¸ªæ–‡ä»¶ã€‚</p>
</blockquote>
<p>The <strong>on-disk <code>inodes</code></strong> are packed into a <strong>contiguous area of disk called the <code>inode blocks</code>.</strong> Every <code>inode</code> is the <strong>same size</strong>, so it is easy, given a number n, to find the <code>nth inode</code> on the disk. In fact, this number n, called the**<code>inode number</code> or <code>i-number</code>,** is how <code>inodes</code> are <strong>identified</strong> in the implementation.</p>
<hr>
<p>The on-disk <code>inode</code> is defined by a struct <code>dinode</code> (kernel/fs.h:32).</p>
<ul>
<li>
<p>The <strong>type</strong> field distinguishes between <strong>files, directories, and special files (devices)</strong>. A <strong>type of zero indicates that an on disk<code>inode</code> is free</strong>.</p>
</li>
<li>
<p>The <strong><code>nlink</code></strong> field counts the number of directory entries that refer to this <code>inode</code>, in order to recognize when the on-disk <code>inode</code> and its data blocks should be freed.</p>
</li>
<li>
<p>The <strong>size</strong> field records the number of bytes of content in the file.</p>
</li>
<li>
<p>The <strong><code>addrs</code></strong> array records the <strong>block numbers of the disk blocks holding the fileâ€™s content</strong>.</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="c1">// On-disk inode structure</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">           </span><span class="c1">// File type</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">major</span><span class="p">;</span><span class="w">          </span><span class="c1">// Major device number (T_DEVICE only)</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span><span class="w">          </span><span class="c1">// Minor device number (T_DEVICE only)</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">nlink</span><span class="p">;</span><span class="w">          </span><span class="c1">// Number of links to inode in file system</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">            </span><span class="c1">// Size of file (bytes)</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w">   </span><span class="c1">// Data block addresses</span>
<span class="p">};</span>
</code></pre></div>
<hr>
<h4 id="in-memory-inode">in-memory <code>inode</code><a class="headerlink" href="#in-memory-inode" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>å†…å­˜ä¸­çš„<code>inodes</code>å¤šäº†ä¸€äº›æ–°ç‰¹æ€§ï¼Œåªæœ‰CæŒ‡é’ˆæŒ‡å‘çš„ <code>inodes</code>æ‰æœ‰èµ„æ ¼è¢«åŠ è½½åˆ°å†…å­˜ä¸­ã€‚</p>
</blockquote>
<p>The kernel keeps the set of active <code>inodes</code> in memory; <strong>struct <code>inode</code> (kernel/file.h:17) is the in-memory copy of a struct <code>dinode</code> on disk</strong>.</p>
<p>The kernel stores an <code>inode</code> in memory only if there are C pointers referring to that <code>inode</code>.</p>
<p>The <strong>ref</strong> field counts the <strong>number of C pointers</strong> referring to the in-memory <code>inode</code>, and the kernel discards the <code>inode</code> from memory if the reference count drops to zero.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// in-memory copy of an inode</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span><span class="w">           </span><span class="c1">// Device number</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span><span class="w">          </span><span class="c1">// Inode number</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w">            </span><span class="c1">// Reference count</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">sleeplock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span><span class="w"> </span><span class="c1">// protects everything below here</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">valid</span><span class="p">;</span><span class="w">          </span><span class="c1">// inode has been read from disk?</span>

<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">         </span><span class="c1">// copy of disk inode</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">major</span><span class="p">;</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">nlink</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>
<p>The <strong><code>iget</code> and <code>iput</code></strong> functions <strong>acquire and release pointers</strong> to an <code>inode</code>, modifying the reference count. Pointers to an <code>inode</code> can come from file descriptors, current working directories, and transient kernel code such as <code>exec</code>.</p>
<hr>
<h4 id="lock-in-inode">Lock in <code>Inode</code><a class="headerlink" href="#lock-in-inode" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>å› ä¸º<code>inodes</code>åœ¨å†…æ ¸ä¸­ä¹Ÿä¼šè¢«ç¼“å­˜ï¼Œæ‰€ä»¥å’Œbuffer cacheå¾ˆç›¸ä¼¼ï¼Œ<code>inodes</code>ä¹Ÿæœ‰ä¸€æŠŠå¤§é”ç”¨æ¥ä¿è¯<code>inodes</code>çš„åŽŸå­æ€§ï¼ˆå†…å­˜ä¸­ä¸ä¼šæœ‰é‡å¤çš„<code>inodes</code>ï¼Œå†…æ ¸å¯¹<code>inodes</code>çš„å¼•ç”¨è®¡æ•°ä¹Ÿæ˜¯æ­£ç¡®çš„ï¼‰ã€‚æ¯ä¸ª<code>inodes</code>é‡Œè¾¹ä¹Ÿæœ‰ä¸€æŠŠå°é”ï¼ˆç¡çœ é”ï¼‰ï¼Œç”¨æ¥ä¿è¯è¯¥æ–‡ä»¶çš„ç‹¬äº«è®¿é—®æƒé™ã€‚</p>
</blockquote>
<p>There are <strong>four lock or lock-like mechanisms</strong> in xv6â€™s <code>inode</code> code.</p>
<p><strong><code>icache.lock</code></strong> protects the invariant that an <code>inode</code> is present in the cache at most once, and the invariant that a cached <code>inodeâ€™s</code> ref field counts the number of in-memory pointers to the cached <code>inode</code>.</p>
<p>Each in-memory <code>inode</code> has a lock field containing a <strong>sleep-lock</strong>, which ensures exclusive access to the <code>inodeâ€™s</code> fields (such as file length) as well as to the <code>inodeâ€™s</code> file or directory content blocks.</p>
<blockquote>
<p>ä¸€ä¸ªåœ¨å†…å­˜ä¸­çš„<code>inode</code>, å¦‚æžœä»–çš„refï¼ˆæŒ‡å‘<code>inode</code>çš„CæŒ‡é’ˆçš„æ•°é‡ï¼‰å¤§äºŽ0ï¼Œé‚£ä¹ˆå†…æ ¸å°±è¦åœ¨å†…å­˜ä¸­ç»´æŠ¤è¿™ä¸ª<code>inode</code>å¹¶ä¸”ä¸ä¼šé‡ç”¨è¿™ä¸ª<code>inode</code>çš„cache entryã€‚</p>
<p><code>nlink</code>è®°å½•çš„æ˜¯æŒ‡å‘è¿™ä¸ªæ–‡ä»¶çš„æ–‡ä»¶å¤¹çš„ä¸ªæ•°ï¼Œåªæœ‰<code>nlink</code>ä¸º0çš„æ—¶å€™ï¼Œç³»ç»Ÿæ‰ä¼šfreeè¿™ä¸ª<code>inode</code>ã€‚</p>
</blockquote>
<p>An <code>inodeâ€™s</code> ref, if it is greater than zero, causes the system to maintain the <code>inode</code> in the cache, and not re-use the cache entry for a different <code>inode</code>. Finally, each <code>inode</code> contains a <code>nlink</code> field (on disk and copied in memory if it is cached) that counts the number of directory entries that refer to a file; xv6 wonâ€™t free an <code>inode</code> if its link count is greater than zero.</p>
<hr>
<h4 id="life-cycle-of-inode">Life Cycle of <code>inode</code><a class="headerlink" href="#life-cycle-of-inode" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>æˆ‘ä»¬èŽ·å–åˆ°çš„å†…å­˜ä¸­çš„<code>inodes</code>å¦‚ä¸‹ç‰¹æ€§ã€‚</p>
<p>æ¯ä¸ªè¿›ç¨‹éƒ½å¯ä»¥æŒ‡å‘åŒä¸€ä¸ª<code>inodes</code>ï¼Œè¿™ç§è®¾è®¡æœ‰ç‚¹è¯»å†™é”çš„æ„æ€ï¼Œæˆ‘ä»¬åœ¨ç”¨æ–‡ä»¶ç³»ç»Ÿçš„æ—¶å€™ï¼Œä¼šç»å¸¸åœ¨ç›¸åŒçš„è·¯å¾„ä¸‹æ‰¾ä¸åŒçš„æ–‡ä»¶ï¼Œå¦‚æžœè®¾ç½®é”çš„è¯ï¼Œé‚£ä¹ˆå¦‚æžœæˆ‘ä»¬æ‰“å¼€äº†è·¯å¾„a/b/cï¼Œé‚£ä¹ˆå…¶ä»–ä»»ä½•è¿›ç¨‹éƒ½æ— æ³•å†è®¿é—®è¿™ä¸ªè·¯å¾„äº†ã€‚</p>
<p>å½“ç„¶ï¼Œåœ¨å¯¹<code>inodes</code>è¿›è¡Œå†™çš„æ“ä½œæ—¶ï¼Œä¾‹å¦‚ï¼šåŠ è½½diskçš„å†…å®¹åˆ°<code>inodes</code>ä»¥åŠå†™å…¥<code>inodes</code>ï¼Œåªæœ‰ä¸€ä¸ªè¿›ç¨‹å¯ä»¥ç‹¬äº«è¿™ä¸ªèµ„æºã€‚</p>
</blockquote>
<p>A struct <code>inode</code> pointer returned by <code>iget()</code> is guaranteed to be valid until the corresponding call to <code>iput()</code>; the <code>inode</code> wonâ€™t be deleted, and the memory referred to by the pointer wonâ€™t be re-used for a different <code>inode</code>.</p>
<p><code>iget()</code> provides <strong>non-exclusive access to an <code>inode</code></strong>, so that <strong>there can be many pointers to the same <code>inode</code>.</strong> Many parts of the file-system code depend on this behavior of <code>iget()</code>, both to hold long-term references to <code>inodes</code> (as open files and current directories) and to prevent races while avoiding deadlock in code that manipulates multiple <code>inodes</code> (such as pathname lookup).</p>
<p>The struct <code>inode</code> that <code>iget</code> returns may not have any useful content. In order to ensure it holds a copy of the <code>on-disk inode</code>, code must call <code>ilock</code>. This locks the <code>inode</code> (so that no other process can <code>ilock</code> it) and reads the <code>inode</code> from the disk, if it has not already been read. <code>iunlock</code>releases the lock on the <code>inode</code>. Separating acquisition of <code>inode</code> pointers from locking helps avoid deadlock in some situations, for example during directory lookup. Multiple processes can hold a C pointer to an <code>inode</code> returned by <code>iget</code>, but <strong>only one process can lock the <code>inode</code> at a time.</strong></p>
<hr>
<blockquote>
<p>å†…å­˜ä¸­çš„<code>inodes</code>ç›®çš„å¹¶ä¸åœ¨äºŽç¼“å­˜ï¼Œè€Œåœ¨äºŽåŒæ­¥ä¸åŒè¿›ç¨‹å¯¹èµ„æºçš„è¯·æ±‚ã€‚</p>
<p><code>inodes</code>ç¼“å­˜çš„å¦ä¸€å¤§ç‰¹ç‚¹æ˜¯å†™å®Œå°±è¦åŒæ­¥åˆ°disk</p>
</blockquote>
<p>The <code>inode</code> cache only caches <code>inodes</code> to which kernel code or data structures hold C pointers. <strong>Its main job is really synchronizing access by multiple processes</strong>; caching is secondary. If an <code>inode</code> is used frequently, the buffer cache will probably keep it in memory if it isnâ€™t kept by the <code>inode</code> cache. The <code>inode</code> cache is <strong>write-through</strong>, which means that <strong>code that modifies a cached <code>inode</code> must immediately write it to disk with <code>iupdate</code>.</strong></p>
<h3 id="89-code-inodes">8.9 Code: <code>Inodes</code><a class="headerlink" href="#89-code-inodes" title="Permanent link">Â¶</a></h3>
<h4 id="ialloc"><code>ialloc</code><a class="headerlink" href="#ialloc" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>ialloc</code> å°±æ˜¯åˆ›å»ºæ–‡ä»¶å®žçŽ°ï¼Œå®ƒçš„åŽŸç†å¾ˆç®€å•ï¼ŒæŠŠdiskä¸Š<code>inodes</code>é‚£ä¸€æ®µBLOCKåŠ è½½åˆ°buffer cacheä¸­ï¼Œç„¶åŽåœ¨å…¶ä¸­æ‰¾åˆ°ä¸€ä¸ªç©ºé—²çš„<code>inodes</code></p>
<p>æŽ¥ç€å°±æ”¹å˜<code>inodes</code>çš„å±žæ€§typeè¡¨æ˜Žå®ƒå·²ç»è¢«å ç”¨</p>
<p>æœ€åŽç”¨<code>iget()</code>æ–¹æ³•è¿”<code>inodes</code>åœ¨å†…å­˜ä¸­çš„ç¼“å­˜</p>
<p>è¿™é‡Œï¼Œå¹¶æ²¡æœ‰ç”¨åˆ°é”ï¼Œå› ä¸ºbuffer cacheä¿è¯äº†æ¯æ¬¡åªæœ‰ä¸€ä¸ªprocesså¯ä»¥ä¿®æ”¹ä¸€ä¸ªblock</p>
</blockquote>
<p>To allocate a new <code>inode</code> (for example, when creating a file), xv6 calls <code>ialloc</code> (kernel/fs.c:196). <code>Ialloc</code> is similar to <code>balloc</code>:</p>
<ul>
<li>
<p>it loops over the <code>inode</code> structures on the disk, one block at a time, <strong>looking for one that is marked free.</strong></p>
</li>
<li>
<p>When it finds one, it <strong>claims it by writing the new type to the disk</strong> and then</p>
</li>
<li>
<p><strong>returns an entry from the <code>inode</code> cache</strong> with the tail call to <code>iget</code> (kernel/fs.c:210).</p>
</li>
</ul>
<p>The correct operation of <code>ialloc</code> depends on the fact that only one process at a time can be holding a reference to <code>bp</code>: <code>ialloc</code> can be sure that some other process does not simultaneously see that the <code>inode</code> is available and try to claim it.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate an inode on device dev.</span>
<span class="c1">// Mark it as allocated by  giving it type type.</span>
<span class="c1">// Returns an unlocked but allocated and referenced inode.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">ialloc</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="w"> </span><span class="o">*</span><span class="n">dip</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">inum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">inum</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">sb</span><span class="p">.</span><span class="n">ninodes</span><span class="p">;</span><span class="w"> </span><span class="n">inum</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">IBLOCK</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span><span class="w"> </span><span class="n">sb</span><span class="p">));</span>
<span class="w">    </span><span class="n">dip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">inum</span><span class="o">%</span><span class="n">IPB</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span><span class="w">  </span><span class="c1">// a free inode</span>
<span class="w">      </span><span class="n">memset</span><span class="p">(</span><span class="n">dip</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dip</span><span class="p">));</span>
<span class="w">      </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">      </span><span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span><span class="w">   </span><span class="c1">// mark it allocated on the disk</span>
<span class="w">      </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">iget</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">inum</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"ialloc: no inodes"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="iget"><code>Iget</code><a class="headerlink" href="#iget" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>ä¹¦æŽ¥ä¸Šæ–‡ï¼Œä¸Šä¸€æ­¥ï¼Œæˆ‘ä»¬åœ¨<code>inode</code> BLOCKä¸­æ‹¿åˆ°äº†ä¸€ä¸ªæ–°çš„<code>inode</code>ï¼Œæˆ‘ä»¬ä¸‹ä¸€æ­¥è¦åšçš„å°±æ˜¯æŠŠè¿™ä¸ªæ–°çš„<code>inode</code>æ”¾è¿›<code>inode</code> ç¼“å­˜ä¸­ã€‚ï¼ˆXv6ç»´æŠ¤äº†ä¸¤ä¸ªç¼“å­˜ï¼Œä¸€ä¸ªæ˜¯BLOCKçš„ç¼“å­˜ï¼Œå¦ä¸€ä¸ªæ˜¯<code>inode</code>çš„ç¼“å­˜ï¼Œå…·ä½“æŸ¥çœ‹8.3ï¼Œ8.7)ã€‚</p>
<p>è¿™é‡Œå…¶å®žé€»è¾‘ä¹Ÿå¾ˆç®€å•ï¼Œå¦‚æžœæœ‰çš„è¯å°±è¿”å›žï¼Œæ²¡æœ‰çš„è¯å°±æ‰¾ä¸€ä¸ªæœ‰ç©ºé—²ä½ç½®çš„ç¼“å­˜ç”¨äºŽå­˜æ”¾è¿™ä¸ªæ–°çš„<code>inode</code>ã€‚</p>
</blockquote>
<p><code>Iget</code> (kernel/fs.c:243) looks through the <code>inode</code> cache for an active entry (<code>ip-&gt;ref &gt; 0</code>) with the desired device and <code>inode</code> number. If it finds one, it returns a new reference to that <code>inode</code> (kernel/fs.c:252-256). <strong>As <code>iget</code> scans, it records the position of the first empty slot (kernel/fs.c:257- 258), which it uses if it needs to allocate a cache entry.</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// Find the inode with number inum on device dev</span>
<span class="c1">// and return the in-memory copy. Does not lock</span>
<span class="c1">// the inode and does not read it from disk.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">iget</span><span class="p">(</span><span class="n">uint</span><span class="w"> </span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">empty</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Is the inode already cached?</span>
<span class="w">  </span><span class="n">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">inode</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">inode</span><span class="p">[</span><span class="n">NINODE</span><span class="p">];</span><span class="w"> </span><span class="n">ip</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">inum</span><span class="p">){</span>
<span class="w">      </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">    </span><span class="c1">// Remember empty slot.</span>
<span class="w">      </span><span class="n">empty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Recycle an inode cache entry.</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">empty</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"iget: no inodes"</span><span class="p">);</span>

<span class="w">  </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">empty</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="ilock"><code>ilock</code><a class="headerlink" href="#ilock" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>åœ¨Buffer Cacheä¸­å¯ä»¥å¾—çŸ¥ï¼Œé‡åˆ°æœ‰ç¼“å­˜çš„é—®é¢˜ï¼Œæˆ‘ä»¬å°±è¦æƒ³åŠžæ³•è§£å†³å¤šçº¿ç¨‹çš„é—®é¢˜ã€‚è¿™ä¸€èŠ‚çš„å‰ä¸€éƒ¨åˆ†ï¼Œæˆ‘ä»¬çŸ¥é“ï¼Œ<code>inode</code> cacheå¤–è¾¹æœ‰æŠŠå¤§é”ï¼Œæ¯ä¸ª<code>inode</code>ç¼“å­˜ä¸­æœ‰æŠŠå°é”ã€‚è¿™ä¸ª<code>ilock</code>å°±æ˜¯é‚£ä¸ªå°é”ï¼Œä»–çš„æœ¬è´¨æ˜¯ä¸€ä¸ªsleep lockã€‚</p>
<p><code>ilock</code>çš„å·¥ä½œå†…å®¹æ˜¯æŠŠdiské‡Œ<code>dinode</code>çš„å†…å®¹è¯»åˆ°ç¼“å­˜ä¸­çš„<code>inode</code>é‡Œè¾¹åŽ»ã€‚</p>
<p>ç›®å‰è¿˜ä¸æ˜¯å¾ˆæ˜Žç™½ä»–çš„åº”ç”¨åœºæ™¯åœ¨å“ªé‡Œ</p>
<p>åŽç»­è¡¥å……ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
</blockquote>
<p>Code must lock the <code>inode</code> using <code>ilock</code> before reading or writing its metadata or content.</p>
<p><code>ilock</code> (kernel/fs.c:289) uses a <code>sleep-lock</code> for this purpose.</p>
<p>Once <code>ilock</code> has exclusive access to the <code>inode</code>, it reads the <code>inode</code> from disk (more likely, the buffer cache) if needed. The function <code>iunlock</code> (kernel/fs.c:317) releases the sleep-lock, which may cause any processes sleeping to be woken up.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Lock the given inode.</span>
<span class="c1">// Reads the inode from disk if necessary.</span>
<span class="kt">void</span>
<span class="nf">ilock</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="w"> </span><span class="o">*</span><span class="n">dip</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"ilock"</span><span class="p">);</span>

<span class="w">  </span><span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">IBLOCK</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span><span class="w"> </span><span class="n">sb</span><span class="p">));</span>
<span class="w">    </span><span class="n">dip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="o">%</span><span class="n">IPB</span><span class="p">;</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">;</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">minor</span><span class="p">;</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="p">;</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="w">    </span><span class="n">memmove</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">,</span><span class="w"> </span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">));</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"ilock: no type"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="iput"><code>Iput</code><a class="headerlink" href="#iput" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>Iput</code>æ¶‰åŠçš„æ˜¯<code>inode</code>ç¼“å­˜çš„é‡Šæ”¾ï¼Œè‹¥æ˜¯æ²¡æœ‰CæŒ‡é’ˆæŒ‡å‘å®ƒï¼Œé‚£ç¼“å­˜å°±æ²¡æœ‰å¿…è¦äº†ï¼›</p>
<p>è‹¥æ˜¯linksï¼ˆæ–‡ä»¶é‡Œä¹Ÿæ²¡æœ‰è¿™ä¸ª<code>inode</code>äº†ï¼‰ä¹Ÿç­‰äºŽ0ï¼Œé‚£ä¹ˆå¯¹åº”çš„BLOCKä¹Ÿå°±è¦è¢«æ¸…ç†äº†ã€‚</p>
</blockquote>
<p><code>Iput</code> (kernel/fs.c:333) releases a C pointer to an <code>inode</code> by decrementing the reference count (kernel/fs.c:356). <strong>If this is the last reference, the <code>inodeâ€™s</code>slot in the <code>inode</code> cache is now free and can be re-used for a different <code>inode</code>.</strong></p>
<p>If <code>iput</code> sees that there are no C pointer references to an <code>inode</code> and that <strong>the <code>inode</code> has no links to it (occurs in no directory), then the <code>inode</code> and its data blocks must be freed</strong>. <code>Iput</code> calls <code>itrunc</code> to truncate the file to zero bytes, freeing the data blocks; sets the <code>inode</code> type to 0 (unallocated); and writes the <code>inode</code> to disk (kernel/fs.c:338).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Drop a reference to an in-memory inode.</span>
<span class="c1">// If that was the last reference, the inode cache entry can</span>
<span class="c1">// be recycled.</span>
<span class="c1">// If that was the last reference and the inode has no links</span>
<span class="c1">// to it, free the inode (and its content) on disk.</span>
<span class="c1">// All calls to iput() must be inside a transaction in</span>
<span class="c1">// case it has to free the inode.</span>
<span class="kt">void</span>
<span class="nf">iput</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// inode has no links and no other references: truncate and free.</span>

<span class="w">    </span><span class="c1">// ip-&gt;ref == 1 means no other process can have ip locked,</span>
<span class="w">    </span><span class="c1">// so this acquiresleep() won't block (or deadlock).</span>
<span class="w">    </span><span class="n">acquiresleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="n">itrunc</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="n">releasesleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">--</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">icache</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>The locking protocol in <code>iput</code> in the case in which it frees the <code>inode</code> deserves a closer look.</p>
<blockquote>
<p>éœ€è¦ç†æ¸…è¿™é‡Œçš„é”ä¹‹é—´çš„å…³ç³»ï¼Œä¸»è¦æ˜¯ç¬¬äºŒæ®µ</p>
<p>è¿™é‡Œæ¶‰åŠå¯¹sleep lockçš„ç†è§£</p>
<p>ä¹‹åŽéœ€è¦è¡¥å……ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼</p>
</blockquote>
<p>One danger is that a concurrent thread might be waiting in <code>ilock</code> to use this <code>inode</code> (e.g., to read a file or list a directory), and wonâ€™t be prepared to find that the <code>inode</code> is not longer allocated. This canâ€™t happen because there is no way for a system call to get a pointer to a cached <code>inode</code> if it has no links to it and<code>ip-&gt;ref</code> is one. That one reference is the reference owned by the thread calling <code>iput</code>. Itâ€™s true that <code>iput</code> checks that the reference count is one outside of its <code>icache.lock</code> critical section, but at that point the link count is known to be zero, so no thread will try to acquire a new reference.</p>
<p>The other main danger is that a concurrent call to <code>ialloc</code> might choose the same <code>inode</code> that <code>iput</code> is freeing. This can only happen after the <code>iupdate</code> writes the disk so that the <code>inode</code> has type zero. This race is benign; the allocating thread will politely wait to acquire the <code>inodeâ€™s</code> sleep-lock before reading or writing the <code>inode</code>, at which point <code>iput</code> is done with it.</p>
<hr>
<blockquote>
<p>è¿™é‡Œå¼•å‡ºä¸€ä¸ªæœ‰æ„æ€çš„ç‚¹ï¼Œæ–‡ä»¶ç³»ç»Ÿçš„system callå¯èƒ½éƒ½ä¼šæ¶‰åŠåˆ°ç£ç›˜çš„å†™å…¥ï¼Œå³ä½¿æ˜¯ä¸€ä¸ªè¯»è¿›ç¨‹ã€‚</p>
<p>å¯ä»¥æƒ³è±¡ï¼Œä¸€ä¸ªè¿›ç¨‹å®Œæˆäº†æ–‡ä»¶çš„å†™å…¥ï¼Œä½†è¿™è¿˜åœç•™åœ¨ç¼“å­˜çš„å±‚é¢ã€‚å› ä¸ºæ­¤æ—¶è¿˜æœ‰ä¸€ä¸ªè¿›ç¨‹åœ¨è¯»è¿™ä¸ªæ–‡ä»¶ï¼Œå†™å…¥çš„ä»£ç è¿˜æ˜¯æ— æ³•è§¦å‘ï¼Œå½“æˆ‘ä»¬å…³é—­äº†è¯»è¿›ç¨‹ä¹‹åŽï¼Œ<code>iput</code>è¿›å…¥äº†å›žæ”¶æ¨¡å¼ï¼Œè¿™æ‰æŠŠå†™è¿›ç¨‹å†™å®Œçš„å†…å­˜å†™å…¥äº†diskä¸Šã€‚</p>
</blockquote>
<p><strong><code>iput()</code> can write to the disk.</strong> This means that any system call that uses the file system may write the disk, because the system call may be the last one having a reference to the file. <strong>Even calls like <code>read()</code> that appear to be read-only, may end up calling <code>iput()</code></strong>. This, in turn, means that even read-only system calls must be wrapped in transactions if they use the file system.</p>
<h4 id="iput-and-crashes"><code>iput()</code> and <code>crashes</code><a class="headerlink" href="#iput-and-crashes" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>è¿™é‡Œå¼•å‡ºäº†ä¸€ä¸ªæœ‰è¶£çš„é—®é¢˜ï¼Œ<code>iput()</code>ä»£ç åœ¨<code>inode</code> linkç­‰äºŽ0æ—¶å¹¶æ²¡æœ‰é€‰æ‹©åŽ»å§diskä¸­çš„å†…å®¹åˆ é™¤ï¼Œè€Œæ˜¯é€‰æ‹©ç»§ç»­è®©è¿›ç¨‹å¯¹ç¼“å­˜ä¸­çš„å†…å®¹è¿›è¡Œè¯»å†™ã€‚</p>
<p>è¿™æ ·ä¼šå¼•å‘ä¸€ä¸ªé—®é¢˜ï¼Œè‹¥æ–‡ä»¶ç³»ç»Ÿåœ¨æˆ‘ä»¬æŠŠè¿™äº›å†…å®¹å½»åº•å†™å…¥diskä¹‹å‰å‡ºçŽ°äº†crashï¼Œé‚£ä¹ˆè¿™ä¸ªæ–‡ä»¶ä¼šè¢«è®¤ä¸ºæ˜¯å­˜åœ¨äºŽdiskä¸Šçš„ï¼ˆ<code>inode</code>å†…å®¹æ²¡æœ‰è¢«æ¸…é›¶ï¼‰ï¼Œä½†æ˜¯äº‹å®žä¸Šæ–‡ä»¶å¤¹ä¸­å·²ç»æ²¡æœ‰è¿™ä¸ªæ–‡ä»¶äº†ã€‚</p>
<p>Xv6å¹¶æ²¡æœ‰å¯¹è¿™ä¸€é—®é¢˜ä½œå‡ºå¤„ç†ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€ï¼Œä¼šå‡ºçŽ°diskå­˜å‚¨çš„æ³„éœ²ã€‚</p>
</blockquote>
<p>There is a challenging interaction between <code>iput()</code> and <code>crashes</code>. <strong><code>iput()</code> doesnâ€™t truncate a file immediately when the link count for the file drops to zero</strong>, because some process might still hold a reference to the <code>inode</code> in memory: a process might still be reading and writing to the file, because it successfully opened it.</p>
<p>But, if a crash happens before the last process closes the file descriptor for the file, then the file will be marked allocated on disk but no directory entry will point to it.</p>
<p>File systems handle this case in one of <strong>two ways.</strong></p>
<ul>
<li>
<p>The simple solution is that on recovery, after reboot, the file system scans the whole file system for files that are marked allocated, but have no directory entry pointing to them. If any such file exists, then it can free those files.</p>
</li>
<li>
<p>The second solution doesnâ€™t require scanning the file system. In this solution, the file system records on disk (e.g., in the super block) the <code>inode inumber</code> of a file <u>whose link count drops to zero but whose reference count isnâ€™t zero</u>. If the file system removes the file when its reference counts reaches 0, then it updates the on-disk list by removing that <code>inode</code> from the list. On recovery, the file system frees any file in the list.</p>
</li>
</ul>
<p>Xv6 implements neither solution, which means that <code>inodes</code> may be marked allocated on disk, even though they are not in use anymore. This means that over time xv6 runs the risk that it may run out of disk space.</p>
<h3 id="810-code-inode-content">8.10 Code: <code>Inode</code> content<a class="headerlink" href="#810-code-inode-content" title="Permanent link">Â¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// On-disk inode structure</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">dinode</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">           </span><span class="c1">// File type</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">major</span><span class="p">;</span><span class="w">          </span><span class="c1">// Major device number (T_DEVICE only)</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span><span class="w">          </span><span class="c1">// Minor device number (T_DEVICE only)</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">nlink</span><span class="p">;</span><span class="w">          </span><span class="c1">// Number of links to inode in file system</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">            </span><span class="c1">// Size of file (bytes)</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span><span class="w">   </span><span class="c1">// Data block addresses</span>
<span class="p">};</span>
</code></pre></div>
<blockquote>
<p>ä¸Šä¸€èŠ‚è®²äº†<code>inode</code>åœ¨å“ªé‡Œè¢«å­˜å‚¨ç€ï¼Œå¦‚ä½•ä½¿ç”¨å’Œé”€æ¯ï¼Œä½†åœ¨8.9èŠ‚çš„å¼€ç¯‡ï¼Œæˆ‘å°±æåˆ°äº†ï¼Œ<code>inode</code>çš„ä¸»è¦ç›®çš„æ˜¯æŠŠBLOCKæ‰“åŒ…èµ·æ¥ï¼Œè¿™å—å°±æ˜¯æ–‡ä»¶çš„æ ¸å¿ƒäº†ã€‚</p>
<p>ä¸‹è¾¹çš„å›¾ä¹Ÿè¯´å¾—å¾ˆæ¸…æ™°äº†ï¼Œå‰12ä¸ªåœ°å€éƒ½å¯¹åº”ç€ä¸€ä¸ªBLOCK</p>
<p>ç¬¬13ä¸ªåœ°å€è®¾è®¡äº†ä¸€ä¸ªäºŒçº§ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªBLOCKé‡Œåˆå­˜å‚¨äº†è®¸å¤šçš„åœ°å€ï¼ŒBLOCKçš„å¤§å°æ˜¯1024Bï¼Œ ä¸€ä¸ªåœ°å€çš„å¤§å°æ˜¯4Bï¼Œä»Žè€Œï¼Œè¿™ä¸ªäºŒçº§ç´¢å¼•è®©æ•´ä¸ª<code>inode</code>åˆå¤šäº†256ä¸ªBLOCKã€‚</p>
</blockquote>
<p>The on-disk <code>inode</code> structure, struct <code>dinode</code>, contains a size and an array of block numbers (see Figure 8.3). The <code>inode</code> data is found in the blocks listed in the <code>dinode</code> â€™s <code>addrs</code> array.</p>
<ul>
<li>
<p>The first <code>NDIRECT</code> blocks of data are listed in the first <code>NDIRECT</code> entries in the array; these blocks are called <strong>direct blocks</strong>.</p>
</li>
<li>
<p>The next <code>NINDIRECT</code> blocks of data are listed not in the <code>inode</code> but in a data block called the indirect block. The last entry in the <code>addrs</code> array gives the address of the indirect block.</p>
</li>
</ul>
<p>Thus <strong>the first 12 kB ( NDIRECT x BSIZE) bytes of a file can be loaded from blocks listed in the <code>inode</code></strong>, while <strong>the next 256 kB ( NINDIRECT x BSIZE) bytes can only be loaded after consulting the indirect block.</strong></p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220621002733864.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220621002733864" src="../../../../assets/Operating%20Systems.assets/image-20220621002733864.png"></a></p>
<p>This is a good on-disk representation but a complex one for clients. The function <code>bmap</code> manages the representation so that higher-level routines such as <code>readi</code> and<code>writei</code>, which we will see shortly. <code>Bmap</code> returns the disk block number of the <code>bnâ€™th</code> data block for the <code>inode ip</code>. If <code>ip</code> does not have such a block yet, <code>bmap</code> allocates one.</p>
<blockquote>
<p>è¿™é‡Œå°±æŠŠæ–‡ä»¶å­˜å‚¨çš„æ–¹å¼è¯´æ˜Žç™½äº†ï¼Œä½†æ˜¯ä¸å¾—ä¸æ‰¿è®¤çš„æ˜¯ï¼Œè®©ç”¨æˆ·é¢å¯¹ç€è¿™æ ·çš„æ•°æ®ç»“æž„åŽ»æ“ä½œæ–‡ä»¶ï¼Œç¡®å®žæ˜¯å¾ˆå›°éš¾çš„ã€‚æ‰€ä»¥è¿™å°±å¼•å‡ºäº†ä¸‹è¾¹çš„å‡½æ•°ã€‚</p>
</blockquote>
<h4 id="bmap"><code>Bmap</code><a class="headerlink" href="#bmap" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>Bmap</code>çš„ä¼šæŽ¥å—ä¸€ä¸ªBLOCKçš„åºå·ï¼Œå½“ç„¶è¿™é‡Œçš„åºå·æ˜¯<code>inode</code>ç»™çœŸå®žçš„BLOCKæ‰€ç¼–çš„åºå·ã€‚</p>
<p>ç„¶åŽï¼Œæ ¹æ®è¿™ä¸ªåºå·ï¼Œ<code>Bmap</code>ä¼šæŒ‰ç…§ä¸Šè¿°çš„æ•°æ®ç»“æž„åŽ»æ‰¾åˆ°å¯¹åº”çš„BLOCKï¼Œå¦‚æžœæ²¡æœ‰å°±ä¼šè°ƒç”¨<code>balloc</code>åˆ†é…ä¸€ä¸ªã€‚</p>
<p>æœ€åŽï¼Œ<code>Bmap</code>ä¼šæŠŠæ‰¾åˆ°çš„BLOCKåºå·è¿”å›ž(è¿™é‡Œçš„åºå·æ˜¯OSæŠ½è±¡å‡ºçš„ç£ç›˜çš„åºå·)ã€‚</p>
</blockquote>
<p>The function <code>bmap</code> (kernel/fs.c:378) begins by picking off the easy case: the first NDIRECT blocks are listed in the <code>inode</code> itself (kernel/fs.c:383-387). The next NINDIRECT blocks are listed in the indirect block at <code>ip-&gt;addrs[NDIRECT]</code>. <code>Bmap</code> reads the indirect block (kernel/fs.c:394) and then reads a block number from the right position within the block (kernel/fs.c:395). If the block number exceeds <code>NDIRECT+NINDIRECT</code>, <code>bmap</code> panics; <code>writei</code> contains the check that prevents this from happening (kernel/fs.c:490).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Inode content</span>
<span class="c1">//</span>
<span class="c1">// The content (data) associated with each inode is stored</span>
<span class="c1">// in blocks on the disk. The first NDIRECT block numbers</span>
<span class="c1">// are listed in ip-&gt;addrs[].  The next NINDIRECT blocks are</span>
<span class="c1">// listed in block ip-&gt;addrs[NDIRECT].</span>

<span class="c1">// Return the disk block address of the nth block in inode ip.</span>
<span class="c1">// If there is no such block, bmap allocates one.</span>
<span class="k">static</span><span class="w"> </span><span class="n">uint</span>
<span class="nf">bmap</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">bn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NDIRECT</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">bn</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">bn</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">NDIRECT</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">bn</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NINDIRECT</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// Load indirect block, allocating if necessary.</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">);</span>
<span class="w">    </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint</span><span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">bn</span><span class="p">])</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">a</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balloc</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">);</span>
<span class="w">      </span><span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">panic</span><span class="p">(</span><span class="s">"bmap: out of range"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><strong><code>Bmap</code> allocates blocks as needed</strong>. An <code>ip-&gt;addrs[]</code> or indirect entry of zero indicates that no block is allocated. <strong>As <code>bmap</code> encounters zeros, it replaces them with the numbers of fresh blocks</strong>, allocated on demand (kernel/fs.c:384-385) (kernel/fs.c:392-393).</p>
<hr>
<p><code>Bmap</code> makes it easy for <code>readi</code> and <code>writei</code> to get at an <code>inodeâ€™s</code> data.</p>
<h4 id="readi"><code>readi</code><a class="headerlink" href="#readi" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>readi</code>æ˜¯åœ¨<code>bmap</code>ä¸Šçš„åˆä¸€å±‚æŠ½è±¡ã€‚</p>
<p>ç®€è€Œè¨€ä¹‹ï¼Œ<code>readi</code>å’Œæˆ‘ä»¬å¸¸ç”¨çš„æ–‡ä»¶è¯»å†™æŽ¥å£å°±æ¯”è¾ƒç±»ä¼¼äº†ã€‚</p>
<p><code>readi</code>ä¼šæŽ¥å—ä¸€ä¸ªåç§»é‡ï¼Œæˆ‘ä»¬é€šè¿‡è¿™ä¸ª <strong>åç§»é‡/BLOCLK_SIZE</strong> å°±å¯ä»¥ç¡®å®šï¼Œè¿™ä¸ªåç§»é‡å¯¹åº”çš„æ•°æ®æ˜¯åœ¨<code>inode</code>çš„å“ªä¸€ä¸ªBLOCKé‡Œï¼Œ<code>bmap</code>ä¼šè¿”å›žè¿™ä¸ªBLOCKåœ¨diskä¸Šçš„çœŸå®žç¼–å·ã€‚æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æŠŠè¿™å—BLOCKåŠ è½½åˆ°buffer cacheä¸­ï¼Œç„¶åŽå°±å¯ä»¥ä»ŽæŒ‡å®šä½ç½®å¼€å§‹è¯»å–æ•°æ®äº†ã€‚</p>
</blockquote>
<p><code>Readi</code> (kernel/fs.c:456) starts by making sure that the offset and count are not beyond the end of the file. Reads that start beyond the end of the file return an error (kernel/fs.c:461-462) while reads that start at or cross the end of the file return fewer bytes than requested (kernel/fs.c:463-464). The main loop processes each block of the file, copying data from the buffer into <code>dst</code> (kernel/fs.c:466-474).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Read data from inode.</span>
<span class="c1">// Caller must hold ip-&gt;lock.</span>
<span class="c1">// If user_dst==1, then dst is a user virtual address;</span>
<span class="c1">// otherwise, dst is a kernel address.</span>
<span class="kt">int</span>
<span class="nf">readi</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">user_dst</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">tot</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">off</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
<span class="w">    </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">tot</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tot</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">tot</span><span class="o">+=</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="o">+=</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="o">+=</span><span class="n">m</span><span class="p">){</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">bmap</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="o">/</span><span class="n">BSIZE</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tot</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">off</span><span class="o">%</span><span class="n">BSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">either_copyout</span><span class="p">(</span><span class="n">user_dst</span><span class="p">,</span><span class="w"> </span><span class="n">dst</span><span class="p">,</span><span class="w"> </span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">),</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">      </span><span class="n">tot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">tot</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="writei"><code>writei</code><a class="headerlink" href="#writei" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>writei</code>å’Œ<code>readi</code>æ˜¯ååˆ†ç±»ä¼¼çš„ï¼Œä½†æ˜¯å†™æ“ä½œå¤šäº†ä¸‰ä¸ªå¼‚å¸¸</p>
<ul>
<li>å†™æ“ä½œå¯ä»¥è®©å¢žå¤§æ–‡ä»¶å¤§å°ï¼Œå½“ç„¶ä¸èƒ½è¶…è¿‡æ–‡ä»¶çš„æœ€å¤§é™åˆ¶</li>
<li>æ•°æ®ä»Žå†…å­˜ä¸­è¢«æ‹·è´åˆ°äº†buffer cacheä¹‹ä¸­</li>
<li>ä»¥ä¸ºå†™æ“ä½œå¯èƒ½æ¶‰åŠåˆ°æ–‡ä»¶ä½“ç§¯çš„å¢žå¤§ï¼Œéœ€è¦æ›´æ–°<code>inode</code>ä¸­å¯¹äºŽæ–‡ä»¶å¤§å°çš„æè¿°</li>
</ul>
<p><strong>æˆ‘çš„ç–‘é—®ï¼Œå¦‚æžœæˆ‘è¦åœ¨æ–‡ä»¶ä¹‹ä¸­å¼€å§‹writeï¼Œé‚£ä¹ˆä¼šä¸ä¼šå‡ºçŽ°BLOCKä¸­çš„æ—§æ•°æ®è¢«æ–°æ•°æ®è¦†ç›–çš„é—®é¢˜å‘¢ï¼Ÿ</strong></p>
</blockquote>
<p><code>writei</code> (kernel/fs.c:483) is identical to <code>readi</code>, with three exceptions:</p>
<p>writes that start at or cross the end of the file grow the file, up to the maximum file size (kernel/fs.c:490-491);</p>
<p>the loop copies data into the buffers instead of out (kernel/fs.c:36); and</p>
<p>if the write has extended the file, <code>writei</code> must update its size (kernel/fs.c:504-511).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Write data to inode.</span>
<span class="c1">// Caller must hold ip-&gt;lock.</span>
<span class="c1">// If user_src==1, then src is a user virtual address;</span>
<span class="c1">// otherwise, src is a kernel address.</span>
<span class="kt">int</span>
<span class="nf">writei</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">user_src</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">tot</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">off</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">MAXFILE</span><span class="o">*</span><span class="n">BSIZE</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">tot</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tot</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">tot</span><span class="o">+=</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="o">+=</span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="o">+=</span><span class="n">m</span><span class="p">){</span>
<span class="w">    </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">bmap</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="o">/</span><span class="n">BSIZE</span><span class="p">));</span>
<span class="w">    </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">tot</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">off</span><span class="o">%</span><span class="n">BSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">either_copyin</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">),</span><span class="w"> </span><span class="n">user_src</span><span class="p">,</span><span class="w"> </span><span class="n">src</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">      </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
<span class="w">      </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// write the i-node back to disk even if the size didn't change</span>
<span class="w">    </span><span class="c1">// because the loop above might have called bmap() and added a new</span>
<span class="w">    </span><span class="c1">// block to ip-&gt;addrs[].</span>
<span class="w">    </span><span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Both <code>readi</code> and <code>writei</code> begin by checking for <code>ip-&gt;type == T_DEV</code>. This case handles special devices whose data does not live in the file system; we will return to this case in the file descriptor layer.</p>
<h4 id="stati"><code>stati</code><a class="headerlink" href="#stati" title="Permanent link">Â¶</a></h4>
<p>The function <code>stati</code> (kernel/fs.c:442) copies <code>inode</code> metadata into the stat structure, which is exposed to user programs via the stat system call.</p>
<h3 id="811-code-directory-layer">8.11 Code: directory layer<a class="headerlink" href="#811-code-directory-layer" title="Permanent link">Â¶</a></h3>
<p>A directory is implemented internally much like a file. Its <code>inode</code> has type <code>T_DIR</code> and its data is a sequence of directory entries. Each entry is a struct <code>dirent</code> (kernel/fs.h:56), which contains a name and an <code>inode</code> number. The name is at most <code>DIRSIZ (14)</code> characters; if shorter, it is terminated by a NUL (0) byte. Directory entries with <code>inode</code> number zero are free.</p>
<blockquote>
<p>æ–‡ä»¶å¤¹å’Œæ–‡ä»¶çš„å®žçŽ°å…¶å®žæ˜¯å¾ˆç›¸ä¼¼çš„ã€‚æ–‡ä»¶é‡Œå­˜å‚¨äº†è®¸å¤šBLOCKçš„åœ°å€ï¼Œæ–‡ä»¶å¤¹å­˜å‚¨äº†è®¸å¤šå…¶ä»–æ–‡ä»¶å¤¹çš„åœ°å€ã€‚è¿™äº›åœ°å€æŒ‡å‘ä¸‹è¾¹æ‰€ç¤ºçš„æ•°æ®ç»“æž„ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Directory is a file containing a sequence of dirent structures.</span>
<span class="cp">##define DIRSIZ 14</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">dirent</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">ushort</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div>
<h4 id="dirlookup"><code>dirlookup</code><a class="headerlink" href="#dirlookup" title="Permanent link">Â¶</a></h4>
<p>The function <code>dirlookup</code> (kernel/fs.c:527) searches a directory for an entry with the given name.</p>
<p>If it finds one, it returns a pointer to the corresponding <code>inode</code>, unlocked, and sets <code>*poff</code> to the byte offset of the entry within the directory, in case the caller wishes to edit it.</p>
<p>If <code>dirlookup</code> finds an entry with the right name, it updates <code>*poff</code> and returns an unlocked <code>inode</code> obtained via <code>iget</code>.</p>
<blockquote>
<p>æ–‡ä»¶æŸ¥æ‰¾æœ€åŽè¿”å›žçš„æ˜¯ä¸€ä¸ªæ²¡æœ‰è¢«é”ä½çš„<code>inode</code>ç¼“å­˜ï¼Œè¿™ä¸€ç‚¹åœ¨8.9èŠ‚<code>iget</code>ä¸­å°±æœ‰äº†è®ºè¿°ï¼Œè¿™é‡Œç»“åˆè¿™ä¸ªåŠŸèƒ½æ›´æ·±å…¥çš„è®¨è®ºäº†è¿™ä¸€ç‚¹ã€‚</p>
<p>è¦æŸ¥è¯¢<code>dp</code>æ–‡ä»¶å¤¹çš„äººå·²ç»ç»™<code>dp</code>åŠ é”äº†ï¼Œæ­¤æ—¶æˆ‘ä»¬çš„nameæ˜¯å½“å‰æ–‡ä»¶å¤¹ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡<code>dp</code>æ‰¾<code>dp</code>ï¼Œå¦‚æžœæˆ‘ä»¬çš„<code>iget</code>ä¹Ÿè¦ç»™<code>dp</code>åŠ é”çš„è¯ï¼Œé‚£å°±é€ æˆæ­»é”äº†ã€‚</p>
</blockquote>
<p><strong><code>Dirlookup</code>is the reason that<code>iget</code> returns unlocked <code>inodes</code>.</strong> The caller has locked <code>dp</code>, so if the lookup was for <code>.</code>, an alias for the current directory, attempting to lock the <code>inode</code> before returning would try to re-lock <code>dp</code> and deadlock. (There are more complicated deadlock scenarios involving multiple processes and <code>..</code>, an alias for the parent directory; . is not the only problem.) <strong>The caller can unlock <code>dp</code> and then lock <code>ip</code>, ensuring that it only holds one lock at a time.</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// Look for a directory entry in a directory.</span>
<span class="c1">// If found, set *poff to byte offset of entry.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">dirlookup</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="o">*</span><span class="n">poff</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">dirent</span><span class="w"> </span><span class="n">de</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T_DIR</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"dirlookup not DIR"</span><span class="p">);</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">)){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"dirlookup read"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">continue</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">namecmp</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// entry matches path element</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">poff</span><span class="p">)</span>
<span class="w">        </span><span class="o">*</span><span class="n">poff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">      </span><span class="n">inum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">de</span><span class="p">.</span><span class="n">inum</span><span class="p">;</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">iget</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">inum</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="dirlink"><code>dirlink</code><a class="headerlink" href="#dirlink" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>åˆ›å»ºæ–°æ–‡ä»¶å¤¹</p>
</blockquote>
<p>The function <code>dirlink</code> (kernel/fs.c:554) writes a new directory entry with the given name and <code>inode</code> number into the directory <code>dp</code>.</p>
<p>If the name already exists, <code>dirlink</code> returns an error (kernel/fs.c:560- 564).</p>
<p>The main loop reads directory entries looking for an unallocated entry. When it finds one, it stops the loop early (kernel/fs.c:538-539), with off set to the offset of the available entry. Otherwise, the loop ends with off set to <code>dp-&gt;size</code>. Either way, <code>dirlink</code> then adds a new entry to the directory by writing at offset off (kernel/fs.c:574-577).</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Write a new directory entry (name, inum) into the directory dp.</span>
<span class="kt">int</span>
<span class="nf">dirlink</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">uint</span><span class="w"> </span><span class="n">inum</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">off</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">dirent</span><span class="w"> </span><span class="n">de</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Check that name is not present.</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirlookup</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Look for an empty dirent.</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">off</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">off</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">)){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"dirlink read"</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">inum</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">strncpy</span><span class="p">(</span><span class="n">de</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">DIRSIZ</span><span class="p">);</span>
<span class="w">  </span><span class="n">de</span><span class="p">.</span><span class="n">inum</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inum</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">writei</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="o">&amp;</span><span class="n">de</span><span class="p">,</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">de</span><span class="p">))</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"dirlink"</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="812-code-path-names">8.12 Code: Path names<a class="headerlink" href="#812-code-path-names" title="Permanent link">Â¶</a></h3>
<p>Path name lookup involves a succession of calls to <code>dirlookup</code>, one for each path component.</p>
<blockquote>
<p>ä¸¤ä¸ªé€šè¿‡åå­—æ‰¾<code>inode</code>çš„å‡½æ•°</p>
</blockquote>
<h4 id="nameinameiparent"><code>Namei/nameiparent</code><a class="headerlink" href="#nameinameiparent" title="Permanent link">Â¶</a></h4>
<p><code>Namei</code> (kernel/fs.c:661) evaluates path and returns the corresponding <code>inode</code>.</p>
<p>The function <code>nameiparent</code> is a variant: it stops before the last element, returning the <code>inode</code> of the parent directory and copying the final element into name. Both call the generalized function <code>namex</code> to do the real work.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">namei</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">];</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">namex</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">nameiparent</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">namex</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="namex"><code>Namex</code><a class="headerlink" href="#namex" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>ç¬¬ä¸€æ­¥ï¼Œç›¸å¯¹è·¯å¾„è¿˜æ˜¯ç»å¯¹è·¯å¾„ï¼Ÿ</p>
</blockquote>
<p><code>Namex</code> (kernel/fs.c:626) starts by deciding where the path evaluation begins. If the path begins with a slash, evaluation begins at the root; otherwise, the current directory (kernel/fs.c:630-633).</p>
<blockquote>
<p>ç¬¬äºŒæ­¥ï¼Œæ£€æŸ¥pathä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ </p>
</blockquote>
<p>Then it uses <code>skipelem</code> to consider each element of the path in turn (kernel/fs.c:635). Each iteration of the loop must look up name in the current <code>inode ip</code>.</p>
<blockquote>
<p>ç¬¬ä¸‰æ­¥ï¼Œç¡®ä¿pathä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ çš„<code>inode</code>éƒ½æ˜¯æ–‡ä»¶å¤¹</p>
<p>æ³¨æ„ï¼Œ<code>ilock</code>åœ¨è¿™é‡Œè¢«ä½¿ç”¨äº†ï¼Œpathä¸­çš„æ¯ä¸ªæ–‡ä»¶å¤¹éƒ½æ˜¯ä¸€ä¸ª<code>inode</code>ï¼Œåœ¨æŸ¥çœ‹ä»–ä»¬çš„Typeä¹‹å‰éœ€è¦é€šè¿‡<code>ilock</code>ä¿è¯ä»–ä»¬éƒ½è¢«åŠ è½½åˆ°äº†cacheä¸­ï¼Œè¿™é‡Œçš„lockçš„ä½œç”¨å¾ˆç‰¹åˆ«ï¼ï¼ï¼</p>
</blockquote>
<p>The iteration begins by locking <code>ip</code> and checking that it is a directory. If not, the lookup fails (kernel/fs.c:636-640). (<strong>Locking <code>ip</code> is necessary</strong> not because <code>ip-&gt;type</code> can change underfootâ€”it canâ€™tâ€”but <strong>because until <code>ilock</code> runs, <code>ip-&gt;type</code> is not guaranteed to have been loaded from disk</strong>.)</p>
<blockquote>
<p>ç¬¬å››æ­¥ï¼Œæ ¹æ®ç›¸åº”çš„æ¡ä»¶ï¼Œæ‰¾åˆ°æ–‡ä»¶æˆ–è€…æ–‡ä»¶çš„parent</p>
</blockquote>
<p>If the call is <code>nameiparent</code> and this is the last path element, the loop stops early, as per the definition of <code>nameiparent</code>; the final path element has already been copied into name, so <code>namex</code> need only return the unlocked <code>ip</code> (kernel/fs.c:641-645).</p>
<p>Finally, the loop looks for the path element using <code>dirlookup</code> and prepares for the next iteration by setting <code>ip = next</code> (kernel/fs.c:646-651). When the loop runs out of path elements, it returns <code>ip</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Look up and return the inode for a path name.</span>
<span class="c1">// If parent != 0, return the inode for the parent and copy the final</span>
<span class="c1">// path element into name, which must have room for DIRSIZ bytes.</span>
<span class="c1">// Must be called inside a transaction since it calls iput().</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">namex</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">nameiparent</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'/'</span><span class="p">)</span>
<span class="w">    </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iget</span><span class="p">(</span><span class="n">ROOTDEV</span><span class="p">,</span><span class="w"> </span><span class="n">ROOTINO</span><span class="p">);</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idup</span><span class="p">(</span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">cwd</span><span class="p">);</span>

<span class="w">  </span><span class="k">while</span><span class="p">((</span><span class="n">path</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">skipelem</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">T_DIR</span><span class="p">){</span>
<span class="w">      </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">nameiparent</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">'\0'</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// Stop one level early.</span>
<span class="w">      </span><span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirlookup</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">nameiparent</span><span class="p">){</span>
<span class="w">    </span><span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>è¿™é‡Œçš„è®¾è®¡äº®ç‚¹å°±æ˜¯ï¼Œpathä¸­çš„æ¯ä¸ªæ–‡ä»¶å¤¹éƒ½æ˜¯ç”¨çš„æ—¶å€™é”ä½ï¼Œç”¨å®Œäº†å°±é‡Šæ”¾ã€‚è¿™ä½¿å¾—å¹¶è¡Œå¾—ä»¥å®žçŽ°ã€‚</p>
</blockquote>
<p>The procedure <code>namex</code> may take a long time to complete: it could involve several disk operations to read <code>inodes</code> and directory blocks for the directories traversed in the pathname (if they are not in the buffer cache). <strong>Xv6 is carefully designed so that if an invocation of <code>namex</code> by one kernel thread is blocked on a disk I/O, another kernel thread looking up a different pathname can proceed concurrently.</strong> <strong><code>Namex</code> locks each directory in the path separately so that lookups in different directories can proceed in parallel.</strong></p>
<blockquote>
<p>å¹¶å‘å¸¦æ¥çš„æŒ‘æˆ˜</p>
<p>æŒ‘æˆ˜ä¸€ï¼šè¿›ç¨‹1æ­£åœ¨æŸ¥è¯¢ä¸€ä¸ªpathnameï¼Œè¿›ç¨‹äºŒå¯èƒ½åœ¨åŒæ—¶æŠŠè·¯å¾„ä¸­çš„æ–‡ä»¶å¤¹ç»™åˆ é™¤äº†ã€‚è¿™ï¿½ï¿½ä¼šä½¿å¾—æŸ¥ï¿½ï¿½ï¿½åˆ°çš„æ–‡ä»¶å¯ï¿½ï¿½ï½¿è¢«åˆ é™¤äº†æˆ–è€…æ˜¯è¢«å…¶ä»–å†…å®¹ç»™è¦†ç›–äº†ã€‚</p>
<p>Xv6è§£å†³äº†è¿™ä¸ªé—®é¢˜ï¼Œé¦–å…ˆ<code>Iget</code>ä¼šå¢žåŠ <code>inode</code>çš„reference countï¼Œä»Žè€Œ<code>inode</code>ä¸ä¼šä»Žç¼“å­˜ä¸­è¢«æ›¿æ¢ï¼›å…¶æ¬¡ï¼Œ<code>namex</code>åªæœ‰åœ¨èŽ·å¾—<code>inode</code>ä¹‹åŽæ‰ä¼šé‡Šæ”¾å¯¹æ–‡ä»¶å¤¹çš„é”ã€‚å› æ­¤ï¼Œå¦‚æžœ<code>inode</code>å·²ç»è¢«å¦ä¸€ä¸ªè¿›ç¨‹åˆ é™¤äº†ï¼Œä½†æ˜¯ä»–çš„pointer referenceå¹¶æ²¡æœ‰å½’0ï¼Œä»Žè€Œä¸ä¼šè¢«ç«‹åˆ»åˆ é™¤ã€‚</p>
</blockquote>
<p>This concurrency introduces some challenges. For example, while one kernel thread is looking up a pathname another kernel thread may be changing the directory tree by unlinking a directory. A potential risk is that a lookup may be searching a directory that has been deleted by another kernel thread and its blocks have been re-used for another directory or file.</p>
<p>Xv6 avoids such races. For example, when executing <code>dirlookup</code> in <code>namex</code>, the lookup thread holds the lock on the directory and <code>dirlookup</code> returns an <code>inode</code> that was obtained using <code>iget</code>. <code>Iget</code> increases the reference count of the <code>inode</code>. Only after receiving the <code>inode</code> from <code>dirlookup</code> does <code>namex</code> release the lock on the directory. Now another thread may unlink the <code>inode</code> from the directory but xv6 will not delete the <code>inode</code> yet, because the reference count of the <code>inode</code> is still larger than zero.</p>
<blockquote>
<p>æŒ‘æˆ˜äºŒï¼šæ­»é”ã€‚å¯ä»¥é¢„æƒ³è¿™æ ·ä¸€ç§æƒ…å†µï¼Œ<code>./a.txt</code>ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œ<code>namex</code>ä¼šå…ˆå¯¹è¿™ä¸ª<code>.</code>è¿›è¡ŒæŸ¥è¯¢ï¼Œä¹Ÿå°±æ˜¯æˆ‘æŸ¥æˆ‘è‡ªå·±ã€‚æˆ‘ä»¬å·²ç»çŸ¥é“ï¼Œ<code>namex</code>ä¼šç»™è¢«æŸ¥è¯¢çš„å½“å‰èŠ‚ç‚¹ä¸Šé”ï¼Œé‚£ä¹ˆï¼Œå½“å‰èŠ‚ç‚¹å·²ç»è¢«é”äº†ï¼Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿæ˜¯å½“å‰èŠ‚ç‚¹ï¼Œè¿™å°±é€ æˆäº†æ­»é”ã€‚å½“ç„¶ï¼Œä»£ç ä¸­å¯ä»¥çœ‹å‡ºï¼Œåœ¨è¿›å…¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ä¹‹å‰ï¼Œ<code>namex</code>ä¼šé‡Šæ”¾å½“å‰èŠ‚ç‚¹çš„é”ï¼Œä»Žè€Œè¿™ç§æ­»é”ä¹Ÿå°±ä¸ä¼šå‘ç”Ÿäº†ã€‚</p>
<p>è¿™é‡Œä¹Ÿå°±ä½“çŽ°å‡º<code>inode cache</code> å’Œ<code>buffer cache</code>ä¸Šé”ç†å¿µçš„ä¸åŒäº†ã€‚<code>buffer cache</code>äº¤ç»™ä¸Šå±‚çš„éƒ½æ˜¯ä¸€ä¸ªä¸Šè¿‡é”çš„bufferï¼Œè€Œ<code>inode cache</code>ä¼šç»™ä¸Šå±‚ä¸€ä¸ªä¸åŠ é”çš„<code>inode</code>ï¼Œå¯¹è¿™ä¸ª<code>inode</code>çš„ä¸Šé”éœ€è¦äº¤ç»™ä¸Šå±‚æ¥å¤„ç†ã€‚</p>
</blockquote>
<p>Another risk is deadlock. For example, next points to the same <code>inode</code> as <code>ip</code> when looking up ".". Locking next before releasing the lock on <code>ip</code> would result in a deadlock. To avoid this deadlock, <code>namex</code> unlocks the directory before obtaining a lock on next. Here again we see why the separation between <code>iget</code> and <code>ilock</code> is important.</p>
<h3 id="813-file-descriptor-layer">8.13 File descriptor layer<a class="headerlink" href="#813-file-descriptor-layer" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>File descriptor,å¥æŸ„ï¼Œæ˜¯å¯¹ç¡¬ç›˜æˆ–è€…å…¶ä»–ç¡¬ä»¶èµ„æºçš„è¿›ä¸€æ­¥æŠ½è±¡ã€‚</p>
</blockquote>
<p>A cool aspect of the Unix interface is that most resources in Unix are represented as files, including devices such as the console, pipes, and of course, real files. The file descriptor layer is the layer that achieves this uniformity.</p>
<blockquote>
<p>æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰ä¸€ä¸ªfile descriptor tableã€‚è¿™ä¸ªå¥æŸ„è¡¨é‡Œå­˜æ”¾çš„æ˜¯fileè¿™ä¸ªæ•°æ®ç»“æž„ï¼Œä»–å†…éƒ¨å¯èƒ½æ˜¯ä¸€ä¸ª<code>inode</code>æˆ–è€…æ˜¯ä¸€ä¸ªpipeã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Per-process state</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// p-&gt;lock must be held when using these:</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">procstate</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">        </span><span class="c1">// Process state</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">;</span><span class="w">         </span><span class="c1">// Parent process</span>
<span class="w">  </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">chan</span><span class="p">;</span><span class="w">                  </span><span class="c1">// If non-zero, sleeping on chan</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">killed</span><span class="p">;</span><span class="w">                  </span><span class="c1">// If non-zero, have been killed</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">xstate</span><span class="p">;</span><span class="w">                  </span><span class="c1">// Exit status to be returned to parent's wait</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="p">;</span><span class="w">                     </span><span class="c1">// Process ID</span>

<span class="w">  </span><span class="c1">// these are private to the process, so p-&gt;lock need not be held.</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">kstack</span><span class="p">;</span><span class="w">               </span><span class="c1">// Virtual address of kernel stack</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">sz</span><span class="p">;</span><span class="w">                   </span><span class="c1">// Size of process memory (bytes)</span>
<span class="w">  </span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">;</span><span class="w">       </span><span class="c1">// User page table</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">trapframe</span><span class="w"> </span><span class="o">*</span><span class="n">trapframe</span><span class="p">;</span><span class="w"> </span><span class="c1">// data page for trampoline.S</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">context</span><span class="w"> </span><span class="n">context</span><span class="p">;</span><span class="w">      </span><span class="c1">// swtch() here to run process</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">ofile</span><span class="p">[</span><span class="n">NOFILE</span><span class="p">];</span><span class="w">  </span><span class="c1">// Open files</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">cwd</span><span class="p">;</span><span class="w">           </span><span class="c1">// Current directory</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span><span class="w">               </span><span class="c1">// Process name (debugging)</span>
<span class="p">};</span>
</code></pre></div>
</blockquote>
<h4 id="struct-file">Struct <code>file</code><a class="headerlink" href="#struct-file" title="Permanent link">Â¶</a></h4>
<p>Xv6 gives each process its own table of open files, or file descriptors, as we saw in Chapter 1. <strong>Each open file is represented by a struct file (kernel/file.h:1), which is a wrapper around either an <code>inode</code> or a <code>pipe</code>, plus an I/O offset</strong>.</p>
<blockquote>
<p>æ¯å½“æˆ‘ä»¬åœ¨ä¸€ä¸ªè¿›ç¨‹ä¸­openä¸€ä¸ªæ–‡ä»¶æ—¶ï¼Œä¸€ä¸ªfileç»“æž„ä½“å°±ä¼šè¢«å†™å…¥<code>proc</code>ä¸­çš„å¥æŸ„è¡¨ä¸­ã€‚</p>
<p>å¤šä¸ªè¿›ç¨‹å¯ä»¥æ‰“å¼€åŒä¸€ä¸ªæ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä»–ä»¬å„è‡ªçš„å¥æŸ„è¡¨ä¸­éƒ½ä¼šè®°å½•åŒä¸€ä¸ª<code>inode</code>,ä½†æ˜¯offsetå¯èƒ½ä¼šå„æœ‰ä¸åŒã€‚</p>
<p>ä¸€ä¸ªè¿›ç¨‹ä¹Ÿå¯ä»¥å¤šæ¬¡æ‰“å¼€åŒä¸€ä¸ªæ–‡ä»¶ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªè¿›ç¨‹çš„å¥æŸ„è¡¨ä¸­å¯ä»¥å¤šæ¬¡å­˜æ”¾åŒä¸€ä¸ª<code>inode</code>ã€‚</p>
</blockquote>
<p>Each call to open creates a new open file (a new struct file): if multiple processes open the same file independently, the different instances will have different I/O offsets. On the other hand, a single open file (the same struct file) can appear multiple times in one processâ€™s file table and also in the file tables of multiple processes. <strong>This would happen if one process used open to open the file and then created aliases using dup or shared it with a child using fork.</strong></p>
<p>A <strong>reference count</strong> tracks the number of references to a particular open file. A file can be open for reading or writing or both. The readable and writable fields track this.</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">FD_NONE</span><span class="p">,</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">,</span><span class="w"> </span><span class="n">FD_INODE</span><span class="p">,</span><span class="w"> </span><span class="n">FD_DEVICE</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>

<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ref</span><span class="p">;</span><span class="w"> </span><span class="c1">// reference count</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">readable</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">writable</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="w"> </span><span class="o">*</span><span class="n">pipe</span><span class="p">;</span><span class="w"> </span><span class="c1">// FD_PIPE</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">;</span><span class="w">  </span><span class="c1">// FD_INODE and FD_DEVICE</span>
<span class="w">  </span><span class="n">uint</span><span class="w"> </span><span class="n">off</span><span class="p">;</span><span class="w">          </span><span class="c1">// FD_INODE</span>
<span class="w">  </span><span class="kt">short</span><span class="w"> </span><span class="n">major</span><span class="p">;</span><span class="w">       </span><span class="c1">// FD_DEVICE</span>
<span class="p">};</span>
</code></pre></div>
<hr>
<p>All the open files in the system are kept in a <strong>global file table, the <code>ftable</code>.</strong> The file table has functions to allocate a file (<code>filealloc</code>), create a duplicate reference (<code>filedup</code>), release a reference (<code>fileclose</code>), and read and write data (<code>fileread</code> and <code>filewrite</code>).</p>
<div class="highlight"><pre><span></span><code><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="n">file</span><span class="p">[</span><span class="n">NFILE</span><span class="p">];</span>
<span class="p">}</span><span class="w"> </span><span class="n">ftable</span><span class="p">;</span>
</code></pre></div>
<blockquote>
<p>æ“ä½œç³»ç»Ÿç”¨äº†ä¸€ä¸ªå…¨å±€å˜é‡æ¥å­˜å‚¨æ‰€æœ‰çš„è¢«æ‰“å¼€çš„æ–‡ä»¶</p>
</blockquote>
<p>The first three follow the now-familiar form. <code>Filealloc</code> (kernel/file.c:30) scans the file table for an unreferenced file (f-&gt;ref == 0) and returns a new reference; <code>filedup</code> (kernel/file.c:48) increments the reference count; and <code>fileclose</code> (kernel/file.c:60) decrements it. When a fileâ€™s reference count reaches zero, <code>fileclose</code> releases the underlying pipe or <code>inode</code>, according to the type.</p>
<h4 id="filealloc"><code>Filealloc</code><a class="headerlink" href="#filealloc" title="Permanent link">Â¶</a></h4>
<p>ä»Žå…¨å±€è¡¨ä¸­æ‰¾å‡ºä¸€ä¸ªç©ºé—²çš„å¥æŸ„ï¼Œç„¶åŽè¿”å›žç»™ä¸Šä¸€çº§</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Allocate a file structure.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="o">*</span>
<span class="n">filealloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ftable</span><span class="p">.</span><span class="n">file</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ftable</span><span class="p">.</span><span class="n">file</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">NFILE</span><span class="p">;</span><span class="w"> </span><span class="n">f</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="filedup"><code>Filedup</code><a class="headerlink" href="#filedup" title="Permanent link">Â¶</a></h4>
<p>å¢žå‡å¥æŸ„è¢«å¼•ç”¨çš„ä¸ªæ•°å¹¶è¿”å›žå¥æŸ„</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Increment ref count for file f.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="o">*</span>
<span class="n">filedup</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"filedup"</span><span class="p">);</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="fileclose"><code>Fileclose</code><a class="headerlink" href="#fileclose" title="Permanent link">Â¶</a></h4>
<p>å½“ç¡®è®¤å¥æŸ„æ²¡æœ‰å¼•ç”¨ä¹‹åŽï¼Œé‡Šæ”¾<code>inode</code>æˆ–è€…pipe</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Close file f.  (Decrement ref count, close when reaches 0.)</span>
<span class="kt">void</span>
<span class="nf">fileclose</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="n">ff</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"fileclose"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">--</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">ff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD_NONE</span><span class="p">;</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ftable</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">){</span>
<span class="w">    </span><span class="n">pipeclose</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">pipe</span><span class="p">,</span><span class="w"> </span><span class="n">ff</span><span class="p">.</span><span class="n">writable</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_INODE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ff</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_DEVICE</span><span class="p">){</span>
<span class="w">    </span><span class="n">begin_op</span><span class="p">();</span>
<span class="w">    </span><span class="n">iput</span><span class="p">(</span><span class="n">ff</span><span class="p">.</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<p>The functions <code>filestat</code>, <code>fileread</code>, and <code>filewrite</code> implement the stat, read, and write operations on files.</p>
<p><code>Filestat</code> (kernel/file.c:88) is only allowed on <code>inodes</code> and calls <code>stati</code>.</p>
<p><code>Fileread</code> and <code>filewrite</code> check that the operation is allowed by the open mode and then pass the call through to either the pipe or <code>inode</code> implementation.</p>
<ul>
<li>
<p>If the file represents an <code>inode</code>, <code>fileread</code> and <code>filewrite</code> use the I/O offset as the offset for the operation and then advance it (kernel/file.c:122- 123) (kernel/file.c:153-154).</p>
</li>
<li>
<p>Pipes have no concept of offset. Recall that the <code>inode</code> functions require the caller to handle locking (kernel/file.c:94-96) (kernel/file.c:121-124) (kernel/file.c:163-166).</p>
</li>
</ul>
<blockquote>
<p>é€šè¿‡å¥æŸ„è¯»å†™pipeæ²¡ä»€ä¹ˆå¾ˆç‰¹åˆ«çš„ï¼Œéƒ½åœ¨<code>pipe.c</code>ä¸­ã€‚</p>
<p>é€šè¿‡å¥æŸ„è¯»å†™<code>inode</code>æ˜¯å¾ˆæœ‰æ„æ€çš„çŽ¯èŠ‚ï¼Œå®ƒåˆ**å†æ¬¡ä½“çŽ°äº†Xv6æŠŠç»™<code>inode</code>çš„ä¸Šé”è§£é”ä»»åŠ¡äº¤ç»™è°ƒç”¨è€…çš„è®¾è®¡**ï¼Œä»Žä¸‹é¢çš„å‡½æ•°æ¥çœ‹ï¼Œ<code>fileread</code>å’Œ<code>filewrite</code>ä¿è¯äº†å¯¹<code>inode</code>çš„offsetæ›´æ–°çš„åŽŸå­æ€§ã€‚ä»Žè€Œï¼Œå¤šä¸ªè¿›ç¨‹åŒæ—¶å¯¹æ–‡ä»¶å†™å…¥å¹¶ä¸ä¼šäº’ç›¸è¦†ç›–ï¼Œä¸€ä¸ªè¿›ç¨‹å¿…é¡»åœ¨å¦ä¸€ä¸ªè¿›ç¨‹æ›´æ–°å®Œoffsetä¹‹åŽæ‰èƒ½ç»§ç»­å†™å…¥ã€‚</p>
</blockquote>
<p>The <code>inode</code> locking has the convenient side effect that the read and write offsets are updated atomically, so that multiple writing to the same file simultaneously cannot overwrite each otherâ€™s data, though their writes may end up interlaced.</p>
<h4 id="fileread"><code>fileread</code><a class="headerlink" href="#fileread" title="Permanent link">Â¶</a></h4>
<div class="highlight"><pre><span></span><code><span class="c1">// Read from file f.</span>
<span class="c1">// addr is a user virtual address.</span>
<span class="kt">int</span>
<span class="nf">fileread</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">readable</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">){</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">piperead</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_DEVICE</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">NDEV</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">read</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">read</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_INODE</span><span class="p">){</span>
<span class="w">    </span><span class="n">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">readi</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="n">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"fileread"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="filewrite"><code>filewrite</code><a class="headerlink" href="#filewrite" title="Permanent link">Â¶</a></h4>
<blockquote>
<p>ç»“åˆ8.6Loggingç« èŠ‚ï¼Œæ–‡ä»¶ä¸€æ¬¡å†™å…¥çš„å¤§å°æ˜¯æœ‰é™åˆ¶çš„ï¼Œå› ä¸ºLOGåœ¨DISKä¸Šçš„ç©ºé—´æ˜¯æœ‰é™çš„ï¼Œé‡åˆ°å¤§æ–‡ä»¶åªèƒ½æŠŠå®ƒæŒ‰ç…§LOGçš„æœ€å¤§ç©ºé—´å¤šæ¬¡å†™å…¥ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Write to file f.</span>
<span class="c1">// addr is a user virtual address.</span>
<span class="kt">int</span>
<span class="nf">filewrite</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">){</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pipewrite</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_DEVICE</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">NDEV</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">!</span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">write</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devsw</span><span class="p">[</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">].</span><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">FD_INODE</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// write a few blocks at a time to avoid exceeding</span>
<span class="w">    </span><span class="c1">// the maximum log transaction size, including</span>
<span class="w">    </span><span class="c1">// i-node, indirect block, allocation blocks,</span>
<span class="w">    </span><span class="c1">// and 2 blocks of slop for non-aligned writes.</span>
<span class="w">    </span><span class="c1">// this really belongs lower down, since writei()</span>
<span class="w">    </span><span class="c1">// might be writing a device like the console.</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">MAXOPBLOCKS</span><span class="mi">-1-1-2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">){</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">n1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">max</span><span class="p">)</span>
<span class="w">        </span><span class="n">n1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">;</span>

<span class="w">      </span><span class="n">begin_op</span><span class="p">();</span>
<span class="w">      </span><span class="n">ilock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">writei</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">addr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="p">,</span><span class="w"> </span><span class="n">n1</span><span class="p">))</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">      </span><span class="n">iunlock</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="n">end_op</span><span class="p">();</span>

<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">n1</span><span class="p">)</span>
<span class="w">        </span><span class="n">panic</span><span class="p">(</span><span class="s">"short filewrite"</span><span class="p">);</span>
<span class="w">      </span><span class="n">i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">-1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"filewrite"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="814-code-system-calls">8.14 Code: System calls<a class="headerlink" href="#814-code-system-calls" title="Permanent link">Â¶</a></h3>
<p>With the functions that the lower layers provide the implementation of most system calls is trivial (see (<code>kernel/sysfile.c</code>)). There are a few calls that deserve a closer look.</p>
<hr>
<p>The functions <code>sys_link</code> and <code>sys_unlink</code> edit directories, creating or removing references to <code>inodes</code>. They are another good example of the power of using transactions.</p>
<h4 id="sys_link"><code>sys_link</code>(ç¡¬é“¾æŽ¥)<a class="headerlink" href="#sys_link" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>sys_link</code>æ‰€åšçš„æ˜¯å°±æ˜¯è®©new pathnameå’Œold pathnameæŒ‡å‘åŒä¸€å—<code>inode</code>ã€‚</p>
<ol>
<li>ä¿è¯old pathnameæ˜¯å­˜åœ¨çš„å¹¶ä¸”ä¸æ˜¯æ–‡ä»¶å¤¹</li>
<li>å¯¹old pathnameå¯¹åº”çš„<code>inode</code>çš„å¼•ç”¨++</li>
<li>new pathnameçš„ä¸Šå±‚æ–‡ä»¶å¤¹å¿…é¡»æ˜¯å­˜åœ¨çš„ï¼Œå¹¶ä¸”new pathnameå’Œold pathnameå¯¹åº”çš„æ˜¯åŒä¸€ä¸ªç¡¬ä»¶è®¾å¤‡</li>
<li><strong>å¦‚æžœä¸€åˆ‡éƒ½æ²¡é—®é¢˜ï¼Œå°±æŠŠold pathnameæ‰€æŒ‡å‘çš„<code>inode</code>å­˜å…¥new pathnameå¯¹åº”çš„æ–‡ä»¶å¤¹ç›®å½•é‡Œè¾¹åŽ»ï¼ˆ<code>dirlink(dp, name, ip-&gt;inum)</code>ï¼‰</strong></li>
<li>æœ€åŽæŠŠå…±äº«çš„<code>inode</code>ç¼“å­˜åŒæ­¥åˆ°diské‡Œè¾¹åŽ»</li>
</ol>
</blockquote>
<p><code>Sys_link</code> (kernel/sysfile.c:120) begins by fetching its arguments, two strings old and new (kernel/sysfile.c:125). Assuming old exists and is not a directory (kernel/sysfile.c:129-132), sys_link increments its <code>ip-&gt;nlink</code> count. Then sys_link calls <code>nameiparent</code> to find the parent directory and final path element of new (kernel/sysfile.c:145) and creates a new directory entry pointing at old â€™s <code>inode</code> (kernel/sysfile.c:148). The new parent directory must exist and be on the same device as the existing <code>inode</code>: <strong><code>inode</code> numbers only have a unique meaning on a single disk</strong>. If an error like this occurs, <code>sys_link</code> must go back and decrement <code>ip-&gt;nlink</code>.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Create the path new as a link to the same inode as old.</span>
<span class="n">uint64</span>
<span class="nf">sys_link</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">],</span><span class="w"> </span><span class="n">new</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">],</span><span class="w"> </span><span class="n">old</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argstr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">old</span><span class="p">,</span><span class="w"> </span><span class="n">MAXPATH</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">argstr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">MAXPATH</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="n">begin_op</span><span class="p">();</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">namei</span><span class="p">(</span><span class="n">old</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DIR</span><span class="p">){</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nameiparent</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">bad</span><span class="p">;</span>
<span class="w">  </span><span class="n">ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">dev</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dirlink</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">bad</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">  </span><span class="n">iput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>

<span class="w">  </span><span class="n">end_op</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="nl">bad</span><span class="p">:</span>
<span class="w">  </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">--</span><span class="p">;</span>
<span class="w">  </span><span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>Loggingéƒ¨åˆ†çš„å†…å®¹</p>
</blockquote>
<p>Transactions simplify the implementation because it requires updating multiple disk blocks, but we donâ€™t have to worry about the order in which we do them. They either will all succeed or none. For example, without transactions, updating <code>ip-&gt;nlink</code> before creating a link, would put the file system temporarily in an unsafe state, and a crash in between could result in havoc. With transactions we donâ€™t have to worry about this.</p>
<p><code>Sys_link</code> creates a new name for an existing <code>inode</code>.</p>
<h4 id="create"><code>create</code><a class="headerlink" href="#create" title="Permanent link">Â¶</a></h4>
<p>The function <code>create</code> (kernel/sysfile.c:242) <strong>creates a new name for a new <code>inode</code>.</strong></p>
<p>It is a generalization of the three file creation system calls: open with the O_CREATE flag makes a new ordinary file, <code>mkdir</code> makes a new directory, and <code>mkdev</code> makes a new device file.</p>
<ul>
<li>
<p>Like sys_link, create starts by calling <code>nameiparent</code> to get the <code>inode</code> of the parent directory.</p>
</li>
<li>
<p>It then calls <code>dirlookup</code> to check whether the name already exists (kernel/sysfile.c:252).</p>
</li>
<li>
<p><strong>If the name does exist</strong>, <code>create</code>â€™s behavior depends on which system call it is being used for:</p>
</li>
<li>
<p>open has different semantics from <code>mkdir</code> and <code>mkdev</code>.</p>
</li>
<li>
<p>If create is being used on behalf of open (type == T_FILE) and the name that exists is itself a regular file, then open treats that as a success, so create does too (kernel/sysfile.c:256).</p>
</li>
<li>
<p>Otherwise, it is an error (kernel/sysfile.c:257-258).</p>
</li>
<li>
<p><strong>If the name does not already exist</strong>, create now allocates a new <code>inode</code> with <code>ialloc</code>(kernel/sysfile.c:261).</p>
</li>
</ul>
<p>I**f the new <code>inode</code> is a directory, create initializes it with . and .. entries.**</p>
<p>Finally, now that the data is initialized properly, create can link it into the parent directory (kernel/sysfile.c:274). Create, like sys_link, holds two <code>inode</code> locks simultaneously: <code>ip</code> and <code>dp</code>. <strong>There is no possibility of deadlock because the <code>inode</code> <code>ip</code> is freshly allocated: no other process in the system will hold <code>ip</code> â€™s lock and then try to lock <code>dp</code>.</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="o">*</span>
<span class="n">create</span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">type</span><span class="p">,</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">major</span><span class="p">,</span><span class="w"> </span><span class="kt">short</span><span class="w"> </span><span class="n">minor</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">dp</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">];</span>
<span class="w">  </span><span class="c1">// èŽ·å¾—æ–‡ä»¶å¤¹å¯¹åº”çš„inode</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">dp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nameiparent</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">ilock</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// æŸ¥çœ‹æ–‡ä»¶å¤¹ä¸­çš„æ¯ä¸€ä¸ªdrientï¼Œä¿è¯æ²¡æœ‰é‡åçš„inode</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dirlookup</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// åå­—é‡å¤</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">    </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// åå­—é‡å¤çš„inodeæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œç›´æŽ¥è¿”å›žå·²ç»å­˜åœ¨çš„æ–‡ä»¶</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_FILE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_FILE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DEVICE</span><span class="p">))</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// å¦åˆ™è¿”å›žé”™è¯¯</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// è¿™é‡Œå¯ä»¥ä¿è¯dpä¸­æ²¡æœ‰å«nameçš„æ–‡ä»¶</span>
<span class="w">  </span><span class="c1">// ialloc,ç»™è¿™ä¸ªnameåˆ†é…ä¸€ä¸ªinode</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ialloc</span><span class="p">(</span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">type</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"create: ialloc"</span><span class="p">);</span>

<span class="w">  </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">major</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">minor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">minor</span><span class="p">;</span>
<span class="w">  </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">iupdate</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// å¦‚æžœè¿™ä¸ªinodeä»£è¡¨çš„æ˜¯ä¸€ä¸ªæ–‡ä»¶å¤¹</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DIR</span><span class="p">){</span><span class="w">  </span><span class="c1">// Create . and .. entries.</span>
<span class="w">    </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">nlink</span><span class="o">++</span><span class="p">;</span><span class="w">  </span><span class="c1">// for ".."</span>
<span class="w">    </span><span class="n">iupdate</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// No ip-&gt;nlink++ for ".": avoid cyclic ref count.</span>
<span class="w">    </span><span class="c1">// ç»™è¿™ä¸ªæ–‡ä»¶å¤¹åˆå§‹åŒ–ä¸¤ä¸ªåŸºæœ¬çš„dirent . å’Œ ..</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">dirlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="s">"."</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">dirlink</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span><span class="w"> </span><span class="s">".."</span><span class="p">,</span><span class="w"> </span><span class="n">dp</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">panic</span><span class="p">(</span><span class="s">"create dots"</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// æœ€åŽï¼ŒæŠŠè¿™ä¸ªæ–‡ä»¶inodeæ”¾åˆ°æ–‡ä»¶å¤¹dpçš„å…¶ä¸­ä¸€ä¸ªdirentä¸­</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">dirlink</span><span class="p">(</span><span class="n">dp</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"create: dirlink"</span><span class="p">);</span>

<span class="w">  </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">dp</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="sys_open"><code>sys_open</code><a class="headerlink" href="#sys_open" title="Permanent link">Â¶</a></h4>
<p>Using create, it is easy to implement <code>sys_open</code>, <code>sys_mkdir</code>, and <code>sys_mknod</code>.</p>
<p>Sys_open (kernel/sysfile.c:287) is the most complex, because creating a new file is only a small part of what it can do.</p>
<ul>
<li>
<p><strong>If open is passed the O_CREATE flag, it calls create</strong> (kernel/sysfile.c:301).</p>
</li>
<li>
<p><strong>Otherwise, it calls <code>namei</code> (kernel/sysfile.c:307). Create returns a locked <code>inode</code>, but <code>namei</code> does not, so sys_open must lock the <code>inode</code> itself.</strong> This provides a convenient place to check that directories are only opened for reading, not writing.</p>
</li>
<li>
<p>Assuming the <code>inode</code> was obtained one way or the other, <code>sys_open</code> allocates a file and a file descriptor (kernel/sysfile.c:325) and then fills in the file (kernel/sysfile.c:337-342).</p>
</li>
</ul>
<p>Note that no other process can access the partially initialized file since it is only in the current processâ€™s table.</p>
<div class="highlight"><pre><span></span><code><span class="n">uint64</span>
<span class="nf">sys_open</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="n">path</span><span class="p">[</span><span class="n">MAXPATH</span><span class="p">];</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">omode</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">f</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">inode</span><span class="w"> </span><span class="o">*</span><span class="n">ip</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argstr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">MAXPATH</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">argint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">omode</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="n">begin_op</span><span class="p">();</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">omode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">O_CREATE</span><span class="p">){</span>
<span class="w">    </span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">create</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="w"> </span><span class="n">T_FILE</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">namei</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">      </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DIR</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">omode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="p">){</span>
<span class="w">      </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">      </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DEVICE</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">NDEV</span><span class="p">)){</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// è¿™é‡Œä¸€å®šæ‹¿åˆ°äº†ä¸€ä¸ªinode</span>
<span class="w">  </span><span class="c1">// æŽ¥ä¸‹æ¥ä¸ºinodeåˆ†é…ä¸€ä¸ªå¥æŸ„</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filealloc</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdalloc</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="w">      </span><span class="n">fileclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="w">    </span><span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">    </span><span class="n">end_op</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// åˆå§‹åŒ–å¥æŸ„fdä¸­çš„ç»†èŠ‚</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_DEVICE</span><span class="p">){</span>
<span class="w">    </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD_DEVICE</span><span class="p">;</span>
<span class="w">    </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">major</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">major</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD_INODE</span><span class="p">;</span>
<span class="w">    </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">off</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">ip</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ip</span><span class="p">;</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">readable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">omode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">O_WRONLY</span><span class="p">);</span>
<span class="w">  </span><span class="n">f</span><span class="o">-&gt;</span><span class="n">writable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">omode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">O_WRONLY</span><span class="p">)</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">omode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">O_RDWR</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">omode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">O_TRUNC</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">T_FILE</span><span class="p">){</span>
<span class="w">    </span><span class="n">itrunc</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">iunlock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
<span class="w">  </span><span class="n">end_op</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">fd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="sys_pipe"><code>sys_pipe</code><a class="headerlink" href="#sys_pipe" title="Permanent link">Â¶</a></h4>
<p>Chapter 7 examined the implementation of pipes before we even had a file system. The function <code>sys_pipe</code> connects that implementation to the file system by providing a way to create a pipe pair. Its argument is a pointer to space for two integers, where it will record the two new file descriptors. Then it allocates the pipe and installs the file descriptors.</p>
<blockquote>
<p><code>int pipe(int p[])</code></p>
<p>è¿™é‡Œè®ºè¿°ä¸€ä¸‹ï¼Œpipeæ˜¯å¦‚ä½•è®©è¿›ç¨‹é—´çš„æ²Ÿé€šæˆä¸ºå¯èƒ½çš„ã€‚pipe ç³»ç»Ÿè°ƒç”¨ä¼šåˆ›å»ºä¸¤ä¸ªå¥æŸ„å‡ºæ¥ï¼Œè¿™ä¸¤ä¸ªå¥æŸ„ä¼šè¢«å­˜å‚¨åœ¨åˆ›å»ºpipeçš„è¿›ç¨‹Açš„open fileè¡¨ä¸­ã€‚å¦‚æžœæˆ‘ä»¬ä½¿ç”¨forkï¼Œé‚£ä¹ˆå­è¿›ç¨‹Bå°±ä¼šå¤åˆ¶ä¸€ä»½è¿›ç¨‹Aå†…å­˜ç©ºé—´ï¼Œä»Žè€Œï¼Œå­è¿›ç¨‹Bä¹Ÿå°±èƒ½ä½¿ç”¨è¿›ç¨‹Aä¸­åˆ›é€ å‡ºçš„pipeäº†ã€‚</p>
<p>ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿›ç¨‹Aå’Œè¿›ç¨‹Bçš„å¥æŸ„è¡¨ä¸­æœ‰ç€ç›¸åŒçš„ä¸¤ä¸ªä¸ªå¥æŸ„ï¼Œè¿™ä¸¤ä¸ªå¥æŸ„æŒ‡å‘äº†åŒä¸€å—å†…æ ¸æ€å¼€è¾Ÿçš„å†…å­˜ç©ºé—´ï¼Œè¿™å—ç©ºé—´å°±æ˜¯æ‰€è°“çš„ç®¡é“äº†ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">uint64</span>
<span class="nf">sys_pipe</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">fdarray</span><span class="p">;</span><span class="w"> </span><span class="c1">// user pointer to array of two integers</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">*</span><span class="n">rf</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">wf</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">fd0</span><span class="p">,</span><span class="w"> </span><span class="n">fd1</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// æ‹¿åˆ°ç”¨æˆ·ä¼ å…¥çš„p[]</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">fdarray</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// é€šè¿‡pipeallocèŽ·å¾—ä¸¤ä¸ªå¥æŸ„</span>
<span class="w">  </span><span class="c1">// ä¸€ä¸ªç”¨æ¥è¯»ï¼Œä¸€ä¸ªç”¨æ¥å†™</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">pipealloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rf</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wf</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="n">fd0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// é€šè¿‡fdallocæŠŠä¸¤ä¸ªå¥æŸ„å†™å…¥è¿›ç¨‹çš„fdè¡¨ä¸­</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">fd0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdalloc</span><span class="p">(</span><span class="n">rf</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">fd1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fdalloc</span><span class="p">(</span><span class="n">wf</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">fd0</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="n">rf</span><span class="p">);</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="n">wf</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// æŠŠfd0å’Œfd1å†™å…¥ç”¨æˆ·ç©ºé—´çš„æ•°ç»„ä¸­</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">fdarray</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fd0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd0</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span>
<span class="w">     </span><span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">fdarray</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd0</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">fd1</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">fd1</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ofile</span><span class="p">[</span><span class="n">fd1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="n">rf</span><span class="p">);</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="n">wf</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="kt">int</span>
<span class="nf">pipealloc</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">**</span><span class="n">f0</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">file</span><span class="w"> </span><span class="o">**</span><span class="n">f1</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="w"> </span><span class="o">*</span><span class="n">pi</span><span class="p">;</span>

<span class="w">  </span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="o">*</span><span class="n">f0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="o">*</span><span class="n">f0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filealloc</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filealloc</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">bad</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">((</span><span class="n">pi</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">pipe</span><span class="o">*</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">bad</span><span class="p">;</span>
<span class="w">  </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">readopen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">writeopen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nwrite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">nread</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pi</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="s">"pipe"</span><span class="p">);</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">readable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">writable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD_PIPE</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">readable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">writable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pipe</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pi</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w"> </span><span class="nl">bad</span><span class="p">:</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
<span class="w">    </span><span class="n">kfree</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pi</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">)</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="o">*</span><span class="n">f0</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)</span>
<span class="w">    </span><span class="n">fileclose</span><span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="84-logging-layer">8.4 Logging layer<a class="headerlink" href="#84-logging-layer" title="Permanent link">Â¶</a></h3>
<p>One of the most interesting problems in file system design is <strong>crash recovery</strong>. The problem arises because many file-system operations involve multiple writes to the disk, and <strong>a crash after a subset of the writes may leave the on-disk file system in an inconsistent state</strong>. For example, suppose a crash occurs during file truncation (setting the length of a file to zero and freeing its content blocks). Depending on the order of the disk writes, the crash may either leave an <code>inode</code> with a reference to a content block that is marked free, or it may leave an allocated but unreferenced content block.</p>
<blockquote>
<p>crashå¸¦æ¥çš„é—®é¢˜ï¼š</p>
<ol>
<li><code>inode</code>ä¸­ä¾ç„¶æŒ‡å‘ç€ä¸€å—è¢«æ ‡è®°ä¸ºfreeçš„BLOCKï¼ˆä¸¥é‡ï¼‰</li>
<li>BLOCKè¢«å†™å…¥äº†æ•°æ®ä½†<code>inode</code>æ²¡æœ‰æŒ‡å‘å®ƒ</li>
</ol>
</blockquote>
<h4 id="crash-handling">Crash Handling<a class="headerlink" href="#crash-handling" title="Permanent link">Â¶</a></h4>
<p>The latter is relatively benign, but an <code>inode</code> that refers to a freed block is likely to cause serious problems after a reboot. <strong>After reboot, the kernel might allocate that block to another file, and now we have two different files pointing unintentionally to the same block</strong>. If xv6 supported multiple users, this situation could be a security problem, since the old fileâ€™s owner would be able to read and write blocks in the new file, owned by a different user.</p>
<blockquote>
<p>è§£å†³æ–¹æ¡ˆ</p>
<ol>
<li>å°†æ‰€æœ‰çš„diskå†™è¯·æ±‚éƒ½å†™å…¥diskä¸Šçš„logåŒºåŸŸ</li>
<li>å½“logäº†æ‰€æœ‰çš„å†™è¯·æ±‚åŽï¼Œå†™å…¥ä¸€ä¸ªcommit recordç”¨æ¥è¡¨ç¤ºä¸€ä¸ªå®Œæ•´çš„æ“ä½œå¯ä»¥è¿›è¡Œ</li>
<li>å¼€å§‹çœŸæ­£å‘diskå†™å…¥æ•°æ®</li>
<li>åˆ é™¤ç›¸å…³çš„logä¿¡æ¯</li>
</ol>
</blockquote>
<p>Xv6 solves the problem of crashes during file-system operations with a simple form of logging. <strong>An xv6 system call does not directly write the on-disk file system data structures. Instead, it places a description of all the disk writes it wishes to make in a log on the disk.</strong></p>
<p>Once the system call has logged all of its writes, it writes a special commit record to the disk indicating that the log contains a complete operation. At that point the system call copies the writes to the on-disk file system data structures. After those writes have completed, the system call erases the log on disk.</p>
<blockquote>
<p>file systemçš„æ¢å¤è¿‡ç¨‹ï¼ˆå¼€å§‹äºŽè¿è¡Œä»»ä½•ç¨‹åºä¹‹å‰ï¼‰</p>
</blockquote>
<p>If the system should crash and reboot, the file-system code recovers from the crash as follows, <strong>before running any processes</strong>.</p>
<ul>
<li>
<p>If the log is <strong>marked</strong> as containing a complete operation, then the recovery code <strong>copies the writes to where they belong in the on-disk</strong> file system.</p>
</li>
<li>
<p>If the log is <strong>not marked</strong> as containing a complete operation, the recovery code ignores the log. The recovery code finishes by <strong>erasing the log</strong>.</p>
</li>
</ul>
<p>Why does xv6â€™s log solve the problem of crashes during file system operations?</p>
<ul>
<li>
<p>If the crash occurs before the operation commits, then the log on disk will not be marked as complete, the recovery code will ignore it, and the state of the disk will be as if the operation had not even started.</p>
</li>
<li>
<p>If the crash occurs after the operation commits, then recovery will replay all of the operationâ€™s writes, perhaps repeating them if the operation had started to write them to the on-disk data structure.</p>
</li>
</ul>
<p>In either case, <strong>the log makes operations atomic with respect to crashes</strong>: after recovery, <strong>either all of the operationâ€™s writes appear on the disk, or none of them appear.</strong></p>
<h3 id="85-log-design">8.5 Log design<a class="headerlink" href="#85-log-design" title="Permanent link">Â¶</a></h3>
<p>The log resides at a known fixed location, specified in the superblock.</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220716230656087.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220716230656087" src="../../../../assets/Operating%20Systems.assets/image-20220716230656087.png"></a></p>
<p>It consists of a header block followed by a sequence of updated block copies (â€œlogged blocksâ€).</p>
<p>The <strong>header block</strong> contains <u>an array of sector numbers</u>, one for each of the logged blocks, <u>and the count of log blocks</u>.</p>
<p>The <strong>count</strong> in the header block on disk is <strong>either zero</strong>, indicating that there is <strong>no transaction in the log</strong>, or <strong>nonzero</strong>, indicating that the <strong>log contains a complete committed transaction</strong> with the indicated number of logged blocks.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Contents of the header block, used for both the on-disk header block</span>
<span class="c1">// and to keep track in memory of logged block# before commit.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">logheader</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">block</span><span class="p">[</span><span class="n">LOGSIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span><span class="w"> </span><span class="nc">log</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">spinlock</span><span class="w"> </span><span class="n">lock</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">start</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">outstanding</span><span class="p">;</span><span class="w"> </span><span class="c1">// how many FS sys calls are executing.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">committing</span><span class="p">;</span><span class="w">  </span><span class="c1">// in commit(), please wait.</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">dev</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">logheader</span><span class="w"> </span><span class="n">lh</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<blockquote>
<p>è¿™é‡Œè¦å¯¹ç…§ç€ä»£ç åŽ»çœ‹</p>
</blockquote>
<p>Xv6 writes the header block when a transaction commits, but not before, and sets the count to zero after copying the logged blocks to the file system. Thus a crash midway through a transaction will result in a count of zero in the logâ€™s header block; a crash after a commit will result in a non-zero count.</p>
<hr>
<blockquote>
<p>ä¸‹é¢çš„è¿™ä¸¤ç‚¹åœ¨8.6èŠ‚çš„<code>end_op</code>ä¸­æœ‰è¯¦ç»†çš„é˜è¿°ï¼Œåº”è¯¥ç»“åˆç€ä»£ç ç†æ¸…é€»è¾‘å†æ¥çœ‹è¿™é‡Œçš„ç»“è®º</p>
</blockquote>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220723205203167.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220723205203167" src="../../../../assets/Operating%20Systems.assets/image-20220723205203167.png"></a></p>
<h4 id="challenge-concurrent-fs-syscalls">Challenge: Concurrent FS <code>Syscalls</code><a class="headerlink" href="#challenge-concurrent-fs-syscalls" title="Permanent link">Â¶</a></h4>
<p>Each system callâ€™s code indicates the start and end of the sequence of writes that must be atomic with respect to crashes. To allow concurrent execution of file-system operations by different processes, <strong>the logging system can accumulate the writes of multiple system calls into one transaction</strong>. Thus a single commit may involve the writes of multiple complete system calls. To avoid splitting a system call across transactions, the logging system only commits when no file-system system calls are underway.</p>
<p>The idea of <strong>committing several transactions together is known as <code>group commit</code></strong>.</p>
<ul>
<li>Group commit <strong>reduces the number of disk operations</strong> because it amortizes(åˆ†æ‘Š) the fixed cost of a commit over multiple operations.</li>
<li>Group commit also hands the disk system more concurrent writes at the same time, perhaps allowing the disk to write them all during a single disk rotation. Xv6â€™s <code>virtio</code> driver doesnâ€™t support this kind of batching, but xv6â€™s file system design allows for it.</li>
</ul>
<h4 id="challenge-max-log-size">Challenge: MAX log size<a class="headerlink" href="#challenge-max-log-size" title="Permanent link">Â¶</a></h4>
<p>Xv6 dedicates a fixed amount of space on the disk to hold the log.</p>
<p>The total number of blocks written by the system calls in a transaction must fit in that space. This has <strong>two consequences</strong>.</p>
<blockquote>
<p>ç¬¬ä¸€ä¸ªç»“è®ºï¼Œè¯¦è§<code>file write</code></p>
</blockquote>
<ul>
<li><strong>No single system call can be allowed to write more distinct blocks than there is space in the log</strong>. This is not a problem for most system calls, but two of them can potentially write many blocks: write and unlink. A large file write may write many data blocks and many bitmap blocks as well as an <code>inode</code> block; unlinking a large file might write many bitmap blocks and an <code>inode</code>. Xv6â€™s write system call breaks up large writes into multiple smaller writes that fit in the log, and unlink doesnâ€™t cause problems because in practice the xv6 file system uses only one bitmap block.</li>
<li>The other consequence of limited log space is that <strong>the logging system cannot allow a system call to start unless it is certain that the system callâ€™s writes will fit in the space remaining in the log.</strong></li>
</ul>
<h3 id="86-code-logging">8.6 Code: logging<a class="headerlink" href="#86-code-logging" title="Permanent link">Â¶</a></h3>
<p>A typical use of the log in a system call looks like this:</p>
<div class="highlight"><pre><span></span><code><span class="n">begin_op</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(...);</span>
<span class="n">bp</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">[...]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="n">log_write</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">end_op</span><span class="p">();</span>
</code></pre></div>
<h4 id="begin_op"><code>begin_op</code><a class="headerlink" href="#begin_op" title="Permanent link">Â¶</a></h4>
<p><code>begin_op</code> (kernel/log.c:126) waits until the logging system is not currently committing, and until there is enough unreserved log space to hold the writes from this call. <strong><code>log.outstanding</code> counts the number of system calls that have reserved log space;</strong> the total reserved space is <code>log.outstanding</code> times MAXOPBLOCKS. Incrementing <code>log.outstanding</code> both reserves space and prevents a commit from occurring during this system call. The code conservatively assumes that each system call might write up to MAXOPBLOCKS distinct blocks.</p>
<blockquote>
<p><code>begin_op</code>åœ¨logè¿›è¡Œcommitçš„æ—¶å€™æ˜¯ä¸å¯ä»¥å†å‘logä¸­å†™å…¥çš„ï¼Œè¿™ä¸ªå¾ˆå¥½ç†è§£ã€‚</p>
<p><code>begin_op</code><strong>åœ¨operationå¯èƒ½è€—å°½logç©ºé—´çš„æ—¶å€™</strong>ï¼Œä¹Ÿä¼š**è¿›å…¥sleepè®©å‡ºCPU**ã€‚è¿™é‡Œå’Œä¸Šä¸€èŠ‚æåˆ°çš„ä¸¤ä¸ªchallengeæœ‰å…³ã€‚æ–‡ä»¶ç³»ç»Ÿæ”¯æŒå¤šä¸ªè¿›ç¨‹å¹¶å‘çš„å‘logå†™å…¥è‡ªå·±çš„è¯·æ±‚ï¼Œå½“å¤šä¸ªè¿›ç¨‹éƒ½å†™å®Œäº†ä»¥åŽï¼Œlogå¯ä»¥æŠŠå¤šä¸ªè¿›ç¨‹çš„è¯·æ±‚æ•´åˆæˆä¸ºä¸€ä¸ªï¼Œå½“ä½œä¸€ä¸ªcommitæäº¤ã€‚ä½†è¿™é‡Œä¼šæ¶‰åŠåˆ°ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æžœä¸€æ¬¡æœ‰å¤ªå¤šçš„è¿›ç¨‹å‘logä¸­å†™å…¥è‡ªå·±çš„è¯·æ±‚ï¼Œé‚£ä¹ˆæœ‰å¯èƒ½å¯¼è‡´**å¤šä¸ªè¿›ç¨‹éƒ½æ²¡æœ‰å®Œæˆè‡ªå·±çš„å®Œæ•´æ–‡ä»¶æ“ä½œï¼Œä½†æ˜¯logå·²ç»è¢«å¡«æ»¡äº†çš„é—®é¢˜**ï¼Œè¿™æ ·çš„è¯ï¼Œlogæ˜¯ä¸èƒ½è¿›è¡Œcommitçš„ï¼Œå› ä¸ºå¦‚æžœcommitäº†ï¼Œæ‰€æœ‰è¿›ç¨‹çš„æ–‡ä»¶æ“ä½œéƒ½æ˜¯ä¸å®Œæ•´çš„ã€‚æ‰€ä»¥ï¼Œè¿™é‡ŒåŠ å…¥äº†è¿™æ ·ä¸€ä¸ªåˆ¤æ–­ï¼Œæ¥é™åˆ¶èƒ½ä½¿ç”¨logçš„è¿›ç¨‹æ•°é‡ã€‚</p>
<p>æ€»ç»“ä¸€ä¸‹ï¼Œ<code>begin_op</code>ç”¨æ¥è¡¨ç¤ºä¸€ä¸ªæ–‡ä»¶system callçš„å¼€å§‹ï¼ŒåŒæ—¶ä¹Ÿæ˜¯è¿›ç¨‹ä½¿ç”¨logå‰çš„ä¸€é“å…³å¡ï¼Œä¿è¯logè¢«å¹¶å‘çš„å†™å…¥å¹¶ä¸”ä¸ä¼šè¢«è¿‡å¤šè¿›ç¨‹è€—å°½logç©ºé—´ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// called at the start of each FS system call.</span>
<span class="kt">void</span>
<span class="nf">begin_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">){</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">MAXOPBLOCKS</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">LOGSIZE</span><span class="p">){</span>
<span class="w">      </span><span class="c1">// this op might exhaust log space; wait for commit.</span>
<span class="w">      </span><span class="n">sleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="log_write"><code>log_write</code><a class="headerlink" href="#log_write" title="Permanent link">Â¶</a></h4>
<p><code>log_write</code> (kernel/log.c:214) acts as a proxy for <code>bwrite</code>.</p>
<ul>
<li>
<p>It records the blockâ€™s sector number in memory, reserving it a slot in the log on disk, and</p>
</li>
<li>
<p>pins the buffer in the block cache to prevent the block cache from evicting it.</p>
</li>
</ul>
<p>The block must stay in the cache until committed: until then, the cached copy is the only record of the modification; it cannot be written to its place on disk until after commit; and other reads in the same transaction must see the modifications.</p>
<p><code>log_write</code> notices when a block is written multiple times during a single transaction, and allocates that block the same slot in the log. This optimization is often called <strong>absorption</strong>.</p>
<p><u>It is common that, for example, the disk block containing <code>inodes</code> of several files is written several times within a transaction.</u> By absorbing several disk writes into one, the file system can save log space and can achieve better performance because only one copy of the disk block must be written to disk.</p>
<blockquote>
<p><code>log_write</code>æ˜¯å¯¹<code>bwrite</code>çš„ä¸€ç§ä»£ç†ï¼Œå®ƒä¸»è¦å¹²äº†ä¸¤ä»¶äº‹ï¼š</p>
<ol>
<li>æŠŠè¦è¿›è¡Œç£ç›˜å†™å…¥çš„BLOCK Noè®°å½•åœ¨logçš„headerçš„æ•°ç»„ä¸­</li>
<li>ä¿è¯è®°å½•åœ¨æ•°ç»„ä¸­çš„BLOCKä¸ä¼šè¢«é©±é€å‡ºbuffer cache</li>
</ol>
<p>å…ˆæ¥è¯´è¯´**é˜²æ­¢é©±é€çš„åŽŸå› **ï¼Œlogè¦åœ¨ä¸€ä¸ªsystem callå…¨éƒ¨å®Œæˆä¹‹åŽæ‰ä¼šè¿›è¡ŒçœŸæ­£çš„å†™å…¥å·¥ä½œï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨åŠ å…¥logçš„æ•°ç»„ä¸­åŽï¼Œdiskè¿˜ä¸èƒ½åŒæ­¥buffer cacheé‡Œä¿®æ”¹çš„å†…å®¹ï¼Œæ‰€ä»¥ï¼Œå¦‚æžœæˆ‘ä»¬è®©è¿™ä¸ªbufferè¢«evictäº†ï¼Œé‚£ä¹ˆç›´æŽ¥å†™å…¥çš„å†…å®¹ä¹Ÿå°±æ²¡æœ‰æœºä¼šè¢«åŒæ­¥åˆ°diskä¸Šäº†ã€‚æ‰€ä»¥ä½¿ç”¨<code>bpin()</code>ç»™bufferçš„<code>refcnt++</code>ï¼Œä¿è¯LRUä¸ä¼šå¤ºèµ°è¿™ä¸ªbuffer cacheã€‚</p>
<p>è¿™é‡Œè¿˜ä½“çŽ°äº†<code>absorbtion</code>ï¼Œç®€å•çš„æ¥è¯´ï¼Œå°±æ˜¯æˆ‘ä»¬åœ¨ä¸€ä¸ªsystem callä¸­å¯èƒ½ä¼šå¤šæ¬¡å†™å…¥åŒä¸€å—blockã€‚ä¸¾ä¸ªä¾‹å­ï¼Œ<code>inodes</code>å°±æœ‰å¯èƒ½å¤„äºŽåŒä¸€å—BLOCKï¼Œæˆ‘ä»¬å¯èƒ½ä¸€æ¬¡éœ€è¦æ›´æ–°å¤šä¸ªåœ¨åŒä¸€å—BLOCKä¸­çš„<code>inodes</code>ï¼Œæ‰€ä»¥æˆ‘ä»¬æ²¡å¿…è¦åœ¨æ•°ç»„ä¸­è®°å½•è¿™ä¸ªBLOCKç¼–å·ä¸¤æ¬¡ï¼Œå› ä¸ºæˆ‘ä»¬åªç”¨ä¸€æ¬¡write diskå°±å¯ä»¥æŠŠå¯¹è¿™å—BLOCKçš„å¤šæ¬¡æ›´æ–°ç»™åŒæ­¥åˆ°diskäº†ã€‚</p>
<p>æ€»ç»“ä¸€ä¸‹ï¼Œ<code>log_write</code>å¹¶æ²¡æœ‰è¿›è¡Œå¯¹ç£ç›˜çš„å†™å…¥å·¥ä½œï¼Œä»–åªæ˜¯æŠŠæ‰€æœ‰çš„å†™è¯·æ±‚æ”¾åˆ°äº†logä¹‹ä¸­ï¼ˆè¿™ä¸ªlogæŒ‡çš„æ˜¯å†…å­˜ä¸Šçš„logï¼‰</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="kt">void</span>
<span class="nf">log_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">LOGSIZE</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"too big a transaction"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"log_write outside of trans"</span><span class="p">);</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">)</span><span class="w">   </span><span class="c1">// log absorbtion</span>
<span class="w">      </span><span class="k">break</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="o">-&gt;</span><span class="n">blockno</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Add new block to log?</span>
<span class="w">    </span><span class="n">bpin</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="o">++</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<h4 id="end_op"><code>end_op</code><a class="headerlink" href="#end_op" title="Permanent link">Â¶</a></h4>
<blockquote>
<p><code>end_op</code>ä¸»è¦å¹²äº†ä¸¤ä»¶äº‹</p>
<ol>
<li>å°†å¯¹logè¿›è¡Œå†™å…¥çš„system callçš„æ•°é‡å‡1</li>
<li><strong>commit()</strong></li>
</ol>
<p><code>end_op</code>çš„æ ¸å¿ƒæ˜¯commitå‡½æ•°ï¼Œé™¤æ­¤ä¹‹å¤–ï¼Œå®ƒæ‰€åšçš„å°±æ˜¯å¦‚æžœcommitçš„æ¡ä»¶æ²¡æœ‰è¾¾æˆï¼ŒåŠè¿˜æœ‰system callæ²¡æœ‰å®Œæˆæ•´ä¸ªäº‹åŠ¡ï¼Œé‚£ä¹ˆåœ¨<code>begin_op</code>è¿›å…¥é˜»å¡žçš„è¿›ç¨‹ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// called at the end of each FS system call.</span>
<span class="c1">// commits if this was the last outstanding operation.</span>
<span class="kt">void</span>
<span class="nf">end_op</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">do_commit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="p">)</span>
<span class="w">    </span><span class="n">panic</span><span class="p">(</span><span class="s">"log.committing"</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">outstanding</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="n">do_commit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// begin_op() may be waiting for log space,</span>
<span class="w">    </span><span class="c1">// and decrementing log.outstanding has decreased</span>
<span class="w">    </span><span class="c1">// the amount of reserved space.</span>
<span class="w">    </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">do_commit</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// call commit w/o holding locks, since not allowed</span>
<span class="w">    </span><span class="c1">// to sleep with locks.</span>
<span class="w">    </span><span class="n">commit</span><span class="p">();</span>
<span class="w">    </span><span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="n">committing</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">wakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">);</span>
<span class="w">    </span><span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">log</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p><code>end_op</code> (kernel/log.c:146) first decrements the count of outstanding system calls.</p>
</li>
<li>
<p>If the count is now zero, it commits the current transaction by calling <code>commit()</code>.</p>
</li>
</ul>
<blockquote>
<p>ä¸‹é¢å°±æ˜¯<code>end_op</code>çš„æ ¸å¿ƒï¼Œä¹Ÿæ˜¯logè¿™ä¸€èŠ‚çš„æ ¸å¿ƒï¼Œcommitäº†ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">commit</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">write_log</span><span class="p">();</span><span class="w">     </span><span class="c1">// Write modified blocks from cache to log</span>
<span class="w">    </span><span class="n">write_head</span><span class="p">();</span><span class="w">    </span><span class="c1">// Write header to disk -- the real commit</span>
<span class="w">    </span><span class="n">install_trans</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Now install writes to home locations</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">write_head</span><span class="p">();</span><span class="w">    </span><span class="c1">// Erase the transaction from the log</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<ul>
<li>
<p>There are four stages in this process. <code>write_log()</code> (kernel/log.c:178) copies each block modified in the transaction from the buffer cache to its slot in the log on disk.</p>
<blockquote>
<p>ç¬¬ä¸€æ­¥ï¼ŒæŠŠlog headerä¸­è®°å½•çš„æ¯ä¸€ä¸ªè¢«ä¿®æ”¹çš„BLOCKä¸­ä»Žä»–ä»¬çš„buffer cacheä¸­ï¼Œè½¬ç§»åˆ°logå¯¹åº”çš„buffer cacheä¸­ã€‚ï¼ˆä¿®æ”¹è¿˜åœ¨å†…å­˜ä¹‹ä¸­ï¼‰</p>
<p>ç„¶åŽï¼ŒæŠŠlogä¸­çš„åœ¨buffer cacheä¸­çš„å†…å®¹åŒæ­¥åˆ°diskçš„logä¹‹ä¸­ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Copy modified blocks from cache to log.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">write_log</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">tail</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// log block</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">from</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span><span class="w"> </span><span class="c1">// cache block</span>
<span class="w">    </span><span class="n">memmove</span><span class="p">(</span><span class="n">to</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">from</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">);</span>
<span class="w">    </span><span class="n">bwrite</span><span class="p">(</span><span class="n">to</span><span class="p">);</span><span class="w">  </span><span class="c1">// write the log</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">from</span><span class="p">);</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><code>write_head()</code> (kernel/log.c:102) writes the header block to disk: this is the commit point, and a crash after the write will result in recovery replaying the transactionâ€™s writes from the log.</p>
<blockquote>
<p>ç¬¬äºŒæ­¥ï¼Œä¿®æ”¹å†…å­˜ä¸­çš„log headerï¼Œå°†è¿™æ¬¡äº‹åŠ¡æ¶‰åŠåˆ°çš„BLOCKæ•°é‡å†™å…¥åˆ°log headerå¯¹åº”çš„diskéƒ¨åˆ†</p>
<p>è¿™é‡Œæ˜¯**commitçœŸçš„å‘ç”Ÿçš„åœ°æ–¹**ï¼Œé‡ç‚¹åœ¨äºŽ<code>bwrite(buf)</code></p>
<p><code>bwrite(buf)</code>ä¹‹å‰æ–­ç”µï¼Œdiskçš„log headerä¸­n == 0ï¼Œæ‰€ä»¥ä¹‹å‰çš„äº‹åŠ¡å®Œå…¨ä¸ä½œæ•°ï¼Œä¸ä¼šåŒæ­¥åˆ°diskä¸Šã€‚</p>
<p><code>bwrite(buf)</code>ä¹‹åŽæ–­ç”µï¼Œdiskçš„log headerä¸­n ï¼= 0ï¼Œæ‰€ä»¥OSä¼šæŠŠlogä¸­å­˜å‚¨çš„nä¸ªBLOCKSä¸­çš„å†…å®¹åŒæ­¥åˆ°diskä¸Šã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Write in-memory log header to disk.</span>
<span class="c1">// This is the true point at which the</span>
<span class="c1">// current transaction commits.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">write_head</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">buf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">logheader</span><span class="w"> </span><span class="o">*</span><span class="n">hb</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">logheader</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">hb</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">bwrite</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="w">  </span><span class="n">brelse</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p><code>install_trans</code> (kernel/log.c:69) reads each block from the log and writes it to the proper place in the file system.</p>
<blockquote>
<p><code>install_trans</code>æ‰€åšçš„äº‹ï¼Œå°±æ˜¯æŠŠlogè®°å½•çš„BLOCKSå…¨éƒ¨åŒæ­¥åˆ°ä»–ä»¬åœ¨diskä¸Šçš„å¯¹åº”ä½ç½®ä¸ŠåŽ»ã€‚</p>
<p><code>install_trans</code>ä¼šåœ¨ä¸¤ç§æƒ…å†µä¸‹è¢«è°ƒç”¨</p>
<ol>
<li>æ¢å¤çš„æ—¶å€™</li>
<li>æ­£å¸¸çš„æ–‡ä»¶å†™æ“ä½œæ‰§è¡Œçš„æ—¶å€™</li>
</ol>
<p>å¯ä»¥çœ‹åˆ°ä»£ç ä¹Ÿå¯¹è¿™ä¸¤ç§æƒ…å†µè¿›è¡Œäº†åŒºåˆ†ï¼Œå¦‚æžœæ˜¯æ¢å¤ï¼Œé‚£å°±ä¸æ¶‰åŠé‡Šæ”¾buffer cacheçš„é—®é¢˜ï¼›å¦‚æžœæ˜¯æ­£å¸¸æ‰§è¡Œï¼Œé‚£å°±å¾—æŠŠ<code>begin_op</code>ç»™buffer cacheåŠ çš„å¼•ç”¨ç»™æ¶ˆé™¤ã€‚</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Copy committed blocks from log to their home location</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">install_trans</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">recovering</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span>

<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">tail</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">tail</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">lbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">start</span><span class="o">+</span><span class="n">tail</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// read log block</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">buf</span><span class="w"> </span><span class="o">*</span><span class="n">dbuf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bread</span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span><span class="w"> </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">block</span><span class="p">[</span><span class="n">tail</span><span class="p">]);</span><span class="w"> </span><span class="c1">// read dst</span>
<span class="w">    </span><span class="n">memmove</span><span class="p">(</span><span class="n">dbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">lbuf</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span><span class="w"> </span><span class="n">BSIZE</span><span class="p">);</span><span class="w">  </span><span class="c1">// copy block to dst</span>
<span class="w">    </span><span class="n">bwrite</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span><span class="w">  </span><span class="c1">// write dst to disk</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">recovering</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">bunpin</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">lbuf</span><span class="p">);</span>
<span class="w">    </span><span class="n">brelse</span><span class="p">(</span><span class="n">dbuf</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
</li>
<li>
<p>Finally <code>end_op</code> writes the log header with a count of zero;</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">commit</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">write_log</span><span class="p">();</span><span class="w">     </span><span class="c1">// Write modified blocks from cache to log</span>
<span class="w">    </span><span class="n">write_head</span><span class="p">();</span><span class="w">    </span><span class="c1">// Write header to disk -- the real commit</span>
<span class="w">    </span><span class="n">install_trans</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="c1">// Now install writes to home locations</span>
<span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">write_head</span><span class="p">();</span><span class="w">    </span><span class="c1">// Erase the transaction from the log</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>æœ€åŽæˆ‘ä»¬å†æ¬¡ä¿®æ”¹log headerä¸­çš„nå€¼ä¸º0ï¼Œå¹¶æŠŠå®ƒå†™å…¥disk</p>
<p><strong>æœ€åŽçš„è¿™æ¬¡å¯¹headerçš„å†™å…¥å¿…é¡»å‘ç”Ÿåœ¨ä¸‹ä¸€æ¬¡äº‹åŠ¡å¼€å§‹ä¹‹å‰</strong>ï¼Œ<code>end_op</code>ä¿è¯äº†è¿™ä¸€ç‚¹ã€‚å¦‚æžœä¸è¿™æ ·çš„è¯ï¼Œå¦‚æžœå‘ç”Ÿäº†crashï¼Œlogçš„diskä¸­è®°å½•çš„æ˜¯æ–°Transactionä¿å­˜åœ¨logä¸­çš„ä¿®æ”¹å†…å®¹ï¼Œè€Œnå´è¿˜æ˜¯ä¸Šä¸€ä¸ªTransactionçš„è®¡æ•°ã€‚</p>
<p>è¿™ä¹Ÿå°±è§£é‡Šäº†ï¼Œä¸€ä¸ªäº‹åŠ¡å¿…é¡»å…¨éƒ¨å®Œæˆä¹‹åŽï¼Œæ‰ä¼šå…è®¸æ–°çš„äº‹åŠ¡å¼€å§‹ã€‚</p>
</blockquote>
<p>this has to happen before the next transaction starts writing logged blocks, so that a crash doesnâ€™t result in recovery using one transactionâ€™s header with the subsequent transactionâ€™s logged blocks.</p>
<hr>
<p><code>recover_from_log</code> (kernel/log.c:116) is called from <code>initlog</code> (kernel/log.c:55), which is called from <code>fsinit</code>(kernel/fs.c:42) during boot before the first user process runs (kernel/proc.c:539). It reads the log header, and mimics the actions of end_op if the header indicates that the log contains a committed transaction.</p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="kt">void</span>
<span class="nf">recover_from_log</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">read_head</span><span class="p">();</span>
<span class="w">  </span><span class="n">install_trans</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// if committed, copy from log to disk</span>
<span class="w">  </span><span class="n">log</span><span class="p">.</span><span class="n">lh</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">  </span><span class="n">write_head</span><span class="p">();</span><span class="w"> </span><span class="c1">// clear the log</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="summary-figure">Summary Figure<a class="headerlink" href="#summary-figure" title="Permanent link">Â¶</a></h4>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220723210534296.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220723210534296" src="../../../../assets/Operating%20Systems.assets/image-20220723210534296.png"></a></p>
<h2 id="journaling-the-linux-ext2fs-filesystem">Journaling the Linux ext2fs Filesystem<a class="headerlink" href="#journaling-the-linux-ext2fs-filesystem" title="Permanent link">Â¶</a></h2>
<h2 id="labs">Labs<a class="headerlink" href="#labs" title="Permanent link">Â¶</a></h2>
<h3 id="gdb">GDB<a class="headerlink" href="#gdb" title="Permanent link">Â¶</a></h3>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>make<span class="w"> </span><span class="nv">CPUS</span><span class="o">=</span><span class="m">1</span><span class="w"> </span>qemu-gdb
***<span class="w"> </span>Now<span class="w"> </span>run<span class="w"> </span><span class="s1">'gdb'</span><span class="w"> </span><span class="k">in</span><span class="w"> </span>another<span class="w"> </span>window.<span class="w"> </span>qemu-system-riscv64<span class="w"> </span>-machine<span class="w"> </span>virt<span class="w"> </span>-bios<span class="w"> </span>none<span class="w"> </span>-kernel<span class="w"> </span>kernel/kernel<span class="w"> </span>-m<span class="w"> </span>128M<span class="w"> </span>-smp<span class="w"> </span><span class="m">3</span><span class="w"> </span>-nographic<span class="w"> </span>-drive<span class="w"> </span><span class="nv">file</span><span class="o">=</span>fs.img,if<span class="o">=</span>none,format<span class="o">=</span>raw,id<span class="o">=</span>x0<span class="w"> </span>-device<span class="w"> </span>virtio-blk-device,drive<span class="o">=</span>x0,bus<span class="o">=</span>virtio-mmio-bus.0<span class="w"> </span>-S<span class="w"> </span>-gdb<span class="w"> </span>tcp::26000
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="nb">echo</span><span class="w"> </span><span class="s2">"add-auto-load-safe-path </span><span class="k">$(</span><span class="nb">pwd</span><span class="k">)</span><span class="s2">/.gdbinit "</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>~/.gdbinit

$<span class="w"> </span>gdb-multiarch
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>layout<span class="w"> </span>split

<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>file<span class="w"> </span>user/_ls
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>b<span class="w"> </span>main
<span class="o">(</span>gdb<span class="o">)</span><span class="w"> </span>c
</code></pre></div>
<h3 id="lab-xv6-and-unix-utilities">Lab: Xv6 and Unix utilities<a class="headerlink" href="#lab-xv6-and-unix-utilities" title="Permanent link">Â¶</a></h3>
<h4 id="sleep_1">sleep<a class="headerlink" href="#sleep_1" title="Permanent link">Â¶</a></h4>
<p>æ®‹ç•™é—®é¢˜ï¼šwhileå¾ªçŽ¯ç”¨äºŽç¡®ä¿ç”¨æˆ·çš„è¾“å…¥åªæœ‰æ•°å­—ï¼Œä½†åœ¨<code>xv6</code> è¿è¡Œè¿‡ç¨‹ä¸­ä¼šæœ‰è¿è¡Œå¤±è´¥çš„æƒ…å†µã€‚æœªèƒ½å®šä½åŽŸå› ã€‚åˆ åŽ»whileå¯ä»¥å®Œç¾Žè¿è¡Œä½†é€»è¾‘ä¸å®Œæ•´ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="cp">##include "kernel/types.h"</span>
<span class="cp">##include "kernel/stat.h"</span>
<span class="cp">##include "user/user.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"usage: sleep ticks....</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="c1">//Since the end of s points to 0x0000 0000 (NULL)</span>
<span class="w">    </span><span class="c1">//So while can be terminated</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="sc">'0'</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">'9'</span><span class="p">)</span>
<span class="w">            </span><span class="n">s</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"only digits are allowed in inputs</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="w">            </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">ticks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">ticks</span><span class="p">);</span>

<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="pingpong">pingpong<a class="headerlink" href="#pingpong" title="Permanent link">Â¶</a></h4>
<p>è®°å¾—åœ¨ä½¿ç”¨å®Œfile descriptoråŽå°†å…¶å…³é—­ï¼Œå¦åˆ™å½“å¤šæ¬¡è¿è¡Œping pongåŽï¼Œ<code>pipe()</code>å°±æ²¡æœ‰å¤šä½™çš„file descriptorå¯ä¾›åˆ†é…äº†ã€‚</p>
<p><a class="glightbox" href="assets/Operating%20Systems.assets/image-20220309231419282.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img src="assets/Operating%20Systems.assets/image-20220309231419282.png" alt="image-20220309231419282" style="zoom: 50%;"></a></p>
<div class="highlight"><pre><span></span><code><span class="cp">##include "kernel/types.h"</span>
<span class="cp">##include "kernel/stat.h"</span>
<span class="cp">##include "user/user.h"</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">c2p</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">pipe</span><span class="p">(</span><span class="n">p2c</span><span class="p">);</span>
<span class="w">    </span><span class="n">pipe</span><span class="p">(</span><span class="n">c2p</span><span class="p">);</span>

<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">ball</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fork</span><span class="p">();</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"fork error"</span><span class="p">);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pid</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">read</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ball</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d: received ping</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">getpid</span><span class="p">());</span>

<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">write</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ball</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">write</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ball</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">p2c</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">wait</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="w">        </span><span class="n">read</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ball</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">close</span><span class="p">(</span><span class="n">c2p</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d: received pong</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">getpid</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="primes">primes(*)<a class="headerlink" href="#primes" title="Permanent link">Â¶</a></h4>
<h4 id="find">find<a class="headerlink" href="#find" title="Permanent link">Â¶</a></h4>
<h3 id="lab-system-calls">Lab: system calls<a class="headerlink" href="#lab-system-calls" title="Permanent link">Â¶</a></h3>
<p>æœ¬éƒ¨åˆ†è®°å½•äº†ç³»ç»Ÿè°ƒç”¨çš„æ•´ä¸ªè¿‡ç¨‹ï¼Œæ‰€æœ‰çš„å®žçŽ°ç»†èŠ‚è§<code>github</code>ã€‚</p>
<h4 id="system-call-tracing">System call tracing<a class="headerlink" href="#system-call-tracing" title="Permanent link">Â¶</a></h4>
<h5 id="user-mode_1">user mode<a class="headerlink" href="#user-mode_1" title="Permanent link">Â¶</a></h5>
<p>åœ¨user modeä¸­çš„<code>user/trace.c</code>ä¸­ï¼Œä½¿ç”¨äº†system call ï¼š<code>trace()</code>ã€‚</p>
<div class="highlight"><pre><span></span><code><span class="cp">##include "kernel/param.h"</span>
<span class="cp">##include "kernel/types.h"</span>
<span class="cp">##include "kernel/stat.h"</span>
<span class="cp">##include "user/user.h"</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">  </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">nargv</span><span class="p">[</span><span class="n">MAXARG</span><span class="p">];</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="sc">'0'</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="sc">'9'</span><span class="p">)){</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"Usage: %s mask command</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">fprintf</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">"%s: trace failed</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">argc</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAXARG</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="w">    </span><span class="n">nargv</span><span class="p">[</span><span class="n">i</span><span class="mi">-2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">exec</span><span class="p">(</span><span class="n">nargv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">nargv</span><span class="p">);</span>
<span class="w">  </span><span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p><code>trace()</code>è¢«å£°æ˜Žåœ¨<code>user/user.h</code>é‡Œï¼Œ</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">trace</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div>
<p><code>trace()</code>çš„å®šä¹‰åœ¨<code>usys.S</code>ä¸­ï¼Œå› ä¸ºæ‰€æœ‰çš„system calléƒ½å…·æœ‰ç›¸åŒå®šä¹‰çš„å½¢å¼ï¼Œæ‰€ä»¥ä¸‹è¾¹çš„ä»£ç <code>usys.pl</code>å¯ä»¥ç”¨æ¥æ‰¹é‡ç¼–å†™ä¸åŒsystem callçš„æ±‡ç¼–ä»£ç ã€‚</p>
<p>å…¶ä¸­ï¼Œ<code>li a7, SYS_${name}\n</code> è¿™ä¸€å¥æ˜¯å°†system callçš„ç¼–å·æ”¾å…¥<code>a7</code>å¯„å­˜å™¨å½“ä¸­ã€‚system callçš„ç¼–å·è®°å½•åœ¨<code>kernel/syscall.h</code>æ–‡ä»¶ä¸­ã€‚</p>
<p><code>ecall</code>é€šè¿‡ç¡¬ä»¶å®žçŽ°user modeè¿›å…¥kernel modeã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">##!/usr/bin/perl -w</span>
<span class="c1">## Generate usys.S, the stubs for syscalls.</span>
<span class="k">print</span><span class="w"> </span><span class="s">"# generated by usys.pl - do not edit\n"</span><span class="p">;</span>
<span class="k">print</span><span class="w"> </span><span class="s">"#include \"kernel/syscall.h\"\n"</span><span class="p">;</span>
<span class="k">sub</span><span class="w"> </span><span class="nf">entry</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">my</span><span class="w"> </span><span class="nv">$name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">shift</span><span class="p">;</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s">".global $name\n"</span><span class="p">;</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s">"${name}:\n"</span><span class="p">;</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s">" li a7, SYS_${name}\n"</span><span class="p">;</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s">" ecall\n"</span><span class="p">;</span>
<span class="w">    </span><span class="k">print</span><span class="w"> </span><span class="s">" ret\n"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">entry</span><span class="p">(</span><span class="s">"fork"</span><span class="p">);</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"exit"</span><span class="p">);</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"wait"</span><span class="p">);</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"pipe"</span><span class="p">);</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"read"</span><span class="p">);</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="o">.</span>
<span class="n">entry</span><span class="p">(</span><span class="s">"trace"</span><span class="p">);</span>
</code></pre></div>
<p><code>kernel/syscall.h</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">// System call numbers</span>
<span class="cp">##define SYS_fork    1</span>
<span class="cp">##define SYS_exit    2</span>
<span class="cp">##define SYS_wait    3</span>
<span class="cp">##define SYS_pipe    4</span>
<span class="cp">##define SYS_read    5</span>
<span class="cp">##define SYS_kill    6</span>
<span class="cp">##define SYS_exec    7</span>
<span class="cp">##define SYS_fstat   8</span>
<span class="cp">##define SYS_chdir   9</span>
<span class="cp">##define SYS_dup    10</span>
<span class="cp">##define SYS_getpid 11</span>
<span class="cp">##define SYS_sbrk   12</span>
<span class="cp">##define SYS_sleep  13</span>
<span class="cp">##define SYS_uptime 14</span>
<span class="cp">##define SYS_open   15</span>
<span class="cp">##define SYS_write  16</span>
<span class="cp">##define SYS_mknod  17</span>
<span class="cp">##define SYS_unlink 18</span>
<span class="cp">##define SYS_link   19</span>
<span class="cp">##define SYS_mkdir  20</span>
<span class="cp">##define SYS_close  21</span>
<span class="cp">##define SYS_trace  22</span>
</code></pre></div>
<h5 id="kernel-mode">kernel mode<a class="headerlink" href="#kernel-mode" title="Permanent link">Â¶</a></h5>
<p>åœ¨å†…æ ¸æ€ï¼Œæ‰§è¡Œsystem callçš„å…¥å£åœ¨<code>kernel/syscall.c</code>ä¸­ã€‚<code>uint64 (*syscalls[])(void)</code> æ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œç±»ä¼¼äºŽjavaä¸­çš„<code>Method[]</code>.</p>
<p><code>void syscall(void)</code>æ˜¯æ‰§è¡Œç³»ç»Ÿè°ƒç”¨çš„æ ¸å¿ƒä»£ç ï¼Œä»–ä»Žå½“å‰è¿›ç¨‹çš„é¡µè¡¨ä¸­å–å‡º<code>a7</code>ä¸­ä¿å­˜çš„ç³»ç»Ÿè°ƒç”¨å·ç ï¼Œç„¶åŽä»ŽæŒ‡é’ˆæ•°ç»„ä¸­å–å‡ºå¯¹åº”çš„å‡½æ•°å¹¶æ‰§è¡Œï¼Œå°†è¿”å›žå€¼å†™å…¥é¡µè¡¨çš„<code>a0</code>å¯„å­˜å™¨ä¸­ã€‚</p>
<p><code>kernel/syscall.c</code></p>
<div class="highlight"><pre><span></span><code><span class="k">static</span><span class="w"> </span><span class="n">uint64</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">syscalls</span><span class="p">[])(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="p">[</span><span class="n">SYS_fork</span><span class="p">]</span><span class="w">    </span><span class="n">sys_fork</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exit</span><span class="p">]</span><span class="w">    </span><span class="n">sys_exit</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_wait</span><span class="p">]</span><span class="w">    </span><span class="n">sys_wait</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_pipe</span><span class="p">]</span><span class="w">    </span><span class="n">sys_pipe</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_read</span><span class="p">]</span><span class="w">    </span><span class="n">sys_read</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_kill</span><span class="p">]</span><span class="w">    </span><span class="n">sys_kill</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_exec</span><span class="p">]</span><span class="w">    </span><span class="n">sys_exec</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_fstat</span><span class="p">]</span><span class="w">   </span><span class="n">sys_fstat</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_chdir</span><span class="p">]</span><span class="w">   </span><span class="n">sys_chdir</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_dup</span><span class="p">]</span><span class="w">     </span><span class="n">sys_dup</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_getpid</span><span class="p">]</span><span class="w">  </span><span class="n">sys_getpid</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_sbrk</span><span class="p">]</span><span class="w">    </span><span class="n">sys_sbrk</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_sleep</span><span class="p">]</span><span class="w">   </span><span class="n">sys_sleep</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_uptime</span><span class="p">]</span><span class="w">  </span><span class="n">sys_uptime</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_open</span><span class="p">]</span><span class="w">    </span><span class="n">sys_open</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_write</span><span class="p">]</span><span class="w">   </span><span class="n">sys_write</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_mknod</span><span class="p">]</span><span class="w">   </span><span class="n">sys_mknod</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_unlink</span><span class="p">]</span><span class="w">  </span><span class="n">sys_unlink</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_link</span><span class="p">]</span><span class="w">    </span><span class="n">sys_link</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_mkdir</span><span class="p">]</span><span class="w">   </span><span class="n">sys_mkdir</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_close</span><span class="p">]</span><span class="w">   </span><span class="n">sys_close</span><span class="p">,</span>
<span class="p">[</span><span class="n">SYS_trace</span><span class="p">]</span><span class="w">   </span><span class="n">sys_trace</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">void</span>
<span class="nf">syscall</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">num</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="n">num</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a7</span><span class="p">;</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">num</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">num</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">NELEM</span><span class="p">(</span><span class="n">syscalls</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">syscalls</span><span class="p">[</span><span class="n">num</span><span class="p">]();</span>
<span class="w">    </span><span class="c1">//print trace of syscall</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">mask</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">num</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d: systemcall %s -&gt; %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">              </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">syscallnames</span><span class="p">[</span><span class="n">num</span><span class="p">],</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d %s: unknown sys call %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="w">            </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">num</span><span class="p">);</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">a0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h5 id="get-args-from-user-mode">get <code>args</code> from user mode<a class="headerlink" href="#get-args-from-user-mode" title="Permanent link">Â¶</a></h5>
<p><code>kernel/sysproc.c</code> ä¸­è®°å½•äº†sys_traceçš„å…·ä½“å®žçŽ°ã€‚</p>
<p>ä»Ž<code>uint64 (*syscalls[])(void)</code>å¯ä»¥çœ‹å‡ºï¼Œæ‰€æœ‰çš„ç³»ç»Ÿè°ƒç”¨éƒ½æ²¡æœ‰å‚æ•°ä¼ å…¥ï¼Œè€Œä¸”è¿”å›žå€¼ç±»åž‹éƒ½ä¸ºuint64ã€‚é‚£ä¹ˆï¼Œ<strong>ç³»ç»Ÿè°ƒç”¨æ˜¯å¦‚ä½•ä»Žç”¨æˆ·æ€èŽ·å¾—ä¼ å…¥çš„å‚æ•°çš„å‘¢ï¼Ÿ</strong><code>kernel/syscall.c</code>ä¸­æä¾›äº†è®¸å¤šå‡½æ•°ç”¨äºŽä»Žç”¨æˆ·æ€æ‹¿åˆ°æ•°æ®å¹¶èµ‹å€¼ç»™å†…æ ¸æ€çš„å˜é‡ã€‚ä»¥<code>argint(0, &amp;mask)</code>ä¸ºä¾‹ï¼Œè¯¥å‡½æ•°å¯ä»¥å°†ç”¨æˆ·æ€ä¼ å…¥çš„ç¬¬0ä¸ªå‚æ•°èµ‹å€¼ç»™å†…æ ¸æ€å˜é‡maskã€‚</p>
<div class="highlight"><pre><span></span><code><span class="c1">//trace system calls of a process and its child process</span>
<span class="n">uint64</span>
<span class="nf">sys_trace</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>

<span class="w">  </span><span class="c1">//get 0th arg from user mode sys call trace(int mask)</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mask</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">mask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mask</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h4 id="sysinfo">Sysinfo<a class="headerlink" href="#sysinfo" title="Permanent link">Â¶</a></h4>
<p>ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹ä¸å†èµ˜è¿°ï¼Œè¿™ä¸€éƒ¨åˆ†çš„å®žéªŒæ¶‰åŠäº†processå’Œpage tableçš„éƒ¨åˆ†ä»£ç ï¼Œè¿™é‡Œä¸åšè¯¦è¿°ã€‚<strong>è¿™ä¸ªå®žéªŒçš„é‡ç‚¹åœ¨äºŽï¼Œå†…æ ¸æ€å¦‚ä½•æŠŠå†…æ ¸æ€ä¸­çš„å˜é‡è¿”å›žç»™ç”¨æˆ·æ€</strong>ã€‚<code>copyout(p-&gt;pagetable, st, (char *)&amp;xv6info, sizeof(xv6info))</code>åšåˆ°äº†è¿™ä¸€ç‚¹ï¼Œ<code>copyout</code>æ˜¯å¦‚ä½•åšåˆ°çš„ä¸æ˜¯è¿™ä¸ªlabçš„é‡ç‚¹ï¼Œä¼šåœ¨ä¹‹åŽçš„ç« èŠ‚ä¸­è®²æ˜Žã€‚</p>
<p><code>kernel/sysproc.c</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">//return sysinfo to user space</span>
<span class="n">uint64</span>
<span class="nf">sys_sysinfo</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">st</span><span class="p">;</span><span class="w"> </span><span class="c1">// user pointer to struct sysinfo</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">sysinfo</span><span class="w"> </span><span class="n">xv6info</span><span class="p">;</span>

<span class="w">  </span><span class="c1">//get syscall args[0]</span>
<span class="w">  </span><span class="c1">//in this case, the argument is a address</span>
<span class="w">  </span><span class="c1">//points to struct sysinfo</span>
<span class="w">  </span><span class="c1">//æ‹¿åˆ°ç”¨æˆ·æ€çš„å‚æ•°-&gt;ä¸€ä¸ªæŒ‡å‘sysinfoçš„æŒ‡é’ˆ</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">st</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="n">xv6info</span><span class="p">.</span><span class="n">freemem</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">free_memory</span><span class="p">();</span>
<span class="w">  </span><span class="n">xv6info</span><span class="p">.</span><span class="n">nproc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">num_process</span><span class="p">();</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="c1">//å°†å†…æ ¸æ€èŽ·å¾—çš„xv6infoæŒ‰å­—èŠ‚å¤åˆ¶åˆ°ä¹‹å‰èŽ·å¾—çš„ç”¨æˆ·åœ°å€æŒ‡å‘çš„å†…å­˜åŒºåŸŸä¸­</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">st</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">xv6info</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">xv6info</span><span class="p">))</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="lab-page-table">Lab: Page Table<a class="headerlink" href="#lab-page-table" title="Permanent link">Â¶</a></h3>
<div class="highlight"><pre><span></span><code>test sbrkbugs: usertrap(): unexpected scause 0x000000000000000c pid=3234
            sepc=0x0000000000005406 stval=0x0000000000005406
usertrap(): unexpected scause 0x000000000000000c pid=3235
            sepc=0x0000000000005406 stval=0x0000000000005406
</code></pre></div>
<h2 id="lab3-page-tables">Lab3 : Page Tables<a class="headerlink" href="#lab3-page-tables" title="Permanent link">Â¶</a></h2>
<h3 id="lab-31-print-a-page-table">Lab 3.1 Print a page table<a class="headerlink" href="#lab-31-print-a-page-table" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>Define a function called <code>vmprint()</code>. It should take a <code>pagetable_t</code> argument, and print that page table in the format described below. Insert <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> in <code>exec.c</code> just before the <code>return argc</code>, to print the first process's page table.</p>
<div class="highlight"><pre><span></span><code>page table 0x0000000087f6e000
..0: pte 0x0000000021fda801 pa 0x0000000087f6a000
.. ..0: pte 0x0000000021fda401 pa 0x0000000087f69000
.. .. ..0: pte 0x0000000021fdac1f pa 0x0000000087f6b000
.. .. ..1: pte 0x0000000021fda00f pa 0x0000000087f68000
.. .. ..2: pte 0x0000000021fd9c1f pa 0x0000000087f67000
..255: pte 0x0000000021fdb401 pa 0x0000000087f6d000
.. ..511: pte 0x0000000021fdb001 pa 0x0000000087f6c000
.. .. ..510: pte 0x0000000021fdd807 pa 0x0000000087f76000
.. .. ..511: pte 0x0000000020001c0b pa 0x0000000080007000
</code></pre></div>
<p>The first line displays the argument to <code>vmprint</code>. After that there is a line for each PTE, including PTEs that refer to page-table pages deeper in the tree. Each PTE line is indented by a number of <code>" .."</code> that indicates its depth in the tree. Each PTE line shows the PTE index in its page-table page, the <code>pte</code> bits, and the physical address extracted from the PTE. Don't print PTEs that are not valid. In the above example, the top-level page-table page has mappings for entries 0 and 255. The next level down for entry 0 has only index 0 mapped, and the bottom-level for that index 0 has entries 0, 1, and 2 mapped.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="c1">// Print pagetable</span>
<span class="c1">// display its three level tree</span>
<span class="kt">void</span>
<span class="nf">vmprint</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">printf</span><span class="p">(</span><span class="s">"page table %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">pagetable</span><span class="p">);</span>
<span class="w">  </span><span class="n">pteprint</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//A helper function to aid vmprint()</span>
<span class="kt">void</span>
<span class="nf">pteprint</span><span class="p">(</span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">512</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">pte_t</span><span class="w"> </span><span class="n">pte</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pagetable</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="c1">//pteæ˜¯éžå¶å­èŠ‚ç‚¹ï¼Œå…¶flagsçš„åŽå…«ä½åªæœ‰PTE_V = 1</span>
<span class="w">    </span><span class="k">if</span><span class="p">((</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_X</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// this PTE points to a lower-level page table.</span>
<span class="w">        </span><span class="c1">// print page table level</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">level</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">".."</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">uint64</span><span class="w"> </span><span class="n">child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">);</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d: pte %p pa %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">pte</span><span class="p">,</span><span class="w"> </span><span class="n">child</span><span class="p">);</span>
<span class="w">        </span><span class="n">pteprint</span><span class="p">((</span><span class="n">pagetable_t</span><span class="p">)</span><span class="w"> </span><span class="n">child</span><span class="p">,</span><span class="w"> </span><span class="n">level</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">((</span><span class="n">pte</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">PTE_V</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">//pteæ˜¯å¶å­èŠ‚ç‚¹ï¼Œå…¶flagsçš„åŽå…«ä½ä¸åªæœ‰PTE_V = 1</span>
<span class="w">        </span><span class="c1">// print page table level</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">level</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">          </span><span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">            </span><span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
<span class="w">          </span><span class="n">printf</span><span class="p">(</span><span class="s">".."</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"%d: pte %p pa %p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">pte</span><span class="p">,</span><span class="w"> </span><span class="n">PTE2PA</span><span class="p">(</span><span class="n">pte</span><span class="p">));</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<h3 id="lab-32-a-kernel-page-table-per-process">Lab 3.2 A kernel page table per process<a class="headerlink" href="#lab-32-a-kernel-page-table-per-process" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>Xv6 has a single kernel page table that's used whenever it executes in the kernel. The kernel page table is a direct mapping to physical addresses, so that kernel virtual address <em>x</em> maps to physical address <em>x</em>. Xv6 also has a separate page table for each process's user address space, containing only mappings for that process's user memory, starting at virtual address zero. Because the kernel page table doesn't contain these mappings, user addresses are not valid in the kernel. Thus, <strong>when the kernel needs to use a user pointer passed in a system call (e.g., the buffer pointer passed to <code>write()</code>), the kernel must first translate the pointer to a physical address</strong>. <strong>The goal of this section and the next is to allow the kernel to directly dereference user pointers.</strong></p>
</blockquote>
<h2 id="lab4-traps">Lab4: Traps<a class="headerlink" href="#lab4-traps" title="Permanent link">Â¶</a></h2>
<h3 id="lab-32-alarm">Lab 3.2 Alarm<a class="headerlink" href="#lab-32-alarm" title="Permanent link">Â¶</a></h3>
<p><code>kernel/proc.h</code></p>
<div class="highlight"><pre><span></span><code><span class="c1">// store the alarm interval and the pointer to the handler function</span>
<span class="c1">// for lab alarm</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ticks</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">passed_ticks</span><span class="p">;</span><span class="w">            </span><span class="c1">// how many ticks have passed since the last call</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span><span class="w">              </span><span class="c1">// the user space address of handler function</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">trapframe</span><span class="w"> </span><span class="o">*</span><span class="n">alarm_trapframe</span><span class="p">;</span><span class="w"> </span><span class="c1">// contains the state of the user process before calling sigalarm()</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">alarm_mode</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>
<p>ticksè¡¨ç¤ºå¤šå°‘ä¸ªæ—¶é’Ÿå‘¨æœŸè¿è¡Œä¸€æ¬¡handler</p>
<p>passed_ticksè¡¨ç¤ºå½“å‰è¿›ç¨‹ä»Žä¸Šä¸€æ¬¡å›žè°ƒå‡½æ•°ç»“æŸèµ·ç»è¿‡äº†å¤šå°‘ä¸ªæ—¶é’Ÿå‘¨æœŸ</p>
<p>handlerå­˜æ”¾çš„æ˜¯ç”¨æˆ·æ€ä¸‹handlerå‡½æ•°çš„åœ°å€</p>
<p><code>alarm_trapframe</code>ç”¨äºŽä¿å­˜è°ƒç”¨handleræ—¶ï¼Œç”¨æˆ·è¿›ç¨‹çš„çŠ¶æ€</p>
<p>alarm_modeè¡¨ç¤ºå½“å‰è¿›ç¨‹æ˜¯å¦å¤„åœ¨ä¸€ä¸ªalarmçŠ¶æ€ä¹‹ä¸­</p>
<hr>
<p><code>kernel/sysproc.c</code></p>
<div class="highlight"><pre><span></span><code><span class="n">uint64</span>
<span class="nf">sys_sigalarm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">ticks</span><span class="p">;</span>
<span class="w">  </span><span class="n">uint64</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// get ticks from user trapframe</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ticks</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// get handler address from user trapframe</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argaddr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">handler</span><span class="p">))</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// check if the process has already</span>
<span class="w">  </span><span class="c1">// been in a sigalarm</span>
<span class="w">  </span><span class="c1">// sigalarm(2, 0) cannot be called again</span>
<span class="w">  </span><span class="c1">// but sigalarm(0, 0) can be called to terminate</span>
<span class="w">  </span><span class="c1">// the sigalarm</span>
<span class="w">  </span><span class="c1">// è‹¥alarm_modeæ˜¯å¼€å¯çš„ä¸”ç”¨æˆ·å¹¶æ²¡æœ‰ä¼ æ¥åœæ­¢alarmçš„å‘½ä»¤ï¼ˆticks = 0ï¼‰</span>
<span class="w">  </span><span class="c1">// å†…æ ¸ä¸ä¼šæ‰§è¡Œæ–°çš„sigalarm()æŒ‡ä»¤</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm_mode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">ticks</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>

<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ticks</span><span class="p">;</span>
<span class="w">  </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">handler</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handler</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// sigalarm()åˆæ³•ï¼Œæ­¤æ—¶éœ€è¦åˆ¤æ–­ä»–æ˜¯å¼€å¯alarmå‘½ä»¤</span>
<span class="w">  </span><span class="c1">// è¿˜æ˜¯ç»“æŸalarmå‘½ä»¤</span>
<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">ticks</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">else</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm_mode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">uint64</span>
<span class="nf">sys_sigreturn</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">proc</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">();</span>
<span class="w">  </span><span class="c1">// æ¢å¤è°ƒç”¨handlerä¹‹å‰ç”¨æˆ·è¿›ç¨‹çš„çŠ¶æ€</span>
<span class="w">  </span><span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm_trapframe</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<hr>
<p><code>kernel/trap.c</code></p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="p">(</span><span class="n">which_dev</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">passed_ticks</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ticks</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">passed_ticks</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// save the user trapframe, since we will modify it</span>
<span class="w">      </span><span class="n">memmove</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">alarm_trapframe</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">passed_ticks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">trapframe</span><span class="o">-&gt;</span><span class="n">epc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">handler</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">yield</span><span class="p">();</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">usertrapret</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>
<p>è¿›ç¨‹æ¯è¿›å…¥ä¸€æ¬¡timer trapï¼Œå°±å¯¹passed_ticksåŠ ä¸€ã€‚å½“ç»è¿‡çš„æ—¶é’Ÿæ¬¡æ•°å’Œé¢„è®¾çš„ä¸€è‡´æ—¶ï¼Œè§¦å‘handlerï¼Œè¿™é‡Œå¹¶ä¸éœ€è¦æˆ‘ä»¬ä¸»åŠ¨åŽ»è°ƒç”¨handlerï¼Œå°†<code>trapframe</code>ä¸­è®°å½•è¿”å›žåœ°å€çš„<code>epc</code>æ”¹ä¸ºhandlerå³å¯ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå°†åŽŸæ¥çš„<code>trapframe</code>ä¿å­˜ä¸‹æ¥ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨è°ƒç”¨å®Œhandlerä¹‹åŽè¿˜éœ€è¦è¿”å›žç”¨æˆ·è¿›ç¨‹timerä¸­æ–­æ—¶çš„è¿è¡Œä½ç½®ã€‚</p>
<hr>
<p>æ³¨æ„ï¼štest 2 forkäº†ä¸€ä¸ªæ–°çš„è¿›ç¨‹åŒæ—¶å¹¶æ²¡æœ‰å…³é—­test 1å¼€å¯çš„alarmåŠŸèƒ½ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¿®æ”¹fork()éƒ¨åˆ†çš„ä»£ç ï¼Œè®©æ–°çš„è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹çš„alarmçŠ¶æ€ä¸€è‡´ã€‚</p>
<h2 id="lab5-lazy-allocation">Lab5 Lazy Allocation<a class="headerlink" href="#lab5-lazy-allocation" title="Permanent link">Â¶</a></h2>
<h3 id="lab-51-eliminate-allocation-from-sbrk">Lab 5.1 Eliminate allocation from <code>sbrk()</code><a class="headerlink" href="#lab-51-eliminate-allocation-from-sbrk" title="Permanent link">Â¶</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">uint64</span>
<span class="nf">sys_sbrk</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>

<span class="w">  </span><span class="k">if</span><span class="p">(</span><span class="n">argint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">  </span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// if(growproc(n) &lt; 0)</span>
<span class="w">  </span><span class="c1">//   return -1;</span>
<span class="w">  </span><span class="c1">// Only increase the size of the process</span>
<span class="w">  </span><span class="c1">// but allocate no memory for it</span>
<span class="w">  </span><span class="n">myproc</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">sz</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code>xv6 kernel is booting

init: starting sh
<span class="s">$</span><span class="nb"> echo hi</span>
<span class="nb">usertrap</span><span class="o">()</span><span class="nb">: unexpected scause </span><span class="m">0</span><span class="nb">x</span><span class="m">000000000000000</span><span class="nb">f pid</span><span class="o">=</span><span class="m">3</span>
<span class="nb">            sepc</span><span class="o">=</span><span class="m">0</span><span class="nb">x</span><span class="m">00000000000012</span><span class="nb">ac stval</span><span class="o">=</span><span class="m">0</span><span class="nb">x</span><span class="m">0000000000004008</span>
<span class="nb">panic: uvmunmap: not mapped</span>
</code></pre></div>
<h3 id="lab-52-lazy-allocation">Lab 5.2 Lazy Allocation<a class="headerlink" href="#lab-52-lazy-allocation" title="Permanent link">Â¶</a></h3>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220601212451904.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220601212451904" src="../../../../assets/Operating%20Systems.assets/image-20220601212451904.png"></a></p>
<div class="highlight"><pre><span></span><code><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="p">((</span><span class="n">which_dev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">devintr</span><span class="p">())</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// ok</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// store/AMO page fault</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">r_scause</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">15</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="c1">// è‹¥å‘ç”Ÿäº†æ— æ³•å†™å…¥çš„page fault</span>
<span class="w">      </span><span class="c1">// èŽ·å–æ— æ³•è®¿é—®çš„è™šæ‹Ÿåœ°å€</span>
<span class="w">      </span><span class="c1">// è¿™é‡Œè®¿é—®ä¸åˆ°çš„åŽŸå› ä¸»è¦æ˜¯æˆ‘ä»¬åŠ å…¥äº†æ‡’åˆ†é…</span>
<span class="w">      </span><span class="n">uint64</span><span class="w"> </span><span class="n">va</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r_stval</span><span class="p">();</span>
<span class="w">      </span><span class="n">uint64</span><span class="w"> </span><span class="n">va_downborder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">PGROUNDDOWN</span><span class="p">(</span><span class="n">va</span><span class="p">);</span>
<span class="w">      </span><span class="n">pagetable_t</span><span class="w"> </span><span class="n">pagetable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pagetable</span><span class="p">;</span>
<span class="w">      </span><span class="c1">// ç»™è¯¥è¿›ç¨‹åˆ†é…ä¸€é¡µå¤§å°çš„ç‰©ç†å†…å­˜</span>
<span class="w">      </span><span class="n">uint64</span><span class="w"> </span><span class="n">pa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">uint64</span><span class="p">)</span><span class="w"> </span><span class="n">kalloc</span><span class="p">();</span>
<span class="w">      </span><span class="c1">// è‹¥ç‰©ç†å†…å­˜å·²ç»æ»¡äº†ï¼Œé‚£ä¹ˆåªèƒ½æ€æŽ‰è¿›ç¨‹</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">pa</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>

<span class="w">      </span><span class="n">memset</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">);</span>
<span class="w">      </span><span class="c1">// ä½¿å¾—ç”¨æˆ·æ— æ³•è®¿é—®çš„é¡µè¡¨éƒ¨åˆ†ä¸Žæ–°åˆ†é…çš„ç‰©ç†å†…å­˜å»ºç«‹æ˜ å°„</span>
<span class="w">      </span><span class="c1">// ç»™äºˆå¥¹ä»¬å¯è¢«è¯»å†™çš„æƒé™</span>
<span class="w">      </span><span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">pagetable</span><span class="p">,</span><span class="w"> </span><span class="n">va_downborder</span><span class="p">,</span><span class="w"> </span><span class="n">PGSIZE</span><span class="p">,</span><span class="w"> </span><span class="n">pa</span><span class="p">,</span><span class="w"> </span><span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_R</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">){</span>
<span class="w">          </span><span class="n">kfree</span><span class="p">((</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="n">pa</span><span class="p">);</span>
<span class="w">          </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">      </span><span class="c1">// ä¹‹åŽä¸­æ–­è¿”å›žå‡ºçŽ°é”™è¯¯çš„ç¨‹åºåœ°å€ï¼Œç»§ç»­æ‰§è¡Œï¼Œè¿™æ—¶ä¹‹å‰æ— æ³•è¯»å†™çš„å†…å­˜åœ°å€å°±å¯ä»¥è¯»å†™äº†</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"usertrap(): unexpected scause %p pid=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r_scause</span><span class="p">(),</span><span class="w"> </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">"            sepc=%p stval=%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="w"> </span><span class="n">r_sepc</span><span class="p">(),</span><span class="w"> </span><span class="n">r_stval</span><span class="p">());</span>
<span class="w">      </span><span class="n">p</span><span class="o">-&gt;</span><span class="n">killed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">  </span><span class="p">}</span>
</code></pre></div>
<blockquote>
<p>trapæœ‰ä¸‰ç§å½¢å¼ï¼Œè¿™é‡Œæ˜¯åœ¨exceptionçš„æƒ…å†µä¸‹æ·»åŠ ä»£ç ã€‚</p>
<p>page faultä¸€èˆ¬æœ‰ä¸¤ç§åŽŸå› ï¼Œå¦‚å›¾ä¸­æ‰€ç¤ºï¼Œ13ä»£è¡¨æ— æ³•è¯»ï¼Œ15ä»£è¡¨æ— æ³•å†™ã€‚è¿™é‡Œçš„ç›®çš„ä»…ä»…åªä¸ºäº†èƒ½è®©<code>echo hi</code>æ­£å¸¸è¿è¡Œï¼Œæ‰€ä»¥æ²¡æœ‰è€ƒè™‘è¿‡å¤šç»†èŠ‚ã€‚</p>
</blockquote>
<h3 id="lab-53-lazytests-and-usertests">Lab 5.3 <code>Lazytests</code> and <code>Usertests</code><a class="headerlink" href="#lab-53-lazytests-and-usertests" title="Permanent link">Â¶</a></h3>
<blockquote>
<p>å®žéªŒ5.2ä»…ä»…å®žçŽ°äº†ä¸€ä¸ªåŸºæœ¬çš„åŠŸèƒ½ï¼Œä½†æ˜¯ä»–åªæ”¯æŒä¸ºæ²¡æœ‰åˆ†é…å†…å­˜çš„è™šæ‹Ÿåœ°å€ç©ºé—´å¢žåŠ å†…å­˜ï¼Œä½†æ²¡æœ‰è€ƒè™‘ç”¨æˆ·å¸Œæœ›é‡Šæ”¾å†…å­˜çš„è¯·æ±‚</p>
<p>è¿™ä¸€éƒ¨åˆ†å°±æ˜¯è¦è§£å†³è¿™ä¸€ç±»çš„è¾¹ç•Œé—®é¢˜ï¼Œä½¿å¾—ä»–å…·æœ‰å®Œæ•´çš„åŠŸèƒ½ã€‚</p>
</blockquote>
<p>freewalkæŒ‰ç…§pageçš„ä¸ªæ•°åˆ é™¤ï¼Œç„¶è€ŒçŽ°åœ¨æˆ‘ä»¬çš„é¡µè¡¨å¹¶ä¸æ˜¯è¿žç»­çš„</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220602222145739.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220602222145739" src="../../../../assets/Operating%20Systems.assets/image-20220602222145739.png"></a></p>
<p>ä¸ºä»€ä¹ˆä¼šé‡åˆ°è¿™ä¸ªé—®é¢˜ï¼Œå› ä¸ºåœ¨æˆ‘ä»¬ç¼©å°äº†sbrkä»¥åŽ</p>
<p>test02åˆå°è¯•å¾€æ²¡æœ‰æ˜ å°„çš„åœ°æ–¹å†™æ•°æ®ï¼Œè¿™æ—¶ä¸­æ–­å°±åˆä¼šç»™ä»–åˆ†é…ç©ºé—´ï¼Œ4å°±æ˜¯è¿™ä¹ˆè¢«åˆ†é…çš„</p>
<p>æ‰€ä»¥åº”è¯¥å…ˆåˆ¤æ–­vaæ˜¯å¦è¶…å‡ºäº†sizeï¼Œè‹¥æ²¡æœ‰æ‰èƒ½ä¸ºå®ƒåˆ†é…ç©ºé—´</p>
<p><code>kernel trapé—®é¢˜</code></p>
<p>user testsè¿›ä¸åŽ»ï¼Œä¸»è¦åŽŸå› æ˜¯<code>trap.c</code>é€»è¾‘å¤ªæ··ä¹±äº†ï¼Œéœ€è¦æ”¹ä¸€æ”¹ï¼Œé”™è¯¯åŽŸå› åœ¨äºŽå½“<code>kalloc</code>å¤±è´¥ä»…ä»…å°†killedè®¾ç½®æˆäº†1ï¼Œä½†ä¹‹åŽçš„æ­£å¸¸é€»è¾‘ä¾ç„¶ä¼šè¢«æ‰§è¡Œã€‚ä¹Ÿå°±æ˜¯è¯´å†…æ ¸ä»£ç åœ¨ä¿®æ”¹pa==0åœ°å€çš„ç‰©ç†å†…å­˜é‡Œçš„æ•°æ®ï¼Œæ‰€ä»¥kernelç›´æŽ¥å‡ºå‘äº†deviceé”™è¯¯ã€‚</p>
<p>// remap é”™è¯¯ æˆ‘ä»¬è™½ç„¶è§£å†³äº†ç”¨æˆ·ç›´æŽ¥åŽ»è¯»å†™æ²¡æœ‰åˆ†é…çš„vaçš„æƒ…å†µï¼Œæˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆæ˜¯åœ¨walkaddré‡Œåˆ¤æ–­vaæ˜¯ä¸æ˜¯åœ¨szä¹‹ä¸­ï¼Œæ˜¯çš„è¯å°±åˆ†é…ã€‚ç„¶è€Œï¼Œè¿™æ ·ä¸€æ¥ï¼Œæœ‰äº›æœ‰paï¿½ï¿½vaä¹Ÿä¼šè¢«æˆ‘ä»¬é‡æ–°åˆ†æ‰¹ç©ºé—´å¹¶remapï¼Œæ‰€ä»¥è¦åœ¨åˆ¤æ–­istouchableæ—¶å†ç¡®å®šï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½è¿™ä¸ªvaæ˜¯å¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½æ˜ å°„è¿‡äº†ã€‚</p>
<p><a class="glightbox" href="../../../../assets/Operating%20Systems.assets/image-20220603144057553.png" data-type="image" data-width="auto" data-height="auto" data-desc-position="bottom"><img alt="image-20220603144057553" src="../../../../assets/Operating%20Systems.assets/image-20220603144057553.png"></a></p></div>







  
  




  



      
    </article>
  </div>

          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
      <div class="md-progress" data-md-component="progress" role="progressbar"></div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../../../..", "features": ["navigation.instant", "navigation.instant.progress", "navigation.tabs", "navigation.path", "toc.integrate", "search.suggest", "search.share", "content.code.copy", "content.code.select", "content.code.annotate"], "search": "../../../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="../../../../../javascripts/mathjax.js"></script>
      
        <script src="https://unpkg.com/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  <script id="init-glightbox">const lightbox = GLightbox({"touchNavigation": true, "loop": false, "zoomable": true, "draggable": true, "openEffect": "zoom", "closeEffect": "zoom", "slideEffect": "slide"});
document$.subscribe(() => { lightbox.reload() });
</script></body>
</html>